<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shio&#39;s Psycology Life</title>
  <icon>https://ushio-s.github.io/icon.png</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ushio-s.github.io/"/>
  <updated>2020-06-09T08:49:54.493Z</updated>
  <id>https://ushio-s.github.io/</id>
  
  <author>
    <name>Shio</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[译文] JavaScript工作原理</title>
    <link href="https://ushio-s.github.io/2019-08-17/translation-how-javascript-works-part-3/"/>
    <id>https://ushio-s.github.io/2019-08-17/translation-how-javascript-works-part-3/</id>
    <published>2019-08-17T06:23:03.000Z</published>
    <updated>2020-06-09T08:49:54.493Z</updated>
    
    <content type="html"><![CDATA[<p>几周前我们开始了一个系列博文旨在深入挖掘 <code>JavaScript</code> 并弄清楚它的工作原理：我们认为通过了解 <code>JavaScript</code> 的构建单元并熟悉它们是怎样结合起来的，有助于写出更好的代码和应用。</p><p><a href="https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf" target="_blank" rel="noopener">本系列的第一篇文章</a>着重提供一个关于引擎、运行时和调用栈的概述。<a href="https://blog.sessionstack.com/how-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code-ac089e62b12e" target="_blank" rel="noopener">第二篇文章</a>深入分析了 <code>Google</code> 的 <code>V8</code> 引擎的内部实现并提供了一些编写更优质 <code>JavaScript</code> 代码的建议。</p><p>在第三篇的本文中，我们将会讨论另一个非常重要的主题，由于日常使用的编程语言的逐渐成熟和复杂性，它被越来越多的开发者忽视——内存管理。我们还会提供一些在 <code>SessionStack</code> 中遵循的关于如何处理 <code>JavaScript</code> 内存泄露的方法，我们必须保证 <code>SessionStack</code> 不会发生内存泄漏，或导致整合进来的应用增加内存消耗。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>像 <code>C</code> 这样的语言，具有低水平的内存管理原语如 <code>malloc()</code> 和 <code>free()</code>，这些原语被开发者用来显式地向操作系统分配和释放内存。</p><p>同时，<code>JavaScript</code> 在事物（对象、字符串等）被创建时分配内存，并在它们不再需要用到时自动释放内存，这个过程称为垃圾收集。这个看似自动释放资源的特性是困惑的来源，造成 <code>JavaScript</code>（和其他高级语言）开发者错误的印象，认为他们可以选择不必关心内存管理。<strong>这是个天大的误解。</strong></p><p>即便在使用高级编程语言时，开发者也应该了解内存管理（至少最基本的）。有时会遇到自动内存管理的问题（如垃圾收集器的BUG和实现限制等），开发者应该了解这些问题才能合理地处理它们（或找到适当的解决方案，用最小的代价和代码债）。</p><h2 id="内存生命周期"><a href="#内存生命周期" class="headerlink" title="内存生命周期"></a>内存生命周期</h2><p>无论使用哪种编程语言，内存的生命周期几乎总是相同的：</p><p><img src="https://upload-images.jianshu.io/upload_images/3497104-e3a78df47a3b1db9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="内存生命循环"></p><p>下面是周期中每个步骤发生了什么的概览：</p><ul><li><strong>分配内存</strong>——内存由允许程序使用的操作系统分配。在低级编程语言（如 <code>C</code>）中这是一个作为开发人员应该处理的显式操作。而在高级编程语言中是由语言本身帮你处理的。</li><li><strong>使用内存</strong>——这是程序实际上使用之前所分配内存的阶段。<strong>读写</strong>操作发生在使用代码中分配的变量时。</li><li><strong>释放内存</strong>——现在是释放不需要的整个内存的时候了，这样它才能变得空闲以便再次可用。与<strong>分配内存</strong>一样，在低级编程语言中这是一个显式操作。</li></ul><p>想要快速浏览调用栈和内存堆的概念，可以阅读我们关于这个主题的<a href="https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf" target="_blank" rel="noopener">第一篇文章</a>。</p><h2 id="什么是内存？"><a href="#什么是内存？" class="headerlink" title="什么是内存？"></a>什么是内存？</h2><p>在直接介绍 <code>JavaScript</code> 中的内存之前，我们会简要讨论一下内存是什么及它是怎样工作的。</p><p>在硬件层面，计算机内存由大量的<a href="https://baike.baidu.com/item/%E8%A7%A6%E5%8F%91%E5%99%A8/193146#viewPageContent" target="_blank" rel="noopener">触发器</a>组成。每个触发器包含几个晶体管能够存储一个比特（译注：1位）。可以通过<strong>唯一标识符</strong>来访问单个触发器，所以可以对它们进行读写操作。因此从概念上，我们可以把整个计算机内存想象成一个巨大的可读写的比特阵列。</p><p>作为人类，我们并不擅长使用字节进行所有的思考和算术，我们把它们组织成更大的组合，一起用来表示数字。8比特称为1个字节。除字节之外，还有其他词（有时是16比特、有时是32比特）。</p><p>很多东西存储在内存中：</p><ol><li>所有程序使用的所有变量和其他数据。</li><li>程序代码，包括操作系统的。</li></ol><p>编译器和操作系统一起工作来处理大部分的内存管理，但我们还是建议你了解一下底层发生的事情。</p><p>编译代码时，编译器可以检测到原始数据类型然后提前计算出需要多少内存。随后给<strong>栈空间</strong>中的程序分配所需额度。分配变量的空间被称为栈空间是因为当函数调用时，它们被添加到已有内存的顶部。当它们终止时，根据后进先出的原则被移除。例如，考虑如下声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int n; &#x2F;&#x2F; 4 bytes 4字节</span><br><span class="line">int x[4]; &#x2F;&#x2F; array of 4 elements, each 4 bytes 含有四个元素的数组，每个4字节</span><br><span class="line">double m; &#x2F;&#x2F; 8 bytes 8字节</span><br></pre></td></tr></table></figure><p>编译器能够立即看出这段代码需要<code>4+4*4+8=28</code>字节。</p><blockquote><p>这是现今处理整型和双精度浮点数的大小。20年以前，整型通常是2字节，双精度是4字节。代码永远不应该依赖当前基本数据类型的大小。</p></blockquote><p>编译器将会插入代码与操作系统交互，请求栈上存储变量所需的字节数。</p><p>在上面的例子中，编译器知道每个变量的精确内存地址。实际上，每当写入变量 <code>n</code>，它都会在内部被转换成类似“内存地址4127963”的东西。</p><p>注意，如果试图在这里访问 <code>x[4]</code>，将会访问到与 <code>m</code> 关联的数据。这是因为我们在访问数组中一个不存在的元素——比数组中最后实际分配的成员 <code>x[3]</code> 要远4个字节，这可能最终会读取（或写入）一些 <code>m</code> 中的比特。这必将会使程序其余部分产生非常不希望得到的结果。</p><p><img src="https://upload-images.jianshu.io/upload_images/3497104-8583390252fd72d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="变量内存分配"></p><p>当函数调用其他函数时，每个函数都会在被调用时得到属于自己的一块栈。这里不仅保存了所有的局部变量，还保存着记录执行位置的程序计数器。当函数结束时，它的内存单元再次变得空闲可供他用。</p><h2 id="动态分配"><a href="#动态分配" class="headerlink" title="动态分配"></a>动态分配</h2><p>不幸的是，当我们在编译时无法得知变量需要多少内存的时候事情就没那么简单了。假设我们要做如下的事情：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int n &#x3D; readInput(); &#x2F;&#x2F; reads input from the user</span><br><span class="line">...</span><br><span class="line">&#x2F;&#x2F; create an array with &quot;n&quot; elements</span><br></pre></td></tr></table></figure><p>这在编译时，编译器无法知道数组需要多少内存，因为它取决于用户提供的值。</p><p>因此无法为栈中的变量分配空间。相反，我们的程序需要在运行时显式向操作系统请求合适的空间。这种内存由<strong>堆空间</strong>分配。静态和动态内存分配的区别总结为下表：</p><p><img src="https://upload-images.jianshu.io/upload_images/3497104-96d9754761081376.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="静态内存分配与动态内存分配的区别"></p><p>要充分理解动态内存分配的原理，我们需要在<strong>指针</strong>上多花些时间，但这已经偏离了本文的主题。如果有兴趣学习更多，请在评论里留言告诉我们，我们可以在以后的文章中讨论更多关于指针的细节。</p><h2 id="JavaScript-中的分配"><a href="#JavaScript-中的分配" class="headerlink" title="JavaScript 中的分配"></a><code>JavaScript</code> 中的分配</h2><p>现在我们将解释第一步（分配内存）如何在 <code>JavaScript</code> 中工作。</p><p><code>JavaScript</code> 将开发者从内存分配的责任中解放出来——在声明变量的同时它会自己处理内存分配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var n &#x3D; 374; &#x2F;&#x2F; allocates memory for a number 为数值分配内存</span><br><span class="line">var s &#x3D; &#39;sessionstack&#39;; &#x2F;&#x2F; allocates memory for a string 为字符串分配内存</span><br><span class="line">var o &#x3D; &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: null</span><br><span class="line">&#125;; &#x2F;&#x2F; allocates memory for an object and its contained values  为对象及其包含的值分配内存</span><br><span class="line">var a &#x3D; [1, null, &#39;str&#39;];  &#x2F;&#x2F; (like object) allocates memory for the</span><br><span class="line">                           &#x2F;&#x2F; array and its contained values （与对象一样）为数组及其包含的值分配内存</span><br><span class="line">function f(a) &#123;</span><br><span class="line">  return a + 3;</span><br><span class="line">&#125; &#x2F;&#x2F; allocates a function (which is a callable object) 分配函数（即可调用对象）</span><br><span class="line">&#x2F;&#x2F; function expressions also allocate an object 函数表达式同样分配一个对象</span><br><span class="line">someElement.addEventListener(&#39;click&#39;, function() &#123;</span><br><span class="line">  someElement.style.backgroundColor &#x3D; &#39;blue&#39;;</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure><p>某些函数调用也产生对象分配：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var d &#x3D; new Date(); &#x2F;&#x2F; allocates a Date object 分配一个日期对象</span><br><span class="line">var e &#x3D; document.createElement(&#39;div&#39;); &#x2F;&#x2F; allocates a DOM element 分配一个DOM元素</span><br></pre></td></tr></table></figure><p>方法可以分配新的值或对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var s1 &#x3D; &#39;sessionstack&#39;;</span><br><span class="line">var s2 &#x3D; s1.substr(0, 3); &#x2F;&#x2F; s2 is a new string s2是一个新字符串</span><br><span class="line">&#x2F;&#x2F; Since strings are immutable, 由于字符串是不可变的</span><br><span class="line">&#x2F;&#x2F; JavaScript may decide to not allocate memory, JavaScript可能会决定不分配内存</span><br><span class="line">&#x2F;&#x2F; but just store the [0, 3] range. 而仅仅存储[0, 3]这个范围</span><br><span class="line">var a1 &#x3D; [&#39;str1&#39;, &#39;str2&#39;];</span><br><span class="line">var a2 &#x3D; [&#39;str3&#39;, &#39;str4&#39;];</span><br><span class="line">var a3 &#x3D; a1.concat(a2);</span><br><span class="line">&#x2F;&#x2F; new array with 4 elements being 含有四个元素的数组</span><br><span class="line">&#x2F;&#x2F; the concatenation of a1 and a2 elements 由a1和a2的元素的结合</span><br></pre></td></tr></table></figure><h2 id="在-JavaScript-中使用内存"><a href="#在-JavaScript-中使用内存" class="headerlink" title="在 JavaScript 中使用内存"></a>在 <code>JavaScript</code> 中使用内存</h2><p>在 <code>JavaScript</code> 中使用分配的内存基本上意味着在其中进行读写操作。</p><p>这可以通过读取或写入变量的值或对象属性、甚至向函数传参数的时候实现。</p><h2 id="在不需要内存时将其释放"><a href="#在不需要内存时将其释放" class="headerlink" title="在不需要内存时将其释放"></a>在不需要内存时将其释放</h2><p>大多数内存管理问题出现在这个阶段。</p><p>最大的难题是弄清楚何时不再需要分配的内存。通常需要开发者来决定这块内存在程序的何处不再需要并且释放它。</p><p>高级编程语言嵌入了一个叫做垃圾收集器软件，它的工作是追踪内存分配和使用以便发现分配的内存何时不再需要，并在这种情况下自动释放它。</p><p>不幸的是这个过程只是个近似的过程，因为知道是否还需要一些内存的一般问题是不可决定的（无法靠算法解决）。</p><p>大多数垃圾收集器的工作原理是收集不能再访问的内存，比如指向它的所有变量都超出作用域。但这也是对可收集内存空间的一种低估，因为在任何时候作用域内都仍可能有一个变量指向一个内存地址，然而它再也不会被访问。</p><h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><p>由于无法确定某些内存是否“不再需要”，垃圾收集实现了对一般解决方法的限制。这一节将会解释理解主要的垃圾收集算法的必要概念和局限性。</p><h2 id="内存引用"><a href="#内存引用" class="headerlink" title="内存引用"></a>内存引用</h2><p>垃圾收集算法依赖的主要概念之一是<strong>引用</strong>。</p><p>在内存管理的上下文中，如果一个对象可以访问另一个对象则说成是前者引用了后者（可是隐式也可是显式）。例如，<code>JavaScript</code> 对象有对其<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="noopener">原型</a>的引用（隐式引用）和对属性的引用（显式引用）。</p><p>在这个上下文中，”对象“的概念扩展到比常规 <code>JavaScript</code> 对象更广泛的范围，并且还包含函数作用域（或全局词法作用域）。</p><blockquote><p>词法作用域规定了如何解析嵌套函数中的变量名称：内层函数包含了父函数的作用域，即使父函数已返回。</p></blockquote><h2 id="引用计数垃圾收集"><a href="#引用计数垃圾收集" class="headerlink" title="引用计数垃圾收集"></a>引用计数垃圾收集</h2><p>这是最简单的垃圾收集算法。如果没有指向对象的引用，就被认为是“可收集的”。</p><p>看看如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">var o1 &#x3D; &#123;</span><br><span class="line">  o2: &#123;</span><br><span class="line">    x: 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; 2 objects are created.</span><br><span class="line">&#x2F;&#x2F; &#39;o2&#39; is referenced by &#39;o1&#39; object as one of its properties.</span><br><span class="line">&#x2F;&#x2F; None can be garbage-collected</span><br><span class="line">&#x2F;&#x2F; 创建了两个对象</span><br><span class="line">&#x2F;&#x2F; o2 被当作 o1 的属性而引用</span><br><span class="line">&#x2F;&#x2F; 现在没有可被收集的垃圾</span><br><span class="line"></span><br><span class="line">var o3 &#x3D; o1; &#x2F;&#x2F; the &#39;o3&#39; variable is the second thing that</span><br><span class="line">            &#x2F;&#x2F; has a reference to the object pointed by &#39;o1&#39;.</span><br><span class="line">            &#x2F;&#x2F; o3是第二个引用了o1 所指向对象的变量。</span><br><span class="line"></span><br><span class="line">o1 &#x3D; 1;      &#x2F;&#x2F; now, the object that was originally in &#39;o1&#39; has a</span><br><span class="line">            &#x2F;&#x2F; single reference, embodied by the &#39;o3&#39; variable</span><br><span class="line">            &#x2F;&#x2F; 现在，本来被 o1 指向的对象变成了单一引用，体现在 o3 上。</span><br><span class="line"></span><br><span class="line">var o4 &#x3D; o3.o2; &#x2F;&#x2F; reference to &#39;o2&#39; property of the object.</span><br><span class="line">                &#x2F;&#x2F; This object has now 2 references: one as</span><br><span class="line">                &#x2F;&#x2F; a property.</span><br><span class="line">                &#x2F;&#x2F; The other as the &#39;o4&#39; variable</span><br><span class="line">                &#x2F;&#x2F; 通过属性 o2 建立了对它所指对象的引用</span><br><span class="line">                &#x2F;&#x2F; 这个对象现在有两个引用：一个作为属性的o2</span><br><span class="line">                &#x2F;&#x2F; 另一个是变量 o4</span><br><span class="line"></span><br><span class="line">o3 &#x3D; &#39;374&#39;; &#x2F;&#x2F; The object that was originally in &#39;o1&#39; has now zero</span><br><span class="line">            &#x2F;&#x2F; references to it.</span><br><span class="line">            &#x2F;&#x2F; It can be garbage-collected.</span><br><span class="line">            &#x2F;&#x2F; However, what was its &#39;o2&#39; property is still</span><br><span class="line">            &#x2F;&#x2F; referenced by the &#39;o4&#39; variable, so it cannot be</span><br><span class="line">            &#x2F;&#x2F; freed.</span><br><span class="line">            &#x2F;&#x2F; 原本由 o1 引用的对象现在含有0个引用。</span><br><span class="line">            &#x2F;&#x2F; 它可以被作为垃圾而收集</span><br><span class="line">            &#x2F;&#x2F; 但是它的属性 o2 仍然被变量 o4 引用，所以它不能被释放。</span><br><span class="line"></span><br><span class="line">o4 &#x3D; null; &#x2F;&#x2F; what was the &#39;o2&#39; property of the object originally in</span><br><span class="line">           &#x2F;&#x2F; &#39;o1&#39; has zero references to it.</span><br><span class="line">           &#x2F;&#x2F; It can be garbage collected.</span><br><span class="line">           &#x2F;&#x2F; 原本由 o1 引用的对象的属性 o2 现在也只有0个引用，它现在可以被收集了。</span><br></pre></td></tr></table></figure><h2 id="循环制造出问题"><a href="#循环制造出问题" class="headerlink" title="循环制造出问题"></a>循环制造出问题</h2><p>这在循环引用时存在限制。在下面示例中，创建了两个互相引用的对象，从而创建了一个循环。它们在函数调用返回后超出作用域，所以实际上它们已经没用了并应该被释放。但引用计数算法考虑到由于它们至少被引用了一次，所以两者都不会被当作垃圾收集。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;</span><br><span class="line">  var o1 &#x3D; &#123;&#125;;</span><br><span class="line">  var o2 &#x3D; &#123;&#125;;</span><br><span class="line">  o1.p &#x3D; o2; &#x2F;&#x2F; o1 references o2</span><br><span class="line">  o2.p &#x3D; o1; &#x2F;&#x2F; o2 references o1. This creates a cycle.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f();</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/3497104-c8dcc3527e438f2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3-4.png"></p><h2 id="标记和清理算法"><a href="#标记和清理算法" class="headerlink" title="标记和清理算法"></a>标记和清理算法</h2><p>为了决定是否还需要对象，这个算法确定了对象是否可以访问。</p><p>标记和清理算法有如下三个步骤：</p><ol><li>根：通常，根是被代码引用的全局变量。例如在 <code>JavaScript</code> 中，可以作为根的全局变量是 <code>window</code> 对象。同一对象在 <code>Node.js</code> 中被称为 <code>global</code>。垃圾收集器建立了所有根的完整列表。</li><li>接着算法检查所有根及它们的子节点，并把它们标记为活跃的（意为它们不是垃圾）。根所不能获取到的任何东西都被标记为垃圾。</li><li>最终，垃圾收集器把未标记为活跃的所有内存片段释放并返还给操作系统。</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/3497104-a50363ce2d461e45.gif?imageMogr2/auto-orient/strip" alt="标记和清理算法的视觉化行为.gif"></p><p>这个算法比之前的更好，因为“一个对象没有引用”造成这个对象变得不可获取，但通过循环我们看到反过来却是不成立的。</p><p>2012年后，所有现代浏览器都装载了标记和清理垃圾收集器。近年来，在 <code>JavaScript</code> 垃圾收集所有领域的改善（分代/增量/并发/并行垃圾收集）都是这个算法（标记和清理）的实现改进，既不是垃圾收集算法自身的改进也并非决定是否对象可获取的目标的改进。</p><p>在<a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection" target="_blank" rel="noopener">这篇文章</a>中，你可以阅读到有关追踪垃圾收集的大量细节，并且涵盖了标记和清理及它的优化。</p><h2 id="循环不再是问题"><a href="#循环不再是问题" class="headerlink" title="循环不再是问题"></a>循环不再是问题</h2><p>在上面的第一个例子中，当函数调用返回后，两个对象不再被全局对象的可获取节点引用。结果是，它们会被垃圾收集齐认为是不可获取的。</p><p><img src="https://upload-images.jianshu.io/upload_images/3497104-86f205f631fe5f9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3-6.png"></p><p>即便它们彼此间仍存在引用，它们也不能被根获取到。</p><h2 id="垃圾收集器与直觉相反的行为"><a href="#垃圾收集器与直觉相反的行为" class="headerlink" title="垃圾收集器与直觉相反的行为"></a>垃圾收集器与直觉相反的行为</h2><p>虽然垃圾收集器很方便，但它们也有自己的一套折中策略。其一是非确定性。换句话说，垃圾收集是不可预测的。你无法确切知道垃圾收集什么时候执行。这意味着在一些情况下程序会要求比实际需要更多的内存。另一些情况下，短时暂停会在一些特别敏感的应用中很明显。虽然非确定性意味着无法确定垃圾收集执行的时间，但大多数垃圾收集的实现都共享一个通用模式：在内存分配期间进行收集。如果没有内存分配发生，垃圾收集器就处于闲置。考虑以下场景：</p><ol><li>执行大量内存分配。</li><li>它们大多数（或全部）被标记为不可获取（假设我们将一个不再需要的指向缓存的引用置为null）。</li><li>不再有进一步的内存分配发生。</li></ol><p>在这个场景下，大多数垃圾收集不会再运行收集传递。换言之，即时存在无法访问的引用可以收集，它们也不会被收集器注意到。这些不是严格意义上的泄露，但是仍然导致了比正常更高的内存使用。</p><h2 id="什么是内存泄露？"><a href="#什么是内存泄露？" class="headerlink" title="什么是内存泄露？"></a>什么是内存泄露？</h2><p>就像内存所暗示的，内存泄露是被应用使用过的一块内存在不需要时尚未返还给操作操作系统或由于糟糕的内存释放未能返还。</p><p><img src="https://upload-images.jianshu.io/upload_images/3497104-fb78f69509c706ed.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3-7.jpeg"></p><p>编程语言喜欢用不同的方式进行内存管理。但一块已知内存是否还被使用实际上是个无法决定的问题。换句话说，只有开发人员可以弄清除是否应该将一块内存还给操作系统。</p><p>某些编程语言提供了开发人员手动释放内存的特性。另一些则希望由开发人员完全提供显式的声明。维基百科上有关于<a href="https://en.wikipedia.org/wiki/Manual_memory_management" target="_blank" rel="noopener">手动</a>和<a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)" target="_blank" rel="noopener">自动</a>内存管理的好的文章。</p><h2 id="四种常见-JavaScript-泄露"><a href="#四种常见-JavaScript-泄露" class="headerlink" title="四种常见 JavaScript 泄露"></a>四种常见 <code>JavaScript</code> 泄露</h2><h3 id="1：全局变量"><a href="#1：全局变量" class="headerlink" title="1：全局变量"></a>1：全局变量</h3><p><code>JavaScript</code> 处理未声明变量的方式很有趣：当引用一个还未声明的变量时，就在全局对象上创建一个新变量。在浏览器中，全局对象是 <code>window</code>，这意味着：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function foo(arg) &#123;</span><br><span class="line">    bar &#x3D; &quot;some text&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function foo(arg) &#123;</span><br><span class="line">    window.bar &#x3D; &quot;some text&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们假设 <code>bar</code> 仅是为了在函数 <code>foo</code> 中引用变量。但如果不使用 <code>var</code> 声明，将创建一个多余的全局变量。在上面的例子中，并不会引起多大损害。但你仍可想到一个更具破坏性的场景。</p><p>你可以偶然地通过 <code>this</code> 创建一个全局变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    this.var1 &#x3D; &quot;potential accidental global&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Foo called on its own, this points to the global object (window)</span><br><span class="line">&#x2F;&#x2F; rather than being undefined.</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><blockquote><p>可以通过在 <code>JavaScript</code> 文件的开头添加 <code>&#39;use strict&#39;;</code> 来避免这一切，这会开启一个更加严格的模式来解析代码，它可以防止意外创建全局变量。</p></blockquote><p>意外的全局变量当然是个问题，但是通常情况下，你的代码会被显示全局变量污染，并且根据定义它们无法被垃圾收集器收集。应该尤其注意用来临时性存储和处理大量信息的全局变量。如果你必须使用全局变量存储信息而当你这样做了时，确保一旦完成之后就将它赋值为 <code>null</code> 或重新分配。</p><h3 id="2：被遗忘的计时器或回调"><a href="#2：被遗忘的计时器或回调" class="headerlink" title="2：被遗忘的计时器或回调"></a>2：被遗忘的计时器或回调</h3><p>让我们来看看 <code>setInterval</code> 的列子，它在 <code>JavaScript</code> 中经常用到。</p><p>提供观察者模式的库和其他接受回调函数的实现通常会在它们的实例无法获取确保对这些回调函数的引用也变成无法获取。同样，下面的代码不难找到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var serverData &#x3D; loadData();</span><br><span class="line">setInterval(function() &#123;</span><br><span class="line">    var renderer &#x3D; document.getElementById(&#39;renderer&#39;);</span><br><span class="line">    if(renderer) &#123;</span><br><span class="line">        renderer.innerHTML &#x3D; JSON.stringify(serverData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, 5000); &#x2F;&#x2F;This will be executed every ~5 seconds.</span><br></pre></td></tr></table></figure><p>上面这段代码展示了引用不再需要的节点或数据的后果。</p><p><code>renderer</code> 对象可能在某个时候被覆盖或移除，这将会导致封装在间隔处理函数中的语句变得冗余。一旦发生这种情况，处理器和它依赖的东西必须要等到间隔器先被停止之后才能收集（记住，它依然是活跃的）。这将会导致这样的事实：用于储存和处理数据的 <code>serverData</code> 也将不会被收集。</p><p>当使用观察者模式时，你需要在完成后确保通过显示调用移除它们（既不再需要观察者，对象也变成不可获取的）。</p><p>幸运的是，大多数现代浏览器会为我们处理好这些事务：它们会自动收集被观察对象变成不可获取的观察者处理器，即使你忘记移除这些监听器。过去一些浏览器是无法做到这些的（老IE6）。</p><p>不过，符合最佳实践的还是在对象过时时移除观察者。来看下面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var element &#x3D; document.getElementById(&#39;launch-button&#39;);</span><br><span class="line">var counter &#x3D; 0;</span><br><span class="line">function onClick(event) &#123;</span><br><span class="line">   counter++;</span><br><span class="line">   element.innerHtml &#x3D; &#39;text &#39; + counter;</span><br><span class="line">&#125;</span><br><span class="line">element.addEventListener(&#39;click&#39;, onClick);</span><br><span class="line">&#x2F;&#x2F; Do stuff</span><br><span class="line">element.removeEventListener(&#39;click&#39;, onClick);</span><br><span class="line">element.parentNode.removeChild(element);</span><br><span class="line">&#x2F;&#x2F; Now when element goes out of scope,</span><br><span class="line">&#x2F;&#x2F; both element and onClick will be collected even in old browsers &#x2F;&#x2F; that don&#39;t</span><br><span class="line">handle cycles well.</span><br><span class="line">&#x2F;&#x2F; 现在，当元素超出作用域之后，</span><br><span class="line">&#x2F;&#x2F; 即使是不能很好处理循环的老浏览器也能将元素和点击处理函数回收。</span><br></pre></td></tr></table></figure><p>在使节点变成不可获取之前不再需要调用 <code>removeEventListener</code>，因为现代浏览器支持垃圾收集器可以探测这些循环并进行适当处理。</p><p>如果你利用 <code>jQuery APIs</code>（其他库和框架也支持），它也可以在节点无效之前移除监听器。这个库也会确保没有内存泄露发生，即使应用运行在老浏览器之下。</p><h3 id="3：闭包"><a href="#3：闭包" class="headerlink" title="3：闭包"></a>3：闭包</h3><p><code>JavaScript</code> 开发的核心领域之一是闭包：内层函数可以访问外层（封闭）函数的变量。 归咎于 <code>JavaScript</code> 运行时的实现细节，可能发生下面这样的内存泄露：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var theThing &#x3D; null;</span><br><span class="line">var replaceThing &#x3D; function () &#123;</span><br><span class="line">  var originalThing &#x3D; theThing;</span><br><span class="line">  var unused &#x3D; function () &#123;</span><br><span class="line">    if (originalThing) &#x2F;&#x2F; a reference to &#39;originalThing&#39;</span><br><span class="line">      console.log(&quot;hi&quot;);</span><br><span class="line">  &#125;;</span><br><span class="line">  theThing &#x3D; &#123;</span><br><span class="line">    longStr: new Array(1000000).join(&#39;*&#39;),</span><br><span class="line">    someMethod: function () &#123;</span><br><span class="line">      console.log(&quot;message&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">setInterval(replaceThing, 1000);</span><br></pre></td></tr></table></figure><p>当 <code>replaceThing</code> 调用后，<code>theThing</code> 被赋值为一个对象，由一个大数组和一个新的闭包（<code>someMethod</code>）组成。还有，<code>originalThing</code> 被变量 <code>unused</code> 拥有的闭包所引用（值是上一次 <code>replaceThing</code> 调用所得到的变量 <code>theThing</code> ）。要记住的是<strong>当一个闭包作用域被创建时，位于同一个父作用域内的其他闭包也共享这个作用域。</strong></p><p>在这个案列中，为闭包 <code>someMethod</code> 创建的作用域被 <code>unused</code> 共享。即便 <code>unused</code> 从未使用，<code>someMethod</code> 可以通过位于 <code>replaceThing</code> 外层的 <code>theThing</code> 使用（例如，在全局中）。又因为 <code>someMethod</code> 与 <code>unused</code> 共享闭包作用域，<code>unused</code> 引用的 <code>originalThing</code> 被强制处于活跃状态（在两个闭包之间被共享的整个作用域）。这些妨碍了被收集。</p><p>在上述列子中，当 <code>unused</code> 引用了 <code>originalThing</code> 时，共享了为 <code>someMethod</code> 创建的作用域。可以通过 <code>replaceThing</code> 作用域外的 <code>theThing</code> 使用 <code>someMethod</code>，且不管其实 <code>unused</code> 从未使用。事实上 <code>unused</code> 引用了 <code>originalThing</code> 使其保持在活跃状态，因为<code>someMethod</code> 与 <code>unused</code> 共享了闭包作用域。</p><p>所有的这些导致了相当大的内存泄露。你会看到在上述代码一遍又一遍运行时内存使用量的激增。它不会在垃圾收集器运行时变小。一系列的闭包被创建（此例中根是变量 <code>theThing</code>），每一个闭包作用域都间接引用了大数组。</p><p><code>Meteor</code> 团队发现了这个问题，他们有<a href="https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156" target="_blank" rel="noopener">一篇非常棒的文章</a>详细描述了这个问题。</p><h3 id="4：外部DOM引用"><a href="#4：外部DOM引用" class="headerlink" title="4：外部DOM引用"></a>4：外部DOM引用</h3><p>还有种情况是当开发人员把 <code>DOM</code> 节点储存在数据结构里的时候。假设你想快速更新表格中某几行的内容。如果把对每行的 <code>DOM</code> 引用存在字典中或数组中，就会存在对相同 <code>DOM</code> 元素的两份引用：一份在 <code>DOM</code> 树中一份在字典里。如果想移除这些行，你得记着要把这两份引用都变成不可获取的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var elements &#x3D; &#123;</span><br><span class="line">    button: document.getElementById(&#39;button&#39;),</span><br><span class="line">    image: document.getElementById(&#39;image&#39;)</span><br><span class="line">&#125;;</span><br><span class="line">function doStuff() &#123;</span><br><span class="line">    elements.image.src &#x3D; &#39;http:&#x2F;&#x2F;example.com&#x2F;image_name.png&#39;;</span><br><span class="line">&#125;</span><br><span class="line">function removeImage() &#123;</span><br><span class="line">    &#x2F;&#x2F; The image is a direct child of the body element.</span><br><span class="line">    &#x2F;&#x2F; 图片是body的直接子元素</span><br><span class="line">    document.body.removeChild(document.getElementById(&#39;image&#39;));</span><br><span class="line">    &#x2F;&#x2F; At this point, we still have a reference to #button in the</span><br><span class="line">    &#x2F;&#x2F;global elements object. In other words, the button element is</span><br><span class="line">    &#x2F;&#x2F;still in memory and cannot be collected by the GC.</span><br><span class="line">    &#x2F;&#x2F; 这时，全局elements对象仍有一个对#button元素的引用。换句话说，button元素</span><br><span class="line">    &#x2F;&#x2F; 仍然在内存里，无法被垃圾收集器回收。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个例外情况应该被考虑到，它出现在引用 <code>DOM</code> 树的内部或叶节点时。如果你在代码里保存了一个对表格单元（<code>td</code> 标签）的引用，然后决定把表格从 <code>DOM</code> 中移除但保留对那个特别单元格的引用，就能预料到将会有大量的内存泄露。你可能认为垃圾收集器将释放其他所有的东西除了那个单元格。但是，这将不会发生。因为这个单元格是表格的一个子节点，子节点保存了对它们父节点的引用，<strong>引用这一个单元格将会在内存里保存整个表格。</strong></p>]]></content>
    
    <summary type="html">
    
      在第三篇的本文中，我们将会讨论另一个非常重要的主题，由于日常使用的编程语言的逐渐成熟和复杂性，它被越来越多的开发者忽视——内存管理。
    
    </summary>
    
    
      <category term="Dev" scheme="https://ushio-s.github.io/categories/Dev/"/>
    
    
      <category term="Translation" scheme="https://ushio-s.github.io/tags/Translation/"/>
    
      <category term="JavaScript" scheme="https://ushio-s.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>理解JavaScript核心知识点：原型</title>
    <link href="https://ushio-s.github.io/2019-07-08/understanding-javascript-core-prototype/"/>
    <id>https://ushio-s.github.io/2019-07-08/understanding-javascript-core-prototype/</id>
    <published>2019-07-08T09:13:28.000Z</published>
    <updated>2020-06-09T08:56:16.710Z</updated>
    
    <content type="html"><![CDATA[<p><code>JavaScript</code> 中的原型机制一直以来都被众多开发者（包括本人）低估甚至忽视了，这是因为绝大多数人没有想要深刻理解这个机制的内涵，以及越来越多的开发者缺乏计算机编程相关的基础知识。对于这样的开发者来说 <code>JavaScript</code> 的原型机制是一个尚待发掘的大宝藏，深入了解下去会让大家在编程这条路上走得更长远，当然你不能妄想任何一种机制、模式或范式是完美无缺的。</p><p>首先，需要来理清一些基础的计算机编程概念：</p><h2 id="编程哲学与设计模式：Programming-Philosophy-and-Design-Pattern"><a href="#编程哲学与设计模式：Programming-Philosophy-and-Design-Pattern" class="headerlink" title="编程哲学与设计模式：Programming Philosophy and Design Pattern"></a>编程哲学与设计模式：Programming Philosophy and Design Pattern</h2><p>计算机编程理念源自于对现实抽象的哲学思考，面向对象编程（<a href="https://baike.baidu.com/item/OOP/1152915" target="_blank" rel="noopener">OOP</a>）是其一种思维方式，与它并驾齐驱的是另外两种思路：过程式和函数式编程。这三种方式对应于解决计算机架构问题的三种不同思路。它们也分别代表了不同的编程哲学。</p><p>具体实现编程架构的代码方案可以称为设计模式。设计模式是解决具体问题的一种最佳实践，可以用在设计语言本身，也可以用在具体业务场景中。</p><p>三种思路在语言本身的设计和应用业务中是可能混用的，灵活的语言正如 <code>JavaScript</code> ，内部虽然是基于面向对象编程而实现，但在开发过程中也可以运用过程式编程或函数式编程的思路进行具体业务的设计。正因为这容易造成开发者的混乱，所以特别指出，下面一段讨论的是针对语言内部的实现方式而不是应用业务。</p><p>面向对象编程语言的核心是对象，针对如何设计出一套语言的对象模型编程大师们又提出了三种不同的模式：类、原型、元类（元类是基于类模型产生的新模型）。三种模型造就了许多不同的编程语言，<code>JavaScript</code> 恰好是原型模式的典型代表，正如 <code>JAVA</code> 是基于类模式的典范，请谨记这一语言本身在设计模式上的区别。</p><p>很多语言由于自身的实现而限制了在其中可能应用到业务中的设计模式。但对于 <code>JavaScript</code> 这样的语言来说，选择是开放性的，因为我们经常在应用业务上听到大家讨论类继承或原型继承这样的实现方案，这便是它非常灵活的一个表现。但对于类模式和原型模式，有一些本质上的概念区别和使用混淆是很多人没有注意到的，下面对这两种设计模式做一个详细的讨论。</p><h2 id="作为一种设计模式的类：”Class”-Design-Pattern"><a href="#作为一种设计模式的类：”Class”-Design-Pattern" class="headerlink" title="作为一种设计模式的类：”Class” Design Pattern"></a>作为一种设计模式的类：”Class” Design Pattern</h2><p>基于类的应用或业务架构实现可以称为类设计模式，我们在业务开发中不可避免地会使用到继承的概念便是出自于<strong>类</strong>的范畴。类不专属于 <code>JavaScript</code> 语言范畴，<code>JavaScript</code> 中实质上也没有实现真正的基于类设计模式的接口。<code>JavaScript</code> 中一切关于“类”的说法实际上都是一种有名无实的冒充和混淆。</p><p>我们通常以为在 <code>JavaScript</code> 中“类”是必选的，使用它来实现业务架构不仅天经地义而且是唯一的——这是对 <code>JavaScript</code> 的最大误解。<code>JavaScript</code> 虽然是面向对象的编程语言，但以类作为对象模型来实现业务需求的方式只能说是一种设计模式：<strong>面向对象绝不等同于类</strong>。</p><p>类是一份产品制造说明书，指导生产机器生产符合其定义参数、具有相应功能的产品。它的用途在于规定而不在于实际使用，使用的是通过类制造出来的产品，在 <code>JavaScript</code> 中即对象。我们基于复用、继承等工业化生产需求而使用类这套设计模式：<strong>规定 -&gt; 制造 -&gt; 使用</strong>。但我们千万不能忘记，在工业化时代出现之前，通过手工的方式一样可以制造产品，如果你需要批量生产模样一样的东西才需要这份产品制造说明说。就手段来说要澄清的一个误区是，<strong>类并不是实现功能复用、广义上的继承等业务目标的唯一模式</strong>。</p><h3 id="类：What’s-Class"><a href="#类：What’s-Class" class="headerlink" title="类：What’s Class"></a>类：What’s Class</h3><p><strong>类</strong>，是面向对象编程中一种通用对象模型，它是基于一种对现实中事物进行分类的抽象，天生带有类别层级的观念，如<strong>生物</strong>是一级类、<strong>动物</strong>是一个具有所有生物特性而派生出自己独有特性的二级类，依照这样的逻辑还可以继续推及到其下更多细别的子类，这是一种将所有对象进行树状类别组织关联的思维方式：</p><p><img src="https://upload-images.jianshu.io/upload_images/3497104-17fabbbd6b39cbc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="类-分类"></p><p>通过这张图可以得出一个显而易见却容易被忽视的事实：永远没有一只具体的哺乳动物（比如说一只狮子）等同于<strong>哺乳动物</strong>这个类别，就像你不等于人类一样。类是一个并不具有实体的概念，是人为的发明，为了将具有类似特性的事物分门别类以适应人脑简化处理信息的方式，尽管自然并不是出于这样的目的而生成各种事物的。</p><p><code>JavaScript</code> 中类的概念也是人为的设计，为的是更靠近本身以类模式设计而成的语言，尽管它本身是以原型模式设计而成的。因此我们有了 <code>new</code> 一个对象这种操作，为的是更符合采用类这一设计模式来实践面向对象编程。所以在此处埋下了第一个令人迷惑的种子：<code>JavaScript</code> 原生基于原型关联起来的对象与基于类创建的与类关联起来的对象两种概念的混淆。对于发现了这一对使人迷惑的概念的开发者来说，便有了第一个疑问：</p><p><strong>为什么基于原型模式设计而成的 <code>JavaScript</code> 不继续在业务场景中使用原型设计模式，而是转而求向类设计模式？</strong></p><p>之前有过说明，实践面向对象编程的方式有三种的，并且没有任何一种是完美无缺的。所以请把类模式是最好的这种想法抛到九霄云外吧。暂且将这个问题移到潜意识中去，继续了解一下类范畴的的其他相关概念。</p><h3 id="实例：What’s-Instance"><a href="#实例：What’s-Instance" class="headerlink" title="实例：What’s Instance"></a>实例：What’s Instance</h3><p>实例的概念基于类之上。正如自然界中单一的个体即是它所属类别中的一个实例，面向对象语言中的一个对象就是它所属类中的一个实例。语言通过类的规定，生成了具有内存实体的对象。在这样的语言中，实例和对象的指代物是一致的，我们通常在类设计模式中采用实例来描述一个内存实体，而在编程实践中使用对象来描述一个内存实体，其实是在不同层面上的语言转换。理解这种词语的转换，对于我们在阅读各种技术书籍时了解作者所选择的表述视角是有帮助的。</p><p>创建实例操作的结果是将类的属性和方法分别复制到不同的实例对象中，它们持有各自独立的版本，这也意味着每一个由同一个类创建出的实例都是各自独立互不影响的个体。</p><p>而在 <code>JavaScript</code> 中，事情就变得没那么简单了。不管在它的设计者设计出模拟类模式的原生 <code>API</code> 之前还是之后（当然官方一直有关于类的语法糖的支持），<code>JavaScript</code> 的世界实际上都是由且只由对象组成。当你创建了一个构造器函数或使用 <code>ES6</code> 的类定义语法时，其实质根本没有真的定义了类，它是由对象伪装而成的。</p><p>在这一事实的基础上，就能发现既然“类”也是对象，那么我们本以为应用类模式建立的类与实例之间的纯粹关系就被基于对象的模拟打破了。使用上面那个大自然的归类例子再来解释下这是什么意思：当哺乳动物这一类别是一只狮子时，它既是具体又是抽象的，作为一个类这只狮子囊括了所有的哺乳动物，它是凌驾于其他具体生物之上的；作为一个具体生物它又是被包含进它本身的…这似乎变成了一个逻辑问题。</p><p>人类在采用类这一概念时就已经将这个概念进行了抽象，它不指代任何具体的个体，即便它是一份具有实体的蓝图，也是与遵循它创造出来的物品不相同的东西。而在 <code>JavaScript</code> 里所发生的正是与之相矛盾的，它对于类模式的模拟实现其实是对类模式的颠覆。</p><h3 id="继承：What’s-Inheritance"><a href="#继承：What’s-Inheritance" class="headerlink" title="继承：What’s Inheritance"></a>继承：What’s Inheritance</h3><p>继承是类范畴里的重要概念，也是我们之所以要使用类的重要理由。继承的目的是为了实现属性或功能复用，顺便减少编写代码的机械操作。类模式的继承操作使子类拥有已经在父类里定义的属性或方法，继承而来的属性或方法是子类所有的独立版本，子类可以在此基础上继续修改已继承的属性或方法，并且扩展属于自己的属性或方法。</p><p>继承即是基于现实中类别的多级抽象。前面图示中所列出的树状结构就是对继承很好的说明。在自然过程中，我们从祖先那里继承而来的基因是属于复制而来的独立版本，现实中当然不存在继承而来的一模一样的基因，但即便是一模一样的基因序列，也是各自独立的版本，你身体中的基因再也不是祖先身体中的那个基因了。</p><p>尤其强调<strong>独立</strong>这个词，是因为类模式如实地实现了对自然界这一复制过程的模拟，而在 <code>JavaScript</code> 这一基于原型模式设计的语言中，我们又一次被它的表面类模式糊弄了。</p><p>在真正的类模式中，不管是父类还是子类都是独立封装好的一份规格，如果一个子类没有继承到父类的某一属性或方法它自身也没有进行扩展时，它的实例是不可能使用这个属性或方法的。很明显 <code>JavaScript</code> 中的继承“<em>完美解决了这个问题</em>”，即便一个“类”自己没有继承也没有扩展某个属性或方法，它创造出的实例还可以从祖先那里<strong>借用</strong>。</p><p>结合实例一节所述，于是第二个问题呼之欲出：<strong>除了写法相似之外，<code>JavaScript</code> 中几乎所有与类相关的概念和行为都同惯常的类模式不那么相符，这真的可以被称为是类模式的实现么？</strong></p><p>基于以上两个问题对自己进行了灵魂拷问，终于决定要来仔细瞧瞧 <code>JavaScript</code> 中一直被当做类的影子的那个亲骨肉——原型。</p><h2 id="作为一种机制的原型：”Prototype”-Mechanism"><a href="#作为一种机制的原型：”Prototype”-Mechanism" class="headerlink" title="作为一种机制的原型：”Prototype” Mechanism"></a>作为一种机制的原型：”Prototype” Mechanism</h2><p>在词汇语义上，原型的概念就与类所区别：<strong>原型是一个最初的对象</strong>。类的逻辑在于将已存在事物划分层次，达到概括事物或分类的目的；原型的逻辑中没有抽象的层级，它是根据已存在事物寻找能代表它最初的最本源的那一个，层层溯源，途径的都是具象的。恐怕原型的概念对于熟稔哲学的人来说比类更为亲切。它在编程上的思想是：<strong>新的物体藉由复制原型产生</strong>。</p><p><img src="https://upload-images.jianshu.io/upload_images/3497104-944b5d225e43ee33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="原型和类"></p><p><code>JavaScript</code> 的原型机制就遵循了一定程度原型哲学的思路。而原型机制是 <code>JavaScript</code> 所特有的。原型机制的实现是，对象有一个内部属性指向另一个对象，将二者联结起来的属性的变量名就是我们熟悉的 <code>__proto__</code>，它暴露了内部实现的原型，被指向的对象被称为前者的原型，通常用 <code>obj.__proto__</code> 来指代 <code>obj</code> 这个对象的原型。除此之外别忘记，这只是那个真实的原型对象的别称。例如 <code>origin</code> 是另一个对象，以下这条语句就建立了这两个对象的原型关联关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let obj &#x3D; &#123;&#125;</span><br><span class="line">let origin &#x3D; &#123;&#125;</span><br><span class="line">obj.__proto__ &#x3D; origin</span><br></pre></td></tr></table></figure><p>你可以使用 <code>origin</code> 引用它指向的那个对象，其实质是一个内存地址，也可以使用 <code>obj.__proto__</code> 来引用同样的内存地址。作为一个单独个体的对象和一个作为别的对象的原型的对象是合而为一的。（实际开发中不要直接使用 <code>__proto__</code> ，此处只是为了简便。应该用 <code>Object.getPrototypeOf()</code> 方法获取原型对象）</p><p>原型机制用一句话概括就是：<strong>将单个对象建立起原型关联关系的过程。</strong></p><h3 id="原型：What’s-Prototype"><a href="#原型：What’s-Prototype" class="headerlink" title="原型：What’s Prototype"></a>原型：What’s Prototype</h3><p>原型的语义概念上面已经介绍了，现在专门讲讲 <code>JavaScript</code> 中的原型。在 <code>JavaScript</code> 中，一切都是对象，那么这个世界总要有一个本源性的对象，就像上图中的原核生物一样，从它一生二而生成万物。的确，这样的一个被称为最初的原型的对象是存在的，它就是 <code>Object.prototype</code>，原因是它再也无法向上追溯到任何对象了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.__proto__ &#x3D;&#x3D;&#x3D; null</span><br></pre></td></tr></table></figure><p>这里我们要知道 <code>null</code> 代表的是“没有”的意思。因此 <code>JavaScript</code> 的世界是从 <code>Object.prototype</code> 开始的。使用过 <code>JavaScript</code> 的开发者必定对这个对象印象深刻，但可能很多人从来没有从这个视角看待它。</p><p>从它衍生出的一个重要的对象是一个函数 <code>Object</code>，它被称为构造函数，尽管由 <code>Object</code> 构造函数创建出来的对象的原型都是指向 <code>Object.prototype</code> 的，但它自己的原型对象却并不是 <code>Object.prototype</code>，而是 <code>Function.prototype</code>， <code>Function.prototype</code> 的原型才指向的是 <code>Object.prototype</code>，从这里我们可以隐隐窥见原型继承的精髓。</p><p>再次强调一下，<code>Object</code> 是一个名字叫做“对象”的函数，<code>Object.prototype</code> 是一个叫做“对象构造器原型”的对象，与其他的原生构造器原型对象一样，这些对象都是没有自己独立名称的对象。在学习 <code>JavaScript</code> 时，必须好好区分这些基础概念。</p><h3 id="原型链：Prototype-Chain"><a href="#原型链：Prototype-Chain" class="headerlink" title="原型链：Prototype Chain"></a>原型链：Prototype Chain</h3><p>原型链是原型继承得以实现的基础，但其实在原型中使用“继承”这个词是不那么准确的。原型链是内部机制通过私有的“原型”属性实现对象之间的关联而形成的一条链式属性查找规则。它是单向度的，只能向上回溯，作为原型的对象无法查找它的继承者们的任何属性和方法。</p><p>原型链机制为 <code>JavaScript</code> 提供了实现强大功能的基础，但可以想象，每次查找都是要花费额外开销的，链条越长，开销越大。它具有一个奇特的特点，即便某个对象上并未定义变量它也不会导致程序报错，而是得到 <code>undefined</code>，这正是原型链机制自动查找属性的一个后果。在没有必要的情况下，应该避免编写造成无谓的原型链查找的代码。</p><p>我们时常需要通过判断一个对象的属性存在与否实现一些分支判断，现在假设一条原型链是这样的，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj5 -&gt; obj4 -&gt; obj3 -&gt; obj2 -&gt; obj1</span><br></pre></td></tr></table></figure><p>它们都不具有一个叫做 <code>prop</code> 的属性，接着实现了如下简化了过程的判断场景：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let condition &#x3D; action()</span><br><span class="line">...</span><br><span class="line">if (condition)  obj5.prop &#x3D; true</span><br><span class="line">...</span><br><span class="line">if (obj5.prop) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>没有任何问题的代码对不对？当然，在条件为true时一切都很完美，但是如果 <code>condition</code> 为 <code>false</code> 呢，最后那条判断语句就要查找5次最后才能回到判断，如果链条更长呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 解决方案1：不需要中间变量时</span><br><span class="line">obj5.prop &#x3D; action()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 解决方案2：需要中间变量时（可能二次改变）</span><br><span class="line">obj5.prop &#x3D; condition</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 当然还有更多变种...</span><br></pre></td></tr></table></figure><p>或许有人觉得不太可能出现这样的错误，但当代码复杂到一定程度、中间过程非常繁琐，工期非常紧迫时，一切都是有可能的，大问题都是因为那些小步骤中一个又一个的将就累积出来的。更何况作为一个有追求的开发者，即便浏览器为我们的代码实现了最大程度的性能优化，不应该多一些对自我的要求么。</p><h3 id="原型的作用：Why-Prototype"><a href="#原型的作用：Why-Prototype" class="headerlink" title="原型的作用：Why Prototype"></a>原型的作用：Why Prototype</h3><p>既然类设计模式已经如此流行并深入一代又一代开发者的脑海，那么为什么还会有原型设计模式的立足之地呢？毫无疑问是因为 <code>JavaScript</code> 的存在。作为网页开发脚本的 <code>JavaScript</code> 一直唯我独尊地统御着这片疆域，至少目前开来还没有哪一种新的脚本语言能够取代它的位置。但试想一下假如有一天一种以类模式设计而成的语言可以彻底取代它，原型机制将要消亡的那天大概就要来临了，没有哪一种语言能够像 <code>JavaScript</code> 这样能够彻底地实践原型机制了。</p><p>除了上面这个从语言层面来说的使用原型模式的前提，在 <code>JavaScript</code> 编程中使用原型模式而不是类模式实现业务功能也有一个让人较为信服的原因。众所周知使用类和原型的目的都是为了实现继承，或者从更本质上来说是功能复用。</p><p>而在 <code>JavaScript</code> 中选择原型模式的理由就在<a href="https://github.com/getify/You-Dont-Know-JS/blob/master/this%20&%20object%20prototypes/ch6.md" target="_blank" rel="noopener">《You Don’t Know JS》这本书的章节中</a>。作者叙述地那么明了，也不需要做额外的解析了。在此我只引用两张图作为最直观的证据：</p><h4 id="使用类模式实现继承的逻辑图"><a href="#使用类模式实现继承的逻辑图" class="headerlink" title="使用类模式实现继承的逻辑图"></a>使用类模式实现继承的逻辑图</h4><p><img src="https://upload-images.jianshu.io/upload_images/3497104-d6b7607b7dab723b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="类继承逻辑图"></p><h4 id="使用原型模式实现继承的逻辑图"><a href="#使用原型模式实现继承的逻辑图" class="headerlink" title="使用原型模式实现继承的逻辑图"></a>使用原型模式实现继承的逻辑图</h4><p><img src="https://upload-images.jianshu.io/upload_images/3497104-1a09ab14f7d9fb91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="原型继承逻辑图"></p><p>很多最为有效的问题处理方式通常都是最简洁的方式，那些需要通过制造一个问题而去解决另一个问题的方法只会让人头脑晕眩，通常如果我们不能三言两语就点出问题的核心，只能反思自己可能对问题理解得不够透彻。如果能用一个非常简单有效的方法实现同样的结果，我实在是找不出什么原因非要去采用一个更加复杂的方法。</p><p>如上铺垫了一大堆概念，到底能从中得出什么结论？——你为什么想在 <code>JavaScript</code> 的业务开发中使用类模式而不是原型模式？</p><p>原型模式作为 <code>JavaScript</code> 原生的设计模式却没有得到开发者足够的理解，这与官方挖空心思强行模拟类模式的引导不无关系。</p><p>一位国外开发者 <a href="http://ericelliottjs.com/" target="_blank" rel="noopener"><code>Eric Elliott</code></a> 作了一个尖锐的比喻：</p><blockquote><p>Using class inheritance in JavaScript is like driving your new Tesla Model S to the dealer and trading it in for a rusted out 1973 Ford Pinto.</p></blockquote><p>翻译：在 <code>JavaScript</code> 中使用类继承就像把你崭新的特斯拉Model S开到交易商那换了一辆生锈的1973年的福特平托。</p><p>这种比喻何以见得恐怕通过上面那两张图的比较已经有了一个大致的理解，即便是不打算放弃类模式的开发方式，深入理解这种争议的缘由更助于提高我们的开发能力。我们需要时不时停下来多问问几个为什么。</p><h2 id="模式之争：The-War-of-Pattern"><a href="#模式之争：The-War-of-Pattern" class="headerlink" title="模式之争：The War of Pattern"></a>模式之争：The War of Pattern</h2><p>一直以来在 <code>JavaScript</code> 中使用类继承还是原型继承似乎不是什么值得争论的事情。但目前越来越多的国外开发者开始意识到原型模式在 <code>JavaScript</code> 中的自然性与逻辑简洁性。类模式与原型模式开始升级为不同阵营实现功能复用的争论点。</p><h3 id="原型与类：Prototype-vs-Class"><a href="#原型与类：Prototype-vs-Class" class="headerlink" title="原型与类：Prototype vs. Class"></a>原型与类：Prototype vs. Class</h3><p>如果我说在 <code>JavaScript</code> 中使用类模式实现继承是不符合目前人类大脑思维模式的复杂度的，我相信深入理解其中缘由的大多数人是会认可的，证据还是上面那张图，有多少人能够清晰地把上面的逻辑复演出来呢？恐怕大多数人都会在来来往往的直线曲线中迷失了方向，毕竟这样的方式要求你不仅要对类、子类和实例的关系把握精准，还要时刻铭记着它们暗中的原型关联关系，对于初学者来说这种双重性关系一定是会在未来学习的道路上横梗多年的坎。所以才需要在此尤为强调类与原型的种种区别。</p><p>但如果只是将注意力集中在对象之间的原型关联关系上，事情就简单多了。要清楚的是只要 <code>JavaScript</code> 语言本身的实现不改变，对象的原型关联关系是我们无法摆脱的。</p><p>不过原型与类的争论已经属于“旧时代”的争论，在随后开发者们对原型模式更加深入的理解基础上，形成了更深刻的认识和结论，“现代争论”不再是原型与类的冲突，而是原型更新、更本质的行为<strong>委托</strong>。</p><h3 id="原型与委托：Prototype-vs-Delegation"><a href="#原型与委托：Prototype-vs-Delegation" class="headerlink" title="原型与委托：Prototype vs. Delegation"></a>原型与委托：Prototype vs. Delegation</h3><p>前面有提到过在原型里说“继承”是不准确的，原因是名副其实的类继承的行为本质上是复制，而 <code>JavaScript</code> 里无论是用何种方式实现“继承”，它的本质行为都不是复制。</p><p>这里要澄清一个可能的误会，<code>JavaScript</code> 当然是支持复制的，然而成熟的开发者都知道复制与引用原型上的方法可是完全不一样的内存消耗，也正是由于 <code>JavaScript</code> 的原型机制才得以通过不增加副本的方式实现“继承”，所以就此排除了这种使用复制实现“继承”的方式。</p><p>那么在 <code>JavaScript</code> 里“继承”的本质又是什么呢？许多开发者共同倡导了一种新的概念——<strong>委托</strong>。这种机制可以这样简单地理解：<strong>所谓的“继承”其实是对象委托其原型们代劳办事，继承者借助原型上的方法实现功能</strong>。这个新的说法确实是比较生动地描述了原型继承机制的本质的。</p><p>以后或许开发者们会达成共识，把使用原型模式实现继承的方式称为原型委托，如此更符合它的实际情况。但究竟想使用哪种模式进行开发最终还是在于个人的选择，官方对类模式的不懈支持当然无法让众多开发者立即摒弃类语法糖，要从类转换到纯粹的原型上，是需要耗费思路转换和习惯改变的成本的，希望对这个核心知识点的剖析能够使学习者们更好地理解 <code>JavaScript</code> 的本质语言特性，启发来者们更多的深入思考。</p><h2 id="参考文献：Reference"><a href="#参考文献：Reference" class="headerlink" title="参考文献：Reference"></a>参考文献：Reference</h2><ul><li>You Don’t Know JS: this &amp; object prototypes<ul><li><a href="https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch4.md" target="_blank" rel="noopener">Chapter 4: Mixing (Up) “Class” Objects</a></li><li><a href="https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch5.md" target="_blank" rel="noopener">Chapter 5: Prototypes</a></li><li><a href="https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch6.md" target="_blank" rel="noopener">Chapter 6: Behavior Delegation</a></li></ul></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="noopener">MDN web docs: 继承与原型链</a></li><li><a href="https://javascript.info/prototype-inheritance" target="_blank" rel="noopener">The JavaScript language：Prototypal inheritance</a></li><li><a href="https://tylermcginnis.com/javascript-inheritance-and-the-prototype-chain/" target="_blank" rel="noopener">JavaScript Inheritance and the Prototype Chain</a></li><li><a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-s-the-difference-between-class-prototypal-inheritance-e4cd0a7562e9" target="_blank" rel="noopener">Master the JavaScript Interview: What’s the Difference Between Class &amp; Prototypal Inheritance?</a></li><li><a href="https://medium.com/javascript-scene/common-misconceptions-about-inheritance-in-javascript-d5d9bab29b0a" target="_blank" rel="noopener">Common Misconceptions About Inheritance in JavaScript</a></li><li><a href="https://baike.baidu.com/item/OOP/1152915" target="_blank" rel="noopener">面向对象编程（Object Oriented Programming，OOP，面向对象程序设计）</a></li><li><a href="https://hackernoon.com/understanding-javascript-prototype-and-inheritance-d55a9a23bde2" target="_blank" rel="noopener">Understanding JavaScript: Prototype and Inheritance</a></li><li><a href="https://flaviocopes.com/javascript-prototypal-inheritance/" target="_blank" rel="noopener">JavaScript Prototypal Inheritance</a></li><li><a href="https://alligator.io/js/prototypal-pattern/" target="_blank" rel="noopener">The JavaScript Prototypal Inheritance Pattern</a></li><li><a href="https://medium.com/@kevincennis/prototypal-inheritance-781bccc97edb" target="_blank" rel="noopener">Prototypal Inheritance in JavaScript</a></li><li><a href="https://www.cnblogs.com/richieyang/p/4884103.html" target="_blank" rel="noopener">面向过程，面向对象，函数式对同一个问题的思考方式</a></li></ul>]]></content>
    
    <summary type="html">
    
      `JavaScript` 中的原型机制一直以来都被众多开发者（包括本人）低估甚至忽视了，这是因为绝大多数人没有想要深刻理解这个机制的内涵，以及越来越多的开发者缺乏计算机编程相关的基础知识。对于这样的开发者来说 `JavaScript` 的原型机制是一个尚待发掘的大宝藏，深入了解下去会让大家在编程这条路上走得更长远，当然你不能妄想任何一种机制、模式或范式是完美无缺的。
    
    </summary>
    
    
      <category term="Dev" scheme="https://ushio-s.github.io/categories/Dev/"/>
    
      <category term="Understanding JavaScript" scheme="https://ushio-s.github.io/categories/Dev/Understanding-JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://ushio-s.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>[译文]JavaScript工作原理</title>
    <link href="https://ushio-s.github.io/2019-06-25/translation-how-javascript-works-part-2/"/>
    <id>https://ushio-s.github.io/2019-06-25/translation-how-javascript-works-part-2/</id>
    <published>2019-06-25T10:20:07.000Z</published>
    <updated>2020-06-09T08:50:02.837Z</updated>
    
    <content type="html"><![CDATA[<p>几周前我们开始了一个系列博文旨在深入挖掘 <code>JavaScript</code> 并弄清楚它的工作原理：我们认为通过了解 <code>JavaScript</code> 的构建单元并熟悉它们是怎样结合起来的，有助于写出更好的代码和应用。</p><p><a href="https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf" target="_blank" rel="noopener">这个系列的第一篇文章</a>聚焦于提供一个关于引擎、运行时和调用栈的概述。本文将会深入分析 <code>Google</code> 的 <code>V8</code> 引擎的内部实现。我们也会提供一些编写更优质 <code>JavaScript</code> 代码的小技巧——我们的团队在构建 <code>SessionStack</code> 应用时遵循的最佳实践。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>JavaScript</code> 引擎是执行 <code>JavaScript</code> 代码的程序或解释器。 <code>JavaScript</code> 引擎可以实现为标准的解释器，或即时编译器，以某种形式将 <code>JavaScript</code> 编译成字节码。</p><p>以下是一些流行的 <code>JavaScript</code> 引擎项目：</p><ul><li><strong>V8</strong> —— 开源，<code>Google</code> 开发，<code>C++</code> 编写</li><li><strong>Rhino</strong>  —— <code>Mozilla</code> 基金会管理，开源，完全使用 <code>Java</code> 开发</li><li><strong>SpiderMonkey</strong> —— 第一个 <code>JavaScript</code> 引擎，以前由 <code>Netscape Navigator</code> 维护，现在由 <code>Firefox</code> 维护</li><li><strong>JavaScriptCore</strong> —— 开源，以 <code>Nitro</code> 的名义销售，由 <code>Apple</code> 公司为 <code>Safari</code> 浏览器开发</li><li><strong>KJS</strong>  —— <code>KDE</code> 的引擎，最初由 <code>Harri Porten</code> 为 <code>KDE</code> 项目的 <code>Konqueror</code> 浏览器开发</li><li><strong>Chakra</strong> (JScript9)  —— <code>IE</code> 浏览器</li><li><strong>Chakra</strong> (JavaScript)  —— <code>Edge</code> 浏览器</li><li><strong>Nashorn</strong> —— <code>OpenJDK</code> 开源项目的一部分，由 <code>Oracle Java</code> 和其工具集开发</li><li><strong>JerryScript</strong>  —— 一个轻量级的物联网引擎</li></ul><h2 id="为什么要创建V8引擎？"><a href="#为什么要创建V8引擎？" class="headerlink" title="为什么要创建V8引擎？"></a>为什么要创建V8引擎？</h2><p>谷歌公司研发的 <code>V8</code> 引擎是由 <code>C++</code> 编写的开源引擎。该引擎使用在谷歌浏览器内部。但与其他引擎不同的是，<code>V8</code> 也应用于 <code>Node.js</code> 这一流行的运行时当中。</p><p><img src="https://upload-images.jianshu.io/upload_images/3497104-27fc410304b08292.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2-1 V8"></p><p><code>V8</code> 最初是为了提高浏览器中 <code>JavaScript</code> 执行的性能而设计的。为了获得速度，<code>V8</code> 将 <code>JavaScript</code> 代码转换成更高效的机器编码而不是使用解释器。同其他现代 <code>JavaScript</code> 引擎如 <code>SpiderMonkey</code> 或 <code>Rhino</code> （<code>Mozilla</code>）所做的一样，<code>V8</code> 通过实现<strong>即时编译器</strong>在执行时将 <code>JavaScript</code> 代码编译成机器代码。其中最主要的区别是 <code>V8</code> 不生成字节码或任何中间代码。</p><h2 id="V8曾有两个编译器"><a href="#V8曾有两个编译器" class="headerlink" title="V8曾有两个编译器"></a>V8曾有两个编译器</h2><p>在 <code>V8</code> 5.9版本发布之前（2017年初发布），该引擎使用两个编译器：</p><ul><li>full-codegen —— 简单、非常快的编译器，生成简单和相对较慢的机器代码</li><li>Crankshaft  —— 更加复杂的（即时）优化编译器，生成高度优化的代码</li></ul><p>同时 <code>V8</code> 内部使用了多条线程：</p><ul><li>主线程的工作正如你所预期：获取代码、编译然后执行代码</li><li>另有一条独立线程负责编译，这样主线程可以在前者优化代码时继续执行</li><li>一条分析器线程会告诉运行时，哪些方法会耗费大量时间以便 <code>Crankshaft</code> 编译器优化代码</li><li>还有几条线程处理垃圾回收清理</li></ul><p>首次执行 <code>JavaScript</code> 代码时，<code>V8</code> 利用 <code>full-codegen</code> 无过渡地直接将解析后的 <code>JavaScript</code> 转换成机器代码。这使得它可以非常快速地开始执行机器代码。注意 <code>V8</code> 不使用中间代码表示，因此摆脱了对解释器的需要。</p><p>在你的代码运行了一定时间后，分析线程就能收集到足够的数据判断哪些方法需要优化。</p><p>接着，<strong><code>Crankshaft</code></strong> 优化在另一线程开始。它将 <code>JavaScript</code> 抽象语法树转换成高级静态单赋值（<code>SSA</code>）表示，称为 <code>Hydrogen</code>（注：氮），并尝试优化氮图。大多数优化都在这个级别完成。</p><h2 id="内联"><a href="#内联" class="headerlink" title="内联"></a>内联</h2><p>优化的第一步是先内联尽可能多的代码。内联是一个将调用引用（函数调用的那行代码）替换成所调用的函数体的过程。这个简单的步骤使接下来的优化过程更有意义：</p><p><img src="https://upload-images.jianshu.io/upload_images/3497104-dcda0d8ff13c2e46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2-2 Inlining"></p><h2 id="隐藏类"><a href="#隐藏类" class="headerlink" title="隐藏类"></a>隐藏类</h2><p><code>JavaScript</code> 是基于原型的语言：没有<strong>类</strong>，使用克隆的方式创建对象。<code>JavaScript</code> 还是一个动态编程语言，这意味着当对象被初始化之后还可以轻易地增删其属性。</p><p>大多数 <code>JavaScript</code> 解释器采用类字典数据结构（基于哈希函数）来存储对象属性值在内存中的位置。这种结构使得在 <code>JavaScript</code> 中取回属性值的计算开销比非动态语言如 <code>Java</code> 或 <code>C#</code>更昂贵。在 <code>Java</code> 中，所有的对象属性在编译前就由固定对象布局决定了，不允许在运行时动态增加或删除（<code>C#</code>有动态类型，但那是另一个话题）。因此，属性值（或指向属性的指针）就可以以连续缓冲区存储在内存中，之间用固定的偏移量隔开。偏移量的长度简单地根据属性的类型确定，然而这在 <code>JavaScript</code> 中是不可能的，因为属性类型可以在运行时更改。</p><p>由于通过字典查找对象属性在内存中的位置非常低效，<code>V8</code> 采用了另一方法作为替代：<strong>隐藏类</strong>。隐藏类的原理类似于 <code>Java</code> 等语言中使用的固定对象布局（类），除了是在运行时创建。现在，让我们来看看它们实际是什么样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Point(x, y) &#123;</span><br><span class="line">    this.x &#x3D; x;</span><br><span class="line">    this.y &#x3D; y;</span><br><span class="line">&#125;</span><br><span class="line">var p1 &#x3D; new Point(1, 2);</span><br></pre></td></tr></table></figure><p>当 <code>new Point(1, 2)</code> 调用发生，<code>V8</code> 将创建了一个名为 <code>C0</code> 的隐藏类。</p><p><img src="https://upload-images.jianshu.io/upload_images/3497104-036841fd4b544963.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2-3 C0"></p><p>现在 <code>Point</code> 还没有定义任何属性，所以 <code>C0</code> 是空的。</p><p>一旦第一条声明 <code>this.x = x</code> 开始执行（在 <code>Point</code> 函数内），<code>V8</code> 将创建第二个基于 <code>C0</code> 的隐藏类 <code>C1</code>。<code>C1</code> 描述了在内存中（相对于 <code>point</code> 对象）能找到属性 <code>x</code> 的位置。在这个例子中，<code>x</code> 保存在偏移量为 <code>0</code> 的位置，这意味着在将内存中的对象视作一个连续缓冲区时，第一个偏移量对应着 <code>x</code>。<code>V8</code> 还会通过一个“类转换”更新 <code>C0</code>，以表明如果一个属性 <code>x</code> 被添加到 <code>point</code> 对象中，隐藏类 <code>C0</code> 就会转换成 <code>C1</code>。下面 <code>point</code> 对象的隐藏类现在变成了 <code>C1</code>。</p><p><img src="https://upload-images.jianshu.io/upload_images/3497104-c5233759a5afd00b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2-4 C1"></p><blockquote><p>每次添加一个新属性到对象，旧隐藏类都会通过一个转换路径更新成一个新隐藏类。隐藏类转换之所以如此重要是因为它能使隐藏类在以同样方式创建的对象间共享。如果两个对象共享同一个隐藏类并向它们添加相同的属性，转换可以确保它们获得相同的隐藏类和所有与其相关的优化代码。</p></blockquote><p>当 <code>this.y = y</code> 语句执行时将会重复同样的过程（同样在 <code>Point</code> 函数内，<code>this.x = x</code> 之后）。</p><p>新的隐藏类 <code>C2</code> 将被创建，<code>C1</code> 发生类转换表示如果向一个 <code>Point</code> 对象添加属性 <code>y</code> （已经包含一个属性 <code>x</code>），隐藏类应该更新为 <code>C2</code>，并且 <code>point</code> 对象的隐藏类更新为 <code>C2</code>。</p><p><img src="https://upload-images.jianshu.io/upload_images/3497104-c8ac7fcdc03adb7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2-5 C2"></p><p>隐藏类转换依赖向对象所添加属性的顺序。请看下面的代码片段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Point(x, y) &#123;</span><br><span class="line">    this.x &#x3D; x;</span><br><span class="line">    this.y &#x3D; y;</span><br><span class="line">&#125;</span><br><span class="line">var p1 &#x3D; new Point(1, 2);</span><br><span class="line">p1.a &#x3D; 5;</span><br><span class="line">p1.b &#x3D; 6;</span><br><span class="line">var p2 &#x3D; new Point(3, 4);</span><br><span class="line">p2.b &#x3D; 7;</span><br><span class="line">p2.a &#x3D; 8;</span><br></pre></td></tr></table></figure><p>现在你可能会假设 <code>p1</code> 和 <code>p2</code> 使用相同的隐藏类和转换。实际则并非如此。对于 <code>p1</code>，先添加属性 <code>a</code> 然后添加属性 <code>b</code>。而对于 <code>p2</code>，先添加的属性是 <code>b</code> 然后才是 <code>a</code>。因此，由于转换路径不同， <code>p1</code> 和 <code>p2</code> 最终将会产生不同的隐藏类。在这种情况下，最好在初始化动态属性时保持顺序一致以便复用相同的隐藏类。</p><h2 id="内联缓存"><a href="#内联缓存" class="headerlink" title="内联缓存"></a>内联缓存</h2><p><code>V8</code> 利用了另一项叫做内联缓存的技术来优化动态类型语言。内联缓存依赖于这样一种观察：同一方法的重复调用通常发生在同一类型的对象上。关于内联缓存的深入阐述在<a href="https://github.com/sq/JSIL/wiki/Optimizing-dynamic-JavaScript-with-inline-caches" target="_blank" rel="noopener">这里</a>。</p><p>我们准备介绍内联缓存的一般概念（以免你没有时间查看上述的深入阐述）。</p><p>那么它的原理是什么？<code>V8</code> 维护着在最近的方法调用中作为参数传入的对象类型的缓存，并利用这个信息假设未来会被当做参数的对象的类型。如果 <code>V8</code> 能很好地假设出将要传入方法的对象的类型，就能直接越过如何获取对象属性的计算过程，取而代之的是使用之前查找对象的隐藏类时存储的信息。</p><p>那么隐藏类是如何与内联缓存关联起来的？每当某一对象调用方法时，<code>V8</code> 必须执行对此对象的隐藏类的查询来确定访问某个属性的偏移量。当对同一隐藏类成功调用过两次同样的方法后，<code>V8</code> 将省略对隐藏类的查询而只将属性偏移量添加到对象指针本身。对于那个方法未来所有的调用，<code>V8</code> 都假定隐藏类不改变，并利用之前查询存储的偏移量直接跳到某一属性的内存地址。这极大地提高了执行速度。</p><p>内联缓存也是同类对象共享同一隐藏类如此重要的原因。如果你创建了拥有不同隐藏类的两个同类对象（正如前面的例子），<code>V8</code> 就无法使用内联缓存，因为即便这两个对象是相同的类型，但他们对应的隐藏类为属性指定了不同的偏移量。</p><p><img src="https://upload-images.jianshu.io/upload_images/3497104-2e38da3461e67798.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2-6 Inline caching"></p><blockquote><p>这两个对象基本相同，但 <code>a</code>、<code>b</code> 属性的创建顺序不同。</p></blockquote><h2 id="编译到机器代码"><a href="#编译到机器代码" class="headerlink" title="编译到机器代码"></a>编译到机器代码</h2><p>一旦氮图优化好后，<code>Crankshaft</code> 会将它降为更低水平的表示，称为 <code>Lithium</code>（注：锂）。大多数 <code>Lithium</code> 的实现依赖于特定架构。寄存器分配发生在这个级别。</p><p>最终，<code>Lithium</code> 被编译成机器代码。随后发生 <code>OSR</code>：堆栈上替换。在开始编译和优化明显长时间运行的方法前，我们可能会运行它。<code>V8</code> 不会在再次开始执行优化版本时忘记那些缓慢的执行。而是转换我们所有的上下文（栈，寄存器）以便能在执行中切换到优化版本。这是个非常复杂的任务，记住在其他的优化中，<code>V8</code> 最先做了代码内联。<code>V8</code> 不是唯一有这种能力的引擎。</p><p>还有种被称为反优化的安全措施能做反向转换，回退到未优化代码，以防引擎做出的假设不再成立。</p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>在垃圾回收方面，<code>V8</code> 采用传统分代方法标记和清扫来清理老的代。标记阶段会暂停 <code>JavaScript</code> 的执行。为了控制垃圾回收的开销并使执行更加稳定，<code>V8</code> 采用增量标记：它不遍历全部栈堆，而是尝试标记每一个可能的对象，它只遍历栈堆的一部分，然后恢复正常执行。下一次垃圾回收暂停会在之前栈堆的停止位置继续。这可使正常执行期间只发生相当短的暂停。正如之前提到的，清理阶段由单独的线程处理。</p><h2 id="Ignition-和-TurboFan"><a href="#Ignition-和-TurboFan" class="headerlink" title="Ignition 和 TurboFan"></a>Ignition 和 TurboFan</h2><p>随着2017年初 <code>V8</code> 5.9版本的发布，一个新的执行管道被引入。新的管道在实际的<code>JavaScript</code> 应用中实现了更大的性能提升和的显著的内存节省。</p><p>新的执行管道构建在 <code>V8</code> 的解释器 <code>Ignition</code> 和 <code>V8</code> 最新的优化编译器 <code>TurboFan</code> 之上。</p><p>你可以在<a href="https://v8project.blogspot.bg/2017/05/launching-ignition-and-turbofan.html" target="_blank" rel="noopener">这里</a>查阅 <code>V8</code> 团队关于这个主题的博文。</p><p>自从 <code>V8</code> 5.9版本发布以来， <code>V8</code> 就不再在 <code>JavaScript</code> 执行里使用 <code>full-codegen</code> 和 <code>Crankshaft</code>（自2010年来一直支撑着 <code>V8</code> 的技术），这是由于 <code>V8</code> 团队也在努力地跟上新的 <code>JavaScript</code> 语言特性的脚步和这些特性所需的优化。</p><p>这意味着将来在整体上 <code>V8</code> 将拥有更加简单和更易于维护的架构。</p><p><img src="https://upload-images.jianshu.io/upload_images/3497104-bc719c62fda9f41c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2-7 Improvements on Web and Node.js benchmarks"></p><p>这些提升仅仅是个开始。新的 <code>Ignition</code> 和 <code>TurboFan</code> 管道铺垫了更远的优化之路，将会推进 <code>JavaScript</code> 的性能并在接下来的几年里缩小 <code>V8</code> 在 <code>Chrome</code> 和 <code>Node.js</code> 中的足迹。</p><p>最后，这里有几条关于如何编写更优化的、更好的 <code>JavaScript</code> 代码的建议和技巧。虽然你可以很容易地从上述的内容中得到这些，为了方便还是把它们做了以下的总结：</p><h2 id="怎么编写优化的JavaScript"><a href="#怎么编写优化的JavaScript" class="headerlink" title="怎么编写优化的JavaScript"></a>怎么编写优化的JavaScript</h2><ol><li><strong>对象属性的顺序</strong>：始终使用相同的顺序初始化对象属性，以便共享隐藏类和随后的优化代码。</li><li><strong>动态属性</strong>：在初始化完成之后添加对象动态属性会强制改变隐藏类并使之前的隐藏类已优化的方法变慢。相反，在对象的构造器里指定所有的属性。</li><li><strong>方法</strong>：重复执行相同方法的代码会比仅执行一次许多不同的方法运行的更快（由于内联缓存）。</li><li><strong>数组</strong>：避免使用键值不递增的稀疏数组。并非每个元素都存在的稀疏数组是一个哈希表。访问稀疏数组的元素将会花费更昂贵的开销。此外，避免预先分配大数组。最好是按需要增加长度。最后，不要删除数组中的元素。这会使数组变得稀疏。</li><li><strong>带标记的值</strong>：<code>V8</code> 用32位字节表示对象和数字。其中使用了一个位来标识是对象（标识为1）或是整数（标识为0），由于它们是31位的而被称为 <code>SMI</code>（<code>SMall Integer</code>）。如果一个数值大小超过了31位可以表示的数字，<code>V8</code> 将会包装它，将其转换为一个双字节类型值并创建一个新的对象存入其中。尽量使用31带符号的数值避免 <code>JS</code> 对象的昂贵包装操作。</li></ol>]]></content>
    
    <summary type="html">
    
      本文聚焦于提供一个关于引擎、运行时和调用栈的概述。本文将会深入分析 `Google` 的 `V8` 引擎的内部实现。我们也会提供一些编写更优质 `JavaScript` 代码的小技巧
    
    </summary>
    
    
      <category term="Dev" scheme="https://ushio-s.github.io/categories/Dev/"/>
    
    
      <category term="Translation" scheme="https://ushio-s.github.io/tags/Translation/"/>
    
      <category term="JavaScript" scheme="https://ushio-s.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>[译文]JavaScript工作原理</title>
    <link href="https://ushio-s.github.io/2019-04-22/translation-how-javascript-works-part-1/"/>
    <id>https://ushio-s.github.io/2019-04-22/translation-how-javascript-works-part-1/</id>
    <published>2019-04-22T02:46:28.000Z</published>
    <updated>2020-06-09T08:50:08.527Z</updated>
    
    <content type="html"><![CDATA[<p>随着 <code>JavaScript</code> 越来越流行，开发团队也更多地利用其来支持技术栈的各方面，前端、后端、混合应用、嵌入式设备等。</p><p>本文是旨在深入挖掘 <code>JavaScript</code> 其工作原理系列教程的首篇：我们认为通过了解 <code>JavaScript</code> 的构建单元并熟悉它们是怎样结合起来的，有助于你写出更好的代码和应用。我们也会分享一些在构建 <code>SessionStack</code> 应用时用到的经验法则，为了维持其竞争力它是一个健壮、高性能的轻量级 <code>JavaScript</code> 应用。</p><p>如<a href="http://githut.info/" target="_blank" rel="noopener">GitHut stats</a>所示，<code>JavaScript</code> 在活跃仓库数和<code>GitHub</code>总推送数方面位于首位。在其他类别排名中落后的也不多。</p><p><img src="https://upload-images.jianshu.io/upload_images/3497104-5f1a6a16081274af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="GitHut stats"></p><p><a href="https://madnight.github.io/githut/" target="_blank" rel="noopener">（查看最新的统计）</a>。</p><p>如果项目变得如此依赖 <code>JavaScript</code> ，这就意味着开发者必须更加深入地理解其内部原理以充分利用语言和其生态提供的所有内容，从而构建更棒的软件。</p><p>事实显示，许多开发者每天都在使用 <code>JavaScript</code> 却不知其底层发生了什么。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>几乎每个人都听说过 <code>V8</code> 引擎的概念，大多数人也知道 <code>JavaScript</code> 是单线程的或者使用回调队列。</p><p>在本文中，我们会详细讲解这些概念并阐述 <code>JavaScript</code> 是如何运行的。通过了解这些细节，你就可以利用提供的 <code>APIs</code> 写出更好的、无阻塞的应用。</p><p>如果你对 <code>JavaScript</code> 相对陌生，这个博客可以帮助你理解为何与其他语言相比 <code>JavaScript</code> 如此怪异。</p><p>如果你是位经验丰富的 <code>JavaScript</code> 开发人员，也希望能提供给你一些每天都在使用的 <code>JavaScript</code> 运行时实际运作机制的新见解。</p><h2 id="JavaScript引擎"><a href="#JavaScript引擎" class="headerlink" title="JavaScript引擎"></a><code>JavaScript</code>引擎</h2><p>JS引擎的一个最流行的例子就是谷歌的 <code>V8</code>。 <code>V8</code> 引擎使用在例如 <code>Chrome</code> 浏览器和 <code>Node.js</code> 中。下图是一个引擎组成部分的极简视图：</p><p><img src="https://upload-images.jianshu.io/upload_images/3497104-9b5f7cb4b297c7d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="JS Engine"></p><p>引擎由以下两个主要部分组成：</p><ul><li>内存堆——这是内存分配发生的地方</li><li>调用栈——这是代码执行时的堆栈帧所在位置</li></ul><h2 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h2><p>几乎所有 <code>JavaScript</code> 开发者都使用过浏览器提供的 <code>APIs</code>（如 <code>setTimeout</code>）。但是那些 <code>APIs</code> 并不由引擎提供。</p><p>那么，它们来自哪里？</p><p>其实实际情况更加复杂一些。</p><p><img src="https://upload-images.jianshu.io/upload_images/3497104-36080fb1a26b82f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="JS Runtime"></p><p>所以，除了引擎之外实际上还有更多东西。我们还有那些由浏览器提供 <code>Web APIs</code>，如 <code>DOM</code>、<code>AJAX</code>、<code>setTimeout</code> 等等。</p><p>并且，我们还有非常流行的<strong>事件循环</strong>和<strong>回调队列</strong>。</p><h2 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h2><p><code>JavaScript</code> 是单线程编程语言，意味着它只有单一的调用栈。因此它一次只能做一件事。</p><p><strong>调用栈是一种数据结构，基本记录了程序运行的位置</strong>。如果进入一个函数，就会把它推入到栈顶部。如果函数返回，就会将函数从栈顶部移除。这就是栈能做的事情。</p><p>举个例子，先来看如下所示的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printSquare</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> s = multiply(x, x);</span><br><span class="line">    <span class="built_in">console</span>.log(s);</span><br><span class="line">&#125;</span><br><span class="line">printSquare(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>当引擎开始执行这段代码时，调用栈将是空的。之后的步骤如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/3497104-0ce0f5ff212930e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Call Stack"></p><p>调用栈的每一次进入称为栈帧。</p><p>这正是抛出异常时栈追踪的构造过程——这基本上就是异常抛出时调用栈的状态。看看下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'SessionStack will help you resolve crashes :)'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    bar();</span><br><span class="line">&#125;</span><br><span class="line">start();</span><br></pre></td></tr></table></figure><p>在 <code>Chrome</code> 中执行这段代码时（假设这些代码在foo.js文件中），会产生如下的栈追踪记录：</p><p><img src="https://upload-images.jianshu.io/upload_images/3497104-599471a5dbdcd0b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Stack Frame"></p><p>“<strong>栈溢出</strong>”——发生在达到最大调用栈的大小时。这非常容易发生，尤其是当你使用了递归而未进行足够的测试时，看看如下示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>当引擎开始执行这段代码时，从调用 <code>foo</code> 函数开始。然而这个函数是递归的，它开始调用自己而没有任何终止条件。所以在执行的每一步中，相同的函数一次又一次添加到调用栈里。它看起来是这样的：</p><p><img src="https://upload-images.jianshu.io/upload_images/3497104-bd7e18cfb7252d65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Blowing the stack"></p><p>但是，在某个时候，调用栈中函数的数量超过了它的实际大小，这时浏览器决定采取一些行动，抛出异常，它是这样的：</p><p><img src="https://upload-images.jianshu.io/upload_images/3497104-ba8de1bfa2b516d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Stack Overflow"></p><p>在单线程上运行代码十分简单，因为不需要处理在多线程环境中遇到的复杂场景——例如，死锁。</p><p>但单线程上的代码运行也相当受限。由于 <code>JavaScript</code> 只有单一的调用栈，当运行非常慢时会发生什么呢？</p><h2 id="并发和事件循环"><a href="#并发和事件循环" class="headerlink" title="并发和事件循环"></a>并发和事件循环</h2><p>当调用栈中存在大量耗时才能处理的函数时会发生什么？例如，假设你需要在浏览器中使用 <code>JavaScript</code> 执行某些非常复杂的图像转换。</p><p>你也许会问——这有什么问题？问题在于当调用栈中有函数等待执行时，浏览器实际上无法做其他事情——它被阻塞了。这意味着浏览器无法继续渲染，也不能运行其他代码，它只是卡住了。如果你希望拥有流畅的用户体验，这就成了问题。</p><p>这并不是唯一的问题。一旦你的浏览器开始执行栈里如此之多的任务，它可能会在相当长的时间里暂停响应。大多数浏览器会采取报错的行为，询问你是否要关闭页面。</p><p><img src="https://upload-images.jianshu.io/upload_images/3497104-74e240ae3cd7fe07.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Page Unresponsive"></p><p>这可不是最好的用户体验，不是吗？</p><p>那么，我们要怎样在既不阻塞 <code>UI</code> 又不导致浏览器无响应的情况下执行大量的代码呢？解决方案是：<strong>异步回调</strong>。</p><p>这将在《JavaScript工作原理》教程的第二部分详细解释。</p>]]></content>
    
    <summary type="html">
    
      随着 `JavaScript` 越来越流行，开发团队也更多地利用其来支持技术栈的各方面，前端、后端、混合应用、嵌入式设备等。本文是旨在深入挖掘 `JavaScript` 其工作原理系列教程的首篇：我们认为通过了解 `JavaScript` 的构建单元并熟悉它们是怎样结合起来的，有助于你写出更好的代码和应用。
    
    </summary>
    
    
      <category term="Dev" scheme="https://ushio-s.github.io/categories/Dev/"/>
    
    
      <category term="Translation" scheme="https://ushio-s.github.io/tags/Translation/"/>
    
      <category term="JavaScript" scheme="https://ushio-s.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>理解JavaScript的核心知识点：This</title>
    <link href="https://ushio-s.github.io/2019-04-17/understanding-javascript-core-this/"/>
    <id>https://ushio-s.github.io/2019-04-17/understanding-javascript-core-this/</id>
    <published>2019-04-17T05:40:10.000Z</published>
    <updated>2020-06-09T08:56:11.719Z</updated>
    
    <content type="html"><![CDATA[<p><code>this</code> 是 <code>JavaScript</code> 中非常重要且使用最广的一个关键字，它的值指向了一个对象的引用。这个引用的结果非常容易引起开发者的误判，所以必须对这个关键字刨根问底。</p><h2 id="执行上下文：Execution-Context"><a href="#执行上下文：Execution-Context" class="headerlink" title="执行上下文：Execution Context"></a>执行上下文：Execution Context</h2><p>在深入了解 <code>this</code> 对象之前先介绍另一个概念：执行上下文。</p><p>没错，执行上下文与 <code>this</code> 在本质上是两个概念，或者说它们指代的范畴有差异，想要准确认识 <code>this</code>，就得先把它们区分开。</p><p>可以把<strong>执行上下文</strong>想象为一个容器，其中包含了一句句待执行的代码。代码在这个容器中有上下行两条路线，是由某一些特殊代码所触发（如函数），上行路线跳入了一个新的容器，开始在新容器中执行另一些代码，本容器中的后续代码被暂时中断；如果新容器中还有代码会触发上行路线，就继续往上增加新容器，并交出控制权，层层叠加，形成了一个从底往上形式的叠罗汉，这就是 <code>JavaScript</code> 运行时的执行上下文栈。</p><p>执行上下文这一抽象概念本身包含了更多有关 <code>JavaScript</code> 这门语言的内部机制，对于语言使用者来说是不透明的，其中与运行前的编译规则有很大关联，并被包含到整个程序运行前的初始化过程中，与词法作用域的变量解析规则相配合，将这些静态解析后的变量带入运行时的环境，所以它是程序运行时的关键内部组件或者说容器，而 <code>JavaScript</code> 将对执行上下文的引用提供给程序开发者的唯一入口就是 <code>this</code>，它得以访问被编译后带入到某个执行上下文运行环境中的变量。<code>this</code> 指代的其实只是内部抽象的执行上下文向用户所开放的那一部分，其实体是一个对象，绑定了许多编译后的变量。</p><p>以下是一段关于执行上下文精辟的总结：</p><blockquote><p>An execution context is purely a specification mechanism and need not correspond to any particular artefact of an ECMAScript implementation. It is impossible for ECMAScript code to directly access or observe an execution context.</p></blockquote><p>翻译：执行上下文纯粹是一种规范机制，它不需要与基于 <code>ECMAScript</code> 规范的任何特定扩展实现对应。<code>ECMAScript</code> 代码无法直接访问或观察执行上下文。</p><h2 id="关于This对象：What’s-This"><a href="#关于This对象：What’s-This" class="headerlink" title="关于This对象：What’s This"></a>关于This对象：What’s This</h2><p>我将官方文档和一些别的文章里的说明稍加梳理，可以从以下段落中较为清晰地看出 <code>this</code> 的本质：</p><blockquote><p>First, know that all functions in JavaScript have properties, just as objects have properties. And when a function executes, it gets the <strong>this</strong> property—a variable with the value of the object that invokes the function where <strong>this</strong> is used.</p></blockquote><blockquote><p>The <strong>this</strong> keyword evaluates to the value of the ThisBinding of the current execution context.</p></blockquote><blockquote><p>The abstract operation GetThisEnvironment finds the Environment Record that currently supplies the binding of the keyword <strong>this</strong></p></blockquote><blockquote><p><strong>this</strong> is not assigned a value until an object invokes the function where <strong>this</strong> is defined.</p></blockquote><p>翻译：</p><ul><li>首先，要知道 <code>JavaScript</code> 中所有的函数与对象一样都拥有属性。当一个函数执行时，它得到 <code>this</code> 属性——一个指向调用函数的对象的变量。</li><li><code>this</code> 关键字计算为当前执行上下文的 <code>ThisBinding</code> 属性的值。</li><li><code>GetThisEnvironment</code> 抽象运算查找当前提供 <code>this</code> 关键字的绑定的环境记录。</li><li>在对象调用了定义了 <code>this</code> 的函数之前，<code>this</code> 不会被赋值。</li></ul><p>由此可得出关于 <code>this</code> 的完全定义：<strong><code>this</code> 是在程序运行时，通过语言内部抽象操作在执行上下文中动态计算得到的，指向调用使用了其的函数的对象的变量。</strong></p><h2 id="执行上下文-vs-This关键字：Execution-Context-vs-This-Keyword"><a href="#执行上下文-vs-This关键字：Execution-Context-vs-This-Keyword" class="headerlink" title="执行上下文 vs. This关键字：Execution Context vs. This Keyword"></a>执行上下文 vs. This关键字：Execution Context vs. This Keyword</h2><p>执行上下文和 <code>this</code> 关键字的关系与潜意识相对于意识的关系类似，执行上下文是冰山下深邃庞大而不可窥探的秘地，而 <code>this</code> 只将其一个小部分显露出来。由于 <code>JavaScript</code> 是面向对象的编程语言，所以执行上下文其实质相当于一个对象，<code>this</code> 指向了它向开发者开放了的一系列属性集合的对象，因而我把 <code>this</code> 叫做执行上下文的引用对象。</p><h2 id="This因何而来：Why-This"><a href="#This因何而来：Why-This" class="headerlink" title="This因何而来：Why This"></a>This因何而来：Why This</h2><p><code>JavaScript</code> 在编写初始借鉴了<code>JAVA</code> 和 <code>C</code> 语言的特性，即便本质上不同，但还是把这个如同惯例般存在的 <code>this</code> 拿了过来。使用 <code>this</code> 的原因其实很简单：</p><p>首先，我们时常无法得知调用了函数的对象的名称，并且有时候根本就没有名称可以用来引用调用对象。这是一个迫切的原因，因为我们在开发时必定会遇到需要引用调用函数的对象的场景。</p><p>其次，避免重复指代，就像我们经常使用第三人称来指代前文的主体一样，作为程序员大家当然很乐意使用一个快捷方式来避免机械重复一些不必要的代码，这也是“语言”这一重要产品的特性。</p><p>最后，它提供给我们实现高级功能的可能性，我们可以通过 <code>this</code> 动态对于执行上下文的指代而实现程序的复用性和扩展。</p><h2 id="This的判断规则：Rules-of-This"><a href="#This的判断规则：Rules-of-This" class="headerlink" title="This的判断规则：Rules of This"></a>This的判断规则：Rules of This</h2><p>对 <code>this</code> 的根源进行深入探究的目的就是为了在开发中对自己所使用的 <code>this</code> 关键字指代的对象进行准确的判定，它就是一个变量，所以当我们使用它的时候，必须清晰地知道它的值到底是什么。</p><p>一般来说，我们可以通过确定是哪个对象拥有所调用的函数来确定其 <code>this</code> 的指向。这是由于 <code>this</code> 的绑定值是在函数调用的时候才赋予的，要看函数在哪个上下文对象中调用，但有时候这不是仅用肉眼就能观察出来的。</p><p>此外还要<strong>严肃声明</strong>一下，虽然在之前下定义的时候将 <code>this</code> 的概念明确地划分到了运行阶段，但由于它作为一个变量的特性，是可以改变引用值的，它的值的计算与词法规则还是息息相关，得将编译和运行时两个阶段结合起来，总结出关于判断 <code>this</code> 绑定值的基本原则。</p><p><code>this</code> 关键字绑定的操作是在语言内核机制的运行时里执行的，由于无法去探索其内部，只能通过官方文档中给出的一系列描述程序来得知其如何判断，可以梳理出函数调用的内部过程中对 <code>this</code> 的绑定计算的依据：</p><h3 id="前置知识-1-内部机制创建执行上下文、初始化函数所属领域和创建相关环境记录"><a href="#前置知识-1-内部机制创建执行上下文、初始化函数所属领域和创建相关环境记录" class="headerlink" title="前置知识 1: 内部机制创建执行上下文、初始化函数所属领域和创建相关环境记录"></a>前置知识 1: 内部机制创建执行上下文、初始化函数所属领域和创建相关环境记录</h3><p>在函数被真正执行之前，内部机制会执行创建拥有函数的领域、创建执行上下文、移交当前执行上下文控制权、创建环境记录、环境记录对象参数的绑定等一系列操作，为程序运行做编译准备。在将函数推入执行栈顶层的时候，对其上下文的归属有以下的判断过程，此处与一个新的概念<strong>领域</strong>有关：</p><ul><li>如果领域中的属性 <code>this</code> 返回了一个对象，就将内部属性 <code>thisValue</code> 设置为以此对象为基础按照规格创建的 <code>js</code> 对象，否则 <code>thisValue</code> 绑定值为 <code>undefined</code>，表明领域的全局对象（本地全局对象）将设置为全局对象（程序全局对象）。</li></ul><p>这里在新规范里出现的一个概念<strong>领域</strong>取代了之前版本中简单的作用域的概念，由于实现了模块化等其他新特性，所以作用域的概念可以相当于扩展成了现在的领域，它下属了其他几个环境记录，其中变量的绑定分别在不同环境记录中，这里就不做深入解释了。</p><p><strong>领域</strong>中比较重要的属性是领域中的全局对象，这与程序运行时的全局对象的概念要加以区别，所以可以把领域中的全局对象看作是本地全局变量，其实也就是函数所属的上下文对象，它的值就是在刚才的以上的判断中确定的，如果没有这个前置对象，就会把全局对象设置为本地全局对象的值。</p><h3 id="前置知识-2-内部机制创建函数"><a href="#前置知识-2-内部机制创建函数" class="headerlink" title="前置知识 2: 内部机制创建函数"></a>前置知识 2: 内部机制创建函数</h3><p>内部机制在词法分析阶段会通过函数的定义方式向创建函数操作传入几种不同类型的函数类型：<code>Normal</code>、<code>Arrow</code>、<code>Method</code>，相对应的是普通函数、箭头函数、作为对象方法的函数。同时在这一步还传入指定代码严格模式的参数 <code>strict</code>。然后进行函数的初始化的。</p><h3 id="方式-1-内部机制初始化普通函数"><a href="#方式-1-内部机制初始化普通函数" class="headerlink" title="方式 1: 内部机制初始化普通函数"></a>方式 1: 内部机制初始化普通函数</h3><p>内部机制在这一步会设置函数的一个重要属性 <code>ThisMode</code> 的值，它是决定 <code>this</code> 绑定值的依据，它的值是根据上一步传入的参数来判断的，依次执行一下三条判断分支：</p><ul><li>函数类型为 <code>Arrow</code>：将 <code>ThisMode</code> 赋值为 <code>lexical</code> ，这个值在计算 <code>this</code> 绑定时将按照词法作用域的规则来赋值，也就是说 <code>this</code> 的值与定义函数的词法作用域中的 <code>this</code> 相一致。</li><li>代码模式为 <code>strict</code> ：将 <code>ThisMode</code> 赋值 <code>strict</code>，按照这个值计算 <code>this</code> 绑定时只会将显式传入的上下文对象绑定给 <code>this</code>。</li><li>非以上两种条件：将 <code>ThisMode</code> 赋值 <code>global</code>，被设置为 <code>global</code> 之后，函数在运行阶段被调用时，<code>this</code> 的值就会指向全局对象。</li></ul><h3 id="方式-2-内部机制创建对象方法函数"><a href="#方式-2-内部机制创建对象方法函数" class="headerlink" title="方式 2: 内部机制创建对象方法函数"></a>方式 2: 内部机制创建对象方法函数</h3><p>作为对象属性的方法是另外来计算 <code>this</code> 的，只有在作为对象方法被调用的函数，在内部创建函数时才会传入 <code>Method</code> 值。毫无疑问它将 <code>this</code> 指向了这个前置的对象。构造函数也是同理。</p><p>总结一下对一般使用到的函数的判断规则如下：</p><ul><li>箭头函数：无论调用位置，取它词法定义处的外层上下文中绑定的 <code>this</code>，没有中间本地对象存在时总是能够取到全局对象。</li><li>严格模式：无论调用位置，只取显式给定的上下文绑定的 <code>this</code>，通过 <code>call()</code>、<code>apply()</code>、<code>bind()</code> 方法传入的第一参数，否则是 <code>undefined</code>。</li><li><code>new</code> 关键字调用的构造器函数：无论调用位置，<code>this</code> 必为在内部创建的新的实例对象</li><li>显式绑定上下文对象的普通函数：无论调用位置，<code>this</code> 必为传入的上下文对象</li><li>方法函数：属于隐式绑定，无论词法定义位置，实际情况视调用处而定：<ul><li>直接调用时：<code>this</code> 为前置上下文对象</li><li>作为被引用值时：<code>this</code> 为调用时的上下文对象，在其他对象中引用 <code>this</code> 就是这个调用它的对象；被全局变量引用，<code>this</code> 就是全局对象。</li></ul></li><li>普通函数：无论词法定义位置，视调用处而定，其实质在内存都都是被作为引用值调用的，所以 <code>this</code> 都指向全局对象，严格模式规则优先。</li></ul><p>另外关于事件造成的一些 <code>this</code> 误解可以参考<a href="https://quirksmode.org/js/this.html" target="_blank" rel="noopener">The this keyword</a>这篇文章。其实并不属于特殊规则，是由于各种事件监听定义方式本身造成的。</p><p>在实际开发中可以参考《You Don’t Know JS》里关于 <code>this</code> 的绑定规则和优先级的章节<a href="https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch2.md#nothing-but-rules" target="_blank" rel="noopener">Nothing But Rules</a>。在这套基础通用规则之外，箭头函数利用了另一套方式来判断 <code>this</code> 的绑定值，这篇文章里也有详尽的叙述。</p><h2 id="参考文献：Reference"><a href="#参考文献：Reference" class="headerlink" title="参考文献：Reference"></a>参考文献：Reference</h2><ul><li>The ECMAScript 9.0 Standard<ul><li><a href="https://www.ecma-international.org/ecma-262/9.0/index.html#sec-executable-code-and-execution-contexts" target="_blank" rel="noopener">Executable Code and Execution Contexts</a></li></ul></li><li>The ECMAScript 5.1 Standard<ul><li><a href="https://ecma-international.org/ecma-262/5.1/#sec-11.1.1" target="_blank" rel="noopener">The this Keyword</a></li></ul></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/Javascript/Reference/Operators/this" target="_blank" rel="noopener">MDN web docs: this</a></li><li>You Don’t Know JS: this &amp; object prototypes<ul><li><a href="https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch1.md" target="_blank" rel="noopener">Chapter 1: this Or That?</a></li><li><a href="https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch2.md" target="_blank" rel="noopener">Chapter 2: this All Makes Sense Now!</a></li></ul></li><li><a href="http://unschooled.org/2012/03/understanding-javascript-this/" target="_blank" rel="noopener">Understanding the “this” keyword in JavaScript</a></li><li><a href="https://quirksmode.org/js/this.html" target="_blank" rel="noopener">The this keyword</a></li><li><a href="https://stackoverflow.com/questions/3127429/how-does-the-this-keyword-work" target="_blank" rel="noopener">StackOverflow: How does the “this” keyword work?</a></li><li><a href="http://www.digital-web.com/articles/scope_in_JavaScript/" target="_blank" rel="noopener">Scope In JavaScript</a></li><li><a href="http://JavaScriptissexy.com/understand-Javascripts-this-with-clarity-and-master-it/" target="_blank" rel="noopener">Understand JavaScript’s “this” With Clarity, and Master It</a></li><li><a href="http://www.ruanyifeng.com/blog/2018/06/javascript-this.html" target="_blank" rel="noopener">JavaScript 的 this 原理</a></li></ul><!--## This引起的问题：Because of This### 在全局上下文中调用的函数全局上下文中调用的函数即被全局对象所拥有，`this` 指向的是一个对象，那么这个对象自然是全局对象。最初级、最不容易混淆的就是既在全局上下文中定义又在其中被调用的函数，即全局函数，它定义的位置和调用的位置是一致的：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">a()</span><br></pre></td></tr></table></figure><p>以上代码相当于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.a()</span><br></pre></td></tr></table></figure><p>更多的是容易忽视实际调用位置而导致混淆的场景：</p><ul><li>嵌套全局函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    b()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>) &#125;</span><br><span class="line">a()</span><br></pre></td></tr></table></figure><p>这样的方式可能让一些不太熟悉 <code>JavaScript</code> 的开发者误以为函数 <code>b</code> 是在函数 <code>a</code> 的执行上下文中调用的，然而此处有一个隐藏的全局作用域上下文的绑定，其实际运行代码相当于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.b()</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.b = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">window</span>.a()</span><br></pre></td></tr></table></figure><p>这貌似说明在确定 <code>this</code> 时还是要看函数的词法定义么？其实这只是由于在浏览器宿主环境中可以省略全局对象这一便利的特性而带来的副作用，并不足以说明在判断 <code>this</code> 时词法作用域的重要。</p><ul><li>全局对象拥有的局部函数</li></ul><p>看这样一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>) &#125;</span><br><span class="line">    b()</span><br><span class="line">&#125;</span><br><span class="line">a()</span><br></pre></td></tr></table></figure><p>函数 <code>b</code> 的定义和调用都在函数 <code>a</code> 里，这下拥有函数 <code>b</code> 的对象一定是函数 <code>a</code> 了吧？不对，拥有函数 <code>b</code> 的还是 <code>window</code> 对象，这与函数的内存地址有关。语言的内部机制会向</p><p>此场景中出现最多的一个更高级的错误就是向 <code>setTimeout()</code> 函数传递对象方法所遇到的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(obj.a, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><ul><li>传递函数</li><li>-&gt;</li></ul>]]></content>
    
    <summary type="html">
    
      `this` 是 `JavaScript` 中非常重要且使用最广的一个关键字，它的值指向了一个对象的引用。这个引用的结果非常容易引起开发者的误判，所以必须对这个关键字刨根问底。
    
    </summary>
    
    
      <category term="Dev" scheme="https://ushio-s.github.io/categories/Dev/"/>
    
      <category term="Understanding JavaScript" scheme="https://ushio-s.github.io/categories/Dev/Understanding-JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://ushio-s.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>理解JavaScript的核心知识点：作用域</title>
    <link href="https://ushio-s.github.io/2019-01-30/understanding-javascript-core-scope/"/>
    <id>https://ushio-s.github.io/2019-01-30/understanding-javascript-core-scope/</id>
    <published>2019-01-30T02:40:15.000Z</published>
    <updated>2020-06-09T08:56:13.936Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于作用域：About-Scope"><a href="#关于作用域：About-Scope" class="headerlink" title="关于作用域：About Scope"></a>关于作用域：About Scope</h2><p>作用域是程序设计里的基础特性，是作用域使得程序运行时可以使用变量存储值、记录和改变程序的“状态”。<code>JavaScript</code> 也毫不例外，但在 <code>JavaScript</code> 中作用域的特性与其他高级语言稍有不同，这是很多学习者久久难以理清的一个核心知识点。</p><h2 id="定义：Definition"><a href="#定义：Definition" class="headerlink" title="定义：Definition"></a>定义：Definition</h2><p>首先引用两处我认为比较精辟的对作用域定义的总结：</p><blockquote><p>Scope is the accessibility of variables, functions, and objects in some particular part of your code during runtime. In other words, scope determines the visibility of variables and other resources in areas of your code.</p></blockquote><p>翻译：作用域是在运行时对代码某些特定部分中的变量、函数和对象的可访问性。换句话说，作用域决定代码区域中变量和其他资源的可见性。</p><blockquote><p>Scope is the set of rules that determines where and how a variable (identifier) can be looked-up.</p></blockquote><p>翻译：作用域是一套规则，决定变量定义在何处以及如何查找变量。</p><p>综上所述，我们可以把作用域理解成是在一套在程序运行时控制变量访问的管理机制。它规定了变量可见的区域、变量查找规则、嵌套时的检索方法。</p><h2 id="目的：Purpose"><a href="#目的：Purpose" class="headerlink" title="目的：Purpose"></a>目的：Purpose</h2><p>利用作用域是为了遵循程序设计中的最小访问原则，也称<a href="https://baike.baidu.com/item/%E6%9C%80%E5%B0%8F%E7%89%B9%E6%9D%83%E5%8E%9F%E5%88%99" target="_blank" rel="noopener">最小特权原则</a>，这是一种以安全性为考量的程序设计原则，可以便于快速定位错误，将发生错误时的损失控制在最低程度。<a href="https://scotch.io/tutorials/understanding-scope-in-JavaScript#toc-why-scope-the-principle-of-least-access" target="_blank" rel="noopener">这篇文章的这一部分</a>举了一个电脑管理员的例子来说明最小访问原则在计算机领域的重要性。</p><p>在编程语言中，作用域还有另外两个好处——规避变量名称冲突和隐藏内部实现。</p><p>我们知道每个作用域具有自己的权利控制范围，在不同的作用域中定义相同名称的变量是完全可行的。实现这一可能性的底层机制叫做“遮蔽效益”。这一机制体在嵌套作用域下得到了更好的体现，因为变量查找的规则是逐级向上，遇到匹配则停止，当内外层都有同名变量的时候，如已在内层找到匹配的变量，就不会再继续向外层作用域查找了，就像是内层的变量把外层的同名变量遮蔽住了一样。是不是感觉非常熟悉？没错，这也是 <code>JavaScript</code> 中原型链查找的内部机制！</p><p>隐藏内部实现其实是一种编程的最佳实践，因为只要编程者愿意，大可暴露出全部代码的内部实现细节。但众所周知，这是不安全的。如果第三者在不可控的情况下修改了正常代码，影响程序的运行，这将带来灾难性的后果，这不仅是库开发者们首先会考虑的安全性问题，也是业务逻辑开发者们需要谨慎对待的可能冲突，这就是模块化之所以重要的原因。其他编程语言在语法特性层面就支持共有和私有作用域的概念，而 <code>JavaScript</code> 官方暂时还没有正式支持。目前用以隐藏内部实现的模块模式主要依赖闭包，所以闭包这一在JS领域具有独特神秘性的机制被广大开发者们又恨又爱。即便 <code>ES6</code> 的新模块机制支持以文件形式划分模块，仍然离不开闭包。</p><h2 id="生成：Generate"><a href="#生成：Generate" class="headerlink" title="生成：Generate"></a>生成：Generate</h2><p>作用域的生成主要依靠词法定义，许多语言中有函数作用域和块级作用域。<code>JavaScript</code> 主要使用的是函数作用域。怎么理解词法定义作用域？词法就是书写规则，编译器会按照所书写的代码确定出作用域范围。</p><p>大多数编程语言里都用 <code>{}</code> 来包裹一些代码语句，编译器就会将它理解为一个块级，它内部的范围就是这个块级的作用域，函数也是如此，写了多少个函数就有相应数量的作用域。虽然 <code>JavaScript</code> 是少数没有实现块级作用域的编程语言，但其实在早期的 <code>JavaScript</code> 中就有几个特性可以变相实现块级作用域，如 <code>with</code>、<code>catch</code> 语句：<code>with</code> 语句会根据传入的对象创建出一个特殊作用域，只在 <code>with</code> 中有效；而 <code>catch</code> 语句中捕捉到的错误变量在外部无法访问的原因，正是因为它创建出了一个自己的块级作用域，据 <code>You Don&#39;t Know JS</code> 的作者说市面上支持块级作用域书写风格的转译插件或 <code>CoffeeScript</code> 之类的转译语言内部都是依靠 <code>catch</code> 来实现的，that’s so tricky!</p><h2 id="相关概念：Relevant-Concepts"><a href="#相关概念：Relevant-Concepts" class="headerlink" title="相关概念：Relevant Concepts"></a>相关概念：Relevant Concepts</h2><p>在这里只讨论 <code>JavaScript</code> 中以下概念的内容和实现方式。</p><h3 id="词法作用域：Lexical-Scope"><a href="#词法作用域：Lexical-Scope" class="headerlink" title="词法作用域：Lexical Scope"></a>词法作用域：Lexical Scope</h3><p>通过上面所说的相关知识可以总结出<strong>词法作用域就是按照书写时的函数位置来决定的作用域</strong>。</p><p>看看下面这段代码，这段代码展示了除全局作用域之外的 <code>3</code> 个函数作用域，分别是函数 <code>a</code> 、函数 <code>b</code> 、函数 <code>c</code> 所各自拥有的地盘：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> aa = <span class="string">'aa'</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> bb = <span class="string">'bb'</span></span><br><span class="line">        <span class="built_in">console</span>.log(aa, bb)</span><br><span class="line">        c();</span><br><span class="line">    &#125;</span><br><span class="line">    b();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cc = <span class="string">'cc'</span></span><br><span class="line">    <span class="built_in">console</span>.log(aa, bb, cc)</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p>各个变量所属的作用域范围是显而易见的，但这段代码的执行结果是什么呢？一但面临嵌套作用域的情景，或许很多人又要犹疑了，接下来才是词法作用域的重点。</p><p>上面代码的执行结果如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b()：</span></span><br><span class="line">aa bb</span><br><span class="line"><span class="comment">// c()：</span></span><br><span class="line">Uncaught <span class="built_in">ReferenceError</span>: aa is not defined</span><br></pre></td></tr></table></figure><p>函数 <code>c</code> 的运行报错了！错误说没有找到变量 <code>aa</code>。按照函数调用时的代码来看，函数 <code>c</code> 写在函数 <code>b</code> 里，按道理来讲，函数 <code>c</code> 不是应该可以访问它嵌套的两层父级函数作用域么？从执行结果得知，词法作用域不关心函数在哪里调用，只关心函数定义在哪里，所以函数 <code>c</code> 其实直接存在全局作用域下，与函数 <code>a</code> 同级，它俩根本就是没有任何交点的世界，无法互相访问，这就是词法作用域的法则！</p><p>请谨记 <code>JavaScript</code> 就是一个应用词法作用域法则的世界。而按照函数调用时决定的作用域叫做<strong>动态作用域</strong>，在 <code>JavaScript</code> 里我们不关心它，所以把它扔出字典。</p><h3 id="函数作用域：Function-Scope"><a href="#函数作用域：Function-Scope" class="headerlink" title="函数作用域：Function Scope"></a>函数作用域：Function Scope</h3><p>很长时间以来，<code>JavaScript</code> 里只存在函数作用域（让我们暂时忽略那些里世界的块级作用域 <code>tricky</code>），所有的作用域都是以函数级别存在。对此做出最明显反证的就是条件、循环语句。函数作用域的例子在上述词法作用域中已经得到了很好的体现，就不再赘述了，这里主要探讨一下函数作用域链的机制。</p><p>以下面一段代码为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cc = <span class="string">'cc'</span></span><br><span class="line">    <span class="built_in">console</span>.log(cc)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> aa = <span class="string">'aa'</span></span><br><span class="line">    <span class="built_in">console</span>.log(aa)</span><br><span class="line">    b();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bb = <span class="string">'bb'</span></span><br><span class="line">    <span class="built_in">console</span>.log(aa, bb)</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br><span class="line">c();</span><br></pre></td></tr></table></figure><p>一个程序里可以有很多函数作用域，引擎怎么确定先从哪个作用域开始，按照词法规则先写先执行？当然不，这时就看谁先调用。函数在作用域中的声明会被提升，函数声明的书写位置不会影响函数调用，参照上例，即便是函数 <code>a</code> 定义在函数 <code>c</code> 后面，由于它会被先调用，所以在全局作用域之后还是会先进入函数 <code>a</code> 的作用域，那函数 <code>b</code> 和函数 <code>c</code> 的顺序又如何，为了解释清楚词法作用域是如何与函数调用机制结合起来，接下来要分两部分研究程序运行的细节。</p><p>都说 <code>JavaScript</code> 是个动态编程语言，然而它的作用域查找规则又是按照词法作用域（也是俗称的<strong>静态作用域</strong>）规则来决定的，实在让人费解。理解它动（执行时编译）静（运行前编译）结合的关键在于引擎在执行程序时的两个阶段：编译和运行。为了避免歧义，区分了两个词：</p><ul><li><strong>执行</strong>：引擎对程序的整体执行过程，包括编译、运行阶段。</li><li><strong>运行</strong>：具体代码的执行或函数调用的过程。</li></ul><p><code>JavaScript</code> 的<strong>动</strong>指的是在程序被执行时才进行编译，仅在代码运行前。而一般语言是先经过编译过程，随后才会被执行的，编译器与引擎执行是继时性的。<strong>静</strong>指函数作用域是根据编译时按照词法规则来确定的，不由调用时所处作用域决定。</p><p>简单来说，函数的运行和其中变量的查找是两套规则：函数作用域中的变量查找基于作用域链，而函数的调用顺序依赖函数调用的背后机制——<strong>调用栈</strong>来决定。在编译阶段，编译器收集了函数作用域的嵌套层级，形成了变量查找规则依赖的作用域链。函数调用栈使函数像栈的数据结构一样排成队列按照<strong>先进后出</strong>的规则先后运行，再根据<code>JavaScript</code> 的同步执行机制，得出正确的执行顺序是：函数 <code>a</code> =&gt;函数 <code>b</code> =&gt;函数 <code>c</code>。最后再结合词法作用域法则推断出上面示例的执行结果仅仅是一句报错提示：<code>Uncaught ReferenceError: aa is not defined</code>。把函数 <code>b</code> 引用的变量 <code>aa</code> 去掉，就可以得到完整的执行顺序的展示。</p><h3 id="块级作用域：Block-Scope"><a href="#块级作用域：Block-Scope" class="headerlink" title="块级作用域：Block Scope"></a>块级作用域：Block Scope</h3><p><code>let</code>、<code>const</code> 声明的出现终于打破了 <code>JavaScript</code> 里没有块级作用域的规则，我们可以显示使用块级语法 <code>{}</code> 或隐式地与 <code>let</code>、<code>const</code> 相结合实现块级作用域。</p><p>隐式（<code>let</code>、<code>const</code> 声明会自动劫持所在作用域形成绑定关系，所以下例中并不是在 <code>if</code> 的块级定义，而是在它的代码块内部创建了一个块级作用域，注意在 <code>if</code> 的条件语句中 <code>a</code> 尚未定义）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a === <span class="string">'a'</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="string">'a'</span></span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a is not defined！'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显式（显式写法揭露了块级变量定义的真实所在）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通写法，稍显啰嗦</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> a = <span class="string">'a'</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// You Don't Know JS的作者提倡的写法，保持let声明在最前，与代码块语句区分开</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    &#123; <span class="keyword">let</span> a = <span class="string">'a'</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 希望未来官方能支持的写法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> (a = <span class="string">'a'</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于块级作用域最后要关注的一个问题是<strong>暂时性死区</strong>，这个问题可以描述为：当提前使用了以 <code>var</code> 声明的变量得到的是 <code>undefined</code>，没有报错，而提前使用以 <code>let</code> 声明的变量则会抛出 <code>ReferenceError</code>。暂时性死区就是用来解释这个问题的原因。很简单，规范不允许在还没有运行到声明语句时就引用变量。来看一下根据官方非正式规范得出的解释：</p><blockquote><p>When a JavaScript engine looks through an upcoming block and finds a variable declaration, it either hoists the declaration to the top of the function or global scope (for var) or places the declaration in the TDZ (for let and const). Any attempt to access a variable in the TDZ results in a runtime error. That variable is only removed from the TDZ, and therefore safe to use, once execution flows to the variable declaration.</p></blockquote><p>翻译：当 <code>JavaScript</code> 引擎浏览即将出现的代码块并查找变量声明时，它既把声明提升到了函数的顶部或全局作用域（对于 <code>var</code> ），也将声明放入暂时性死区（对于 <code>let</code> 和<code>const</code>）。任何想要访问暂时性死区中变量的尝试都会导致运行时错误。只有当执行流到达变量声明的语句时，该变量才会从暂时性死区中移除，可以安全访问。</p><p>另外，把 <code>let</code> 跟 <code>var</code> 声明作两点比较能更好排除其他疑惑。以下述代码为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="keyword">let</span> b;</span><br></pre></td></tr></table></figure><ul><li><strong>变量提升</strong>：<code>let</code> 与 <code>var</code> 定义的变量一样都存在提升。</li><li><strong>默认赋值</strong>：<code>let</code> 与 <code>var</code> 声明却未赋值的变量都相当于默认赋值 <code>undefined</code>。</li></ul><p><code>let</code> 与 <code>var</code> 声明提前引用导致的结果的区别仅仅是因为在编译器在词法分析阶段，将块级作用域变量做了特殊处理，用暂时性死区把它们包裹住，保持块级作用域的特性。</p><h3 id="全局作用域：Global-Scope"><a href="#全局作用域：Global-Scope" class="headerlink" title="全局作用域：Global Scope"></a>全局作用域：Global Scope</h3><p>全局作用域仿佛是透明存在的，容易受到忽视，就像人们经常忘记身处氧气包裹中一样，变量无法超越全局作用域存在，人们也无法脱离地球给我们提供的氧气圈。简而言之，<strong>全局作用域就是运行时的顶级作用域</strong>，一切的一切都归属于顶级作用域，它的地位如同宇宙。</p><p>我们在所有函数之外定义的变量都归属于全局作用域，这个“全局”视 <code>JavaScript</code> 代码运行的环境而定，在浏览器中是 <code>window</code> 对象，在 <code>Node.js</code> 里就是 <code>global</code> 对象，或许以后还会有更多其他的全局对象。全局对象拥有的势力范围就是它们的作用域，定义在它们之中的变量对所有其他内层作用域都是可见的，即共享，所以开发者们都非常讨厌在全局定义变量，这继承自上面所说的最小特权原则的思想，为安全起见，定义在全局作用域里的变量越少越好，于是一个叫做<strong>全局污染</strong>的话题由此引发。</p><p>全局作用域在运行时会由引擎创建，不需要我们自己来实现。</p><h3 id="局部作用域：Local-Scope"><a href="#局部作用域：Local-Scope" class="headerlink" title="局部作用域：Local Scope"></a>局部作用域：Local Scope</h3><p>与全局作用域相对的概念就是局部作用域，或者叫本地作用域。<strong>局部作用域就是在全局作用域之下创建的任何内层作用域</strong>，可以说我们定义的任何函数和块级作用域都是局部作用域，一般在用来与全局作用域做区别的时候才会采用这种概括说法。在开发中，我们主要关心的是使用函数作用域来实现局部作用域的这一具体方式。</p><h3 id="公有作用域：Public-Scope"><a href="#公有作用域：Public-Scope" class="headerlink" title="公有作用域：Public Scope"></a>公有作用域：Public Scope</h3><p><strong>公有作用域存在于模块中，它是提供项目中所有其他模块都可以访问的变量和方法的范围或命名空间</strong>。公私作用域的概念与模块化开发息息相关，我们通常关心的是定义在公私作用域中的属性或方法。</p><p>模块化提供给程序更多的安全性控制，并隐蔽内部实现细节，但是要让程序很好的实现功能，我们有访问模块内部作用域中数据的需要。从作用域链的查找机制可知，外层作用域是无法访问内层作用域变量的，而<code>JavaScript</code> 中公私作用域的概念也不像其他编程语言中那么完整，不能通过词法直接定义公有和私有作用域变量，所以闭包成为了模块化开发中的核心力量。</p><p>闭包实现了在外层作用域中访问内层作用域变量的可能，其方法就是在内层函数里再定义一个内层函数，用来保留对想要访问的函数作用域的内存引用，这样外层作用域就可以通过这个保留引用的闭包来访问内层函数里的数据了。</p><p>通过下面两段代码的执行结果就能看出区别：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> aa = <span class="string">'aa'</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> bb = <span class="string">'bb'</span></span><br><span class="line">    &#125;</span><br><span class="line">    b()</span><br><span class="line">    <span class="built_in">console</span>.log(bb)</span><br><span class="line">&#125;</span><br><span class="line">a()</span><br></pre></td></tr></table></figure><p>控制台报错：<code>Uncaught ReferenceError: bb is not defined</code>，因为函数 <code>b</code> 在运行完后就从执行栈里出栈了，其内存引用也被内存回收机制清理掉了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> aa = <span class="string">'aa'</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> bb = <span class="string">'bb'</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">c</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(bb)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> c = b()</span><br><span class="line">    <span class="built_in">console</span>.log(c())</span><br><span class="line">&#125;</span><br><span class="line">a()</span><br></pre></td></tr></table></figure><p>而这段代码中用变量 <code>c</code> 保留了对函数 <code>b</code> 中返回的函数 <code>c</code> 的引用，函数 <code>c</code> 又根据词法作用域法则，能够进入函数 <code>b</code> 的作用域查找变量，这个引用形成的闭包就被保存在函数 <code>a</code> 中变量 <code>c</code> 的值中，函数 <code>a</code> 可以在任何想要的时候调用这个闭包来获取函数 <code>b</code> 里的数据。此时这个被返回的变量 <code>bb</code> 就成为了暴露在函数 <code>a</code> 的作用域范围内，定义在函数 <code>b</code> 里的公有作用域变量。</p><p>更加通用的实现公有作用域变量或 <code>API</code> 的方式，称为模块模式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = (<span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> aa = <span class="string">'aa'</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> bb = <span class="string">'bb'</span></span><br><span class="line">        <span class="built_in">console</span>.log(bb)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        aa: aa,</span><br><span class="line">        b: b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="built_in">console</span>.log(a.aa)</span><br><span class="line">a.b()</span><br></pre></td></tr></table></figure><p>使用闭包实现了一个单例模块，输出了共有变量 <code>a.aa</code> 和 共有方法也称 <code>API</code> 的 <code>a.b</code>。</p><h3 id="私有作用域：Private-Scope"><a href="#私有作用域：Private-Scope" class="headerlink" title="私有作用域：Private Scope"></a>私有作用域：Private Scope</h3><p>相对于公有作用域，<strong>私有作用域是存在于模块中，只能提供由定义模块直接访问的变量和方法的范围或命名空间</strong>。要澄清一个关于私有作用域变量的的误会，定义私有作用域变量，不一定是要完全避免被外部模块或方法访问，更多时候是禁止它们被直接访问。大多时候可以通过模块暴露出的公有方法来间接地访问私有作用域变量，当然想不想让它被访问或者如何限制它的增删改查就是开发者自己掌控的事情了。</p><p>接着上述公有作用域的实现，来看看私有作用域的实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = (<span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bb = <span class="string">'bb'</span></span><br><span class="line">    <span class="keyword">var</span> cc = <span class="string">'c'</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(bb)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">c</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        cc = <span class="string">'cc'</span></span><br><span class="line">        <span class="built_in">console</span>.log(cc)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        b: b,</span><br><span class="line">        c: c</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line">a.b()</span><br><span class="line">a.c()</span><br></pre></td></tr></table></figure><p>在模块 <code>a</code> 中定义的属性 <code>bb</code> 和 <code>cc</code> 都是无法直接通过引用来获取的。但是模块暴露的两个方法 <code>b</code> 和 <code>c</code>，分别实现了一个查找操作和修改操作，间接控制模块中上述两个私有作用域变量。</p><h2 id="作用域与This：Scope-vs-This"><a href="#作用域与This：Scope-vs-This" class="headerlink" title="作用域与This：Scope vs This"></a>作用域与This：Scope vs This</h2><p>在对作用域是什么的理解中，最大的一个误区就是把作用域当作 <code>this</code> 对象。</p><p>一个铁打的证据是函数作用域的确定是在词法分析时，属于编译阶段，而 <code>this</code> 对象是在运行时动态绑定到函数作用域里的。另一个更明显的证据是当函数调用时，它们内部的 <code>this</code> 指的是全局对象，而不是函数本身， 想必所有开发者都踩过这一坑，能够理解作用域与 <code>this</code> 本质上的区别。从这两点就可以肯定决不能把作用域与 <code>this</code> 等同对待。</p><p><code>this</code> 到底是什么？它跟作用域有很大关系，但具体留到以后再讨论吧。在此之前我们先要与作用域成为好朋友。</p><h2 id="参考文献：Reference"><a href="#参考文献：Reference" class="headerlink" title="参考文献：Reference"></a>参考文献：Reference</h2><ul><li><a href="https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20%26%20closures/ch1.md" target="_blank" rel="noopener">You Don’t Know JS: Scope &amp; Closures</a></li><li><a href="https://scotch.io/tutorials/understanding-scope-in-JavaScript" target="_blank" rel="noopener">Understanding Scope in JavaScript</a></li><li><a href="https://leanpub.com/understandinges6/read#leanpub-auto-functions-with-default-parameter-values" target="_blank" rel="noopener">Understanding ECMAScript 6</a></li><li><a href="https://toddmotto.com/everything-you-wanted-to-know-about-javascript-scope/" target="_blank" rel="noopener">Everything you wanted to know about JavaScript scope</a></li><li><a href="https://docs.microsoft.com/en-us/office/vba/language/concepts/getting-started/understanding-scope-and-visibility" target="_blank" rel="noopener">Understanding scope and visibility</a></li><li><a href="http://www.ruanyifeng.com/blog/2018/06/javascript-this.html" target="_blank" rel="noopener">JavaScript 的 this 原理</a></li><li><a href="http://www.ruanyifeng.com/blog/2013/11/stack.html" target="_blank" rel="noopener">Stack的三种含义</a></li><li><a href="http://jsrocks.org/2015/01/temporal-dead-zone-tdz-demystified" target="_blank" rel="noopener">TEMPORAL DEAD ZONE (TDZ) DEMYSTIFIED</a></li></ul>]]></content>
    
    <summary type="html">
    
      作用域是程序设计里的基础特性，是作用域使得程序运行时可以使用变量存储值、记录和改变程序的“状态”。`JavaScript` 也毫不例外，但在 `JavaScript` 中作用域的特性与其他高级语言稍有不同，这是很多学习者久久难以理清的一个核心知识点。
    
    </summary>
    
    
      <category term="Dev" scheme="https://ushio-s.github.io/categories/Dev/"/>
    
      <category term="Understanding JavaScript" scheme="https://ushio-s.github.io/categories/Dev/Understanding-JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://ushio-s.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>绝妙的函数：模块模式</title>
    <link href="https://ushio-s.github.io/2019-01-23/awesome-function-module/"/>
    <id>https://ushio-s.github.io/2019-01-23/awesome-function-module/</id>
    <published>2019-01-23T02:30:47.000Z</published>
    <updated>2020-06-09T08:57:30.782Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Awesome-Function-module-pattern"><a href="#Awesome-Function-module-pattern" class="headerlink" title="Awesome Function: module pattern"></a>Awesome Function: module pattern</h1><p><a href="https://awesome-function.herokuapp.com/#module" target="_blank" rel="noopener">在线演示</a></p><p>利用函数的闭包不仅可以非常轻松地实现模块模式，并且可以自己创建一个模块管理器，就这么简单！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下模块的触发方法</span></span><br><span class="line">moduleX.sayHello()</span><br></pre></td></tr></table></figure><h2 id="实现最简单的模块"><a href="#实现最简单的模块" class="headerlink" title="实现最简单的模块"></a>实现最简单的模块</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现最简单的模块</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleModule</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sayHello = <span class="function"><span class="keyword">function</span> <span class="title">sayHello</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`Hi, <span class="subst">$&#123;name&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        sayHello: sayHello</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> module1 = simpleModule()</span><br></pre></td></tr></table></figure><h2 id="实现单例模式的模块"><a href="#实现单例模式的模块" class="headerlink" title="实现单例模式的模块"></a>实现单例模式的模块</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现单例模式的模块</span></span><br><span class="line"><span class="keyword">var</span> module2 = (<span class="function"><span class="keyword">function</span> <span class="title">singleModule</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> hello = <span class="string">'Hi, Module 2'</span></span><br><span class="line">    <span class="keyword">let</span> sayHello = <span class="function"><span class="keyword">function</span> <span class="title">sayHello</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hello</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        sayHello: sayHello</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h2 id="实现保存对模块的内部引用"><a href="#实现保存对模块的内部引用" class="headerlink" title="实现保存对模块的内部引用"></a>实现保存对模块的内部引用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现保存对模块的内部引用实现保存对模块的内部引用</span></span><br><span class="line"><span class="keyword">var</span> module3 = (<span class="function"><span class="keyword">function</span> <span class="title">storeModule</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> store = &#123;&#125;</span><br><span class="line">    <span class="keyword">let</span> hello = <span class="string">'Hi, Module 3'</span></span><br><span class="line">    <span class="keyword">let</span> sayHello = <span class="function"><span class="keyword">function</span> <span class="title">sayHello</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> store.getHello()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> getHello = <span class="function"><span class="keyword">function</span> <span class="title">getHello</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hello</span><br><span class="line">    &#125;</span><br><span class="line">    store = &#123;</span><br><span class="line">        sayHello: sayHello,</span><br><span class="line">        getHello: getHello</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> store</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h2 id="实现一个模块管理器"><a href="#实现一个模块管理器" class="headerlink" title="实现一个模块管理器"></a>实现一个模块管理器</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现一个模块管理器</span></span><br><span class="line"><span class="keyword">var</span> ModuleManager = (<span class="function"><span class="keyword">function</span> <span class="title">moduleManager</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> modules = &#123;&#125;</span><br><span class="line">    <span class="keyword">let</span> register = <span class="function"><span class="keyword">function</span> <span class="title">register</span> (<span class="params">name, deps, impl</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; deps.length; i++) &#123;</span><br><span class="line">            deps[i] = modules[deps[i]]</span><br><span class="line">        &#125;</span><br><span class="line">        modules[name] = impl.apply(impl, deps)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">get</span> = function <span class="keyword">get</span> (name) &#123;</span><br><span class="line">        <span class="keyword">return</span> modules[name]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        register: register,</span><br><span class="line">        <span class="keyword">get</span>: <span class="keyword">get</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">// 注册不带依赖的模块</span><br><span class="line">ModuleManager.register('module4', [], function () &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sayHello</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`Hello, <span class="subst">$&#123;name || <span class="string">'module4'</span>&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        sayHello: sayHello</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册带依赖的模块</span></span><br><span class="line">ModuleManager.register(<span class="string">'module5'</span>, [<span class="string">'module4'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">module4</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sayHello</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;module4.sayHello()&#125;</span>, this is Module 5`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        sayHello: sayHello</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取模块等待调用</span></span><br><span class="line">module4 = ModuleManager.get(<span class="string">'module4'</span>)</span><br><span class="line">module5 = ModuleManager.get(<span class="string">'module5'</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Awesome-Function-module-pattern&quot;&gt;&lt;a href=&quot;#Awesome-Function-module-pattern&quot; class=&quot;headerlink&quot; title=&quot;Awesome Function: module patte
      
    
    </summary>
    
    
      <category term="Dev" scheme="https://ushio-s.github.io/categories/Dev/"/>
    
    
      <category term="Javascript" scheme="https://ushio-s.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>绝妙的函数：重复触发防抖</title>
    <link href="https://ushio-s.github.io/2018-11-25/awesome-function-debounce/"/>
    <id>https://ushio-s.github.io/2018-11-25/awesome-function-debounce/</id>
    <published>2018-11-25T07:29:45.000Z</published>
    <updated>2020-06-09T08:57:27.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Awesome-Function-debounce"><a href="#Awesome-Function-debounce" class="headerlink" title="Awesome Function: debounce"></a>Awesome Function: debounce</h1><p><a href="https://awesome-function.herokuapp.com/#debounce" target="_blank" rel="noopener">在线演示</a></p><h2 id="利用闭包保存定时器的debounce函数"><a href="#利用闭包保存定时器的debounce函数" class="headerlink" title="利用闭包保存定时器的debounce函数"></a>利用闭包保存定时器的debounce函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用闭包保存定时器的debounce函数</span></span><br><span class="line"><span class="keyword">const</span> debounce1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">fn, wait, scope</span>) </span>&#123;</span><br><span class="line">        clearTimeout(timer)</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            fn.call(scope)</span><br><span class="line">        &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按钮触发事件</span></span><br><span class="line">debounce1(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    paras[index - <span class="number">1</span>].innerHTML += <span class="string">' 执行的内容'</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><h2 id="利用函数属性保存定时器的debounce函数"><a href="#利用函数属性保存定时器的debounce函数" class="headerlink" title="利用函数属性保存定时器的debounce函数"></a>利用函数属性保存定时器的debounce函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用函数属性保存定时器的debounce函数</span></span><br><span class="line"><span class="keyword">const</span> debounce2 = <span class="function"><span class="keyword">function</span> (<span class="params">fn, wait, scope</span>) </span>&#123;</span><br><span class="line">    clearTimeout(debounce2.timer)</span><br><span class="line">    debounce2.timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        fn.call(scope)</span><br><span class="line">    &#125;, wait)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按钮触发事件</span></span><br><span class="line">debounce2(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    paras[index - <span class="number">1</span>].innerHTML += <span class="string">' 执行的内容'</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><h2 id="可配置是否立即执行的debounce函数"><a href="#可配置是否立即执行的debounce函数" class="headerlink" title="可配置是否立即执行的debounce函数"></a>可配置是否立即执行的debounce函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可配置是否立即执行的debounce函数</span></span><br><span class="line"><span class="keyword">const</span> debounce3 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">fn, wait, scope, immediate</span>) </span>&#123;</span><br><span class="line">        timer &amp;&amp; clearTimeout(timer)</span><br><span class="line">        <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">            !timer &amp;&amp; fn.call(scope)</span><br><span class="line">            timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                timer = <span class="literal">null</span></span><br><span class="line">                count = <span class="number">0</span></span><br><span class="line">            &#125;, wait)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                fn.call(scope)</span><br><span class="line">                timer = <span class="literal">null</span></span><br><span class="line">            &#125;, wait)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按钮触发事件，立即执行的内容</span></span><br><span class="line">debounce3(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    paras[index - <span class="number">1</span>].innerHTML += <span class="string">' 立即执行的内容'</span></span><br><span class="line">&#125;, <span class="number">1000</span>, <span class="literal">null</span>, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按钮触发事件，延迟执行的内容</span></span><br><span class="line">debounce3(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    paras[index - <span class="number">1</span>].innerHTML += <span class="string">' 延迟执行的内容'</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Awesome-Function-debounce&quot;&gt;&lt;a href=&quot;#Awesome-Function-debounce&quot; class=&quot;headerlink&quot; title=&quot;Awesome Function: debounce&quot;&gt;&lt;/a&gt;Awesome Fu
      
    
    </summary>
    
    
      <category term="Dev" scheme="https://ushio-s.github.io/categories/Dev/"/>
    
    
      <category term="Javascript" scheme="https://ushio-s.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>Angular学习笔记：应用基础架构</title>
    <link href="https://ushio-s.github.io/2018-11-07/angular-basic-architecture/"/>
    <id>https://ushio-s.github.io/2018-11-07/angular-basic-architecture/</id>
    <published>2018-11-07T03:13:40.000Z</published>
    <updated>2020-06-09T08:57:22.915Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/3497104-e426caf4194e00eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>刚接触Angular的时候觉得它的<strong>模块化</strong>让人非常不适应，并且使用TypeScript编写后更是提升了一些学习曲线，在感觉高大上的同时一头雾水摸不清。仔细学习和研究了之后发现要使用好Angular，对应用的架构要求具有高度组织性和层次性，但初学者非常容易在逻辑和文件层面出现组织混乱。为了理清这种混淆，首先得明确<strong>NgModule</strong>的概念。</p><h3 id="NgModule"><a href="#NgModule" class="headerlink" title="NgModule"></a>NgModule</h3><p>Angular赖以实现<strong>模块化</strong>开发和构建应用的方式就是定义了自身框架的模块化系统<strong>NgModule</strong>。对<strong>模块化</strong>如此强调的原因有开发者意识层面的原因，也有实践层面的原因，在Angular中尤其关键，逻辑层面的功能组织都是围绕模块来展开的。<strong>NgModule</strong>的含义有广狭之分，广义的概念就是指代Angular框架中的模块体系，狭义的概念是Angular框架中最基础的构建单元，即Angular应用是由一个个<strong>NgModule</strong>组成的，它具有代码实体。</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p><strong>NgModule</strong>最主要的用途就是在逻辑层面上组织代码，它也体现在文件组织上。</p><ul><li><p><strong>模块化</strong>：将实现一个具体功能集或特性的各部分归集到一个模块中，达到逻辑上的模块化，可以通过对这个模块进行导入和删除而引用和移除这个模块的功能。模块可以包含多个组件和服务。这个模块具体做了以下事情：</p><ul><li>引入其他模块导出的内容</li><li>声明模块包含的各部分内容</li><li>为模块内各部分提供统一的编译上下文</li><li>导出本模块可供其他模块依赖的内容</li></ul></li><li><p><strong>代码组织</strong>：除了在逻辑层面上进行组织，文件目录中也能体现这种模块化的代码组织方式，一个模块可以体现为一个目录，通过添加和移除目录来实现这部分代码的引入和删除，做整体化的模块增减。文件夹中包含了模块文件、入口组件和路由文件，然后再通过子层的组件文件夹去实现具体的视图或其他功能。一个文件组织非常到位的实例是<a href="https://github.com/akveo/ngx-admin" target="_blank" rel="noopener">ngx-admin</a>，具体的文件组件方式也要根据应用的复杂程度来调整。另外官方已经推荐了比较好的实践范式，<a href="https://www.cnblogs.com/yitim/p/angular2-study-module-framework.html" target="_blank" rel="noopener">这篇文章</a>中最后整理出的体系图可以为开发者提供一个最佳实践的示意图。</p></li></ul><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><ul><li><strong>组件</strong>：组件与Vue中的组件含义略有差异。在Angular中，组件的作用被要求更加单纯，主要是模板和数据视图的中间层，定义与视图有关的逻辑，它通过文件夹的方式组织起来，组成的构建块分别有html模板、css文件和ts视图逻辑文件。尽管不把服务等与视图无关的逻辑按文件拆分开来放也不影响最终的应用实现，但Angular希望能让组件与服务这些用装饰器实现的声明类在逻辑层面上各司其职，在文件组织层面上各就其位。根据构建单元的引用层级，组件一般还包含了以下部分：<ul><li>模板：与组件关联的html文件</li><li>指令：Angular提供的结构化指令如 <code>*ngIf</code>、<code>*ngFor</code>，插值模板指令如<code>ngModel</code>，可自定义</li><li>管道：格式化显示插值</li></ul></li><li><strong>服务</strong>：与视图无关并可跨组件共享的功能模块。</li></ul><h4 id="NgModule与ES-Module"><a href="#NgModule与ES-Module" class="headerlink" title="NgModule与ES Module"></a>NgModule与ES Module</h4><p>ES Module是语言语法层面上的模块体系，NgModule是Angular逻辑框架层面上的模块体系，这两个模块系统的层面不同，是无冲突的。简而言之，ES Module的使用以文件为单位，在其他框架构建的应用中与NgModule毫无关联。</p><p>在Angular应用中，模块的实现依赖于这两个模块系统的结合，是相辅相成的。由于NgModule是框架自身以逻辑实现的，与文件的绑定并无严格关系，模块导入这种语法层面的事情还是得需要ES Module来处理，所以通过分析，可以很显然得出结论，ES module处理文件依赖关系，NgModule处理应用逻辑依赖关系。</p><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>Angular架构中使用JS特性最突出的一点就是类，所有逻辑功能单元都被声明为类，模块、组件、服务、指令、管道等都是作为类来导出，而这些类本身是没有办法区分彼此，难道都只能通过口头约定么？</p><p>另一个特性<strong>装饰器</strong>无疑为这个问题提供了一个近乎完美的解决方案，<strong>装饰器</strong>这个概念的引入得益于其他高级语言，而且这个方案的应用早就很成熟了，Python里就屡见不鲜。之前在学习ES6特性的时候一直觉得此特性只可远观，通过学习Angular的一番实践，终于知道它是多么强大的开发助攻了。</p><p>在Angular所有的构建单元声明前都要包装一层装饰器，元数据作为一个对象传入装饰器中用来在内部逻辑中将类和声明的另一些构建块（如模板、样式）和构建单元建立关联，同时明确这个类的身份。这样在构建单元相互引用依赖时，就能区别引入的构建单元的类型，同时会制约它们的行为。</p><h3 id="Angular应用的基础架构"><a href="#Angular应用的基础架构" class="headerlink" title="Angular应用的基础架构"></a>Angular应用的基础架构</h3><p><strong>装饰器</strong>是Angular架构中高层的抽象机制它区别了Angular中声明类的类别，<strong>NgModule</strong>是逻辑层面的组织结构，它与<strong>装饰器</strong>一起构筑了整个Angular应用架构的基石。</p>]]></content>
    
    <summary type="html">
    
      刚接触Angular的时候觉得它的**模块化**让人非常不适应，并且使用TypeScript编写后更是提升了一些学习曲线，在感觉高大上的同时一头雾水摸不清。仔细学习和研究了之后发现要使用好Angular，对应用的架构要求具有高度组织性和层次性，但初学者非常容易在逻辑和文件层面出现组织混乱。
    
    </summary>
    
    
      <category term="Dev" scheme="https://ushio-s.github.io/categories/Dev/"/>
    
    
      <category term="Angular" scheme="https://ushio-s.github.io/tags/Angular/"/>
    
      <category term="TypeScript" scheme="https://ushio-s.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>绝妙的函数：字符串去重</title>
    <link href="https://ushio-s.github.io/2018-10-25/awesome-function-deduplicate/"/>
    <id>https://ushio-s.github.io/2018-10-25/awesome-function-deduplicate/</id>
    <published>2018-10-25T07:29:45.000Z</published>
    <updated>2020-06-09T08:57:35.021Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Awesome-Function-dedulpicate"><a href="#Awesome-Function-dedulpicate" class="headerlink" title="Awesome Function: dedulpicate"></a>Awesome Function: dedulpicate</h1><p><a href="https://awesome-function.herokuapp.com/#deduplicate" target="_blank" rel="noopener">在线演示</a></p><p>原始数据：’我我们都是勤勤劳的小蜜蜂蜂蜜我我们都是勤勤劳的…’</p><p>经过较大数据的测试，方法一和方法三的性能最好，不相上下，可见正则的威力还是很大的。<br>另外在正则方法的实现上，eval函数可谓是最大功臣，所以此函数并不是一无是处的。</p><h2 id="方法一：利用ES6原生Set-API"><a href="#方法一：利用ES6原生Set-API" class="headerlink" title="方法一：利用ES6原生Set API"></a>方法一：利用ES6原生Set API</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> deduplicate1 = <span class="function"><span class="params">string</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(string.split(<span class="string">''</span>))).join(<span class="string">''</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二：逐一取出字符串首元素同时过滤相同元素"><a href="#方法二：逐一取出字符串首元素同时过滤相同元素" class="headerlink" title="方法二：逐一取出字符串首元素同时过滤相同元素"></a>方法二：逐一取出字符串首元素同时过滤相同元素</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> deduplicate2 = <span class="function"><span class="params">string</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">    <span class="keyword">let</span> arr = string.split(<span class="string">''</span>)</span><br><span class="line">    <span class="keyword">while</span> (arr.length) &#123;</span><br><span class="line">        <span class="keyword">let</span> current = arr.shift()</span><br><span class="line">        result.push(current)</span><br><span class="line">        arr = arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> item !== current)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.join(<span class="string">''</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法三：逐一取出字符串首元素同时过滤相同元素正则版"><a href="#方法三：逐一取出字符串首元素同时过滤相同元素正则版" class="headerlink" title="方法三：逐一取出字符串首元素同时过滤相同元素正则版"></a>方法三：逐一取出字符串首元素同时过滤相同元素正则版</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> deduplicate3 = <span class="function"><span class="params">string</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> s = string</span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">    <span class="keyword">let</span> current = <span class="string">''</span></span><br><span class="line">    <span class="keyword">while</span> (s.length) &#123;</span><br><span class="line">        current = s[<span class="number">0</span>]</span><br><span class="line">        result.push(current)</span><br><span class="line">        s = s.slice(<span class="number">1</span>)</span><br><span class="line">        s = s.replace(<span class="built_in">eval</span>(<span class="string">`/<span class="subst">$&#123;current&#125;</span>/g`</span>), <span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.join(<span class="string">''</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Awesome-Function-dedulpicate&quot;&gt;&lt;a href=&quot;#Awesome-Function-dedulpicate&quot; class=&quot;headerlink&quot; title=&quot;Awesome Function: dedulpicate&quot;&gt;&lt;/a&gt;A
      
    
    </summary>
    
    
      <category term="Dev" scheme="https://ushio-s.github.io/categories/Dev/"/>
    
    
      <category term="Javascript" scheme="https://ushio-s.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>绝妙的函数：随机打乱数组</title>
    <link href="https://ushio-s.github.io/2018-10-10/awesome-function-shuffle/"/>
    <id>https://ushio-s.github.io/2018-10-10/awesome-function-shuffle/</id>
    <published>2018-10-10T08:32:26.000Z</published>
    <updated>2020-06-09T08:57:21.069Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Awesome-Function-shuffle"><a href="#Awesome-Function-shuffle" class="headerlink" title="Awesome Function: shuffle"></a>Awesome Function: shuffle</h1><p><a href="https://awesome-function.herokuapp.com/#shuffle" target="_blank" rel="noopener">在线演示</a></p><p>原始数据：[‘红桃J’, ‘黑桃A’, ‘方块8’, ‘梅花6’, ‘黑桃K’, ‘红桃A’, ‘梅花9’, ‘梅花2’, ‘红桃K’, ‘黑桃5’]</p><h2 id="方法一：数组数据两两交换"><a href="#方法一：数组数据两两交换" class="headerlink" title="方法一：数组数据两两交换"></a>方法一：数组数据两两交换</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shuffle = <span class="function"><span class="params">array</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> count = array.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (count) &#123;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (count + <span class="number">1</span>))</span><br><span class="line">        ;[array[index], array[count]] = [array[count], array[index]]</span><br><span class="line">        count--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法在测试时踩了一个大坑，因为没有句尾分号，解构赋值的方括号与前一语句混在一起导致了报错，好一会检查不到错误之处，后来终于解决。</p><h2 id="方法二：首尾取元素随机插入"><a href="#方法二：首尾取元素随机插入" class="headerlink" title="方法二：首尾取元素随机插入"></a>方法二：首尾取元素随机插入</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shuffle2 = <span class="function"><span class="params">array</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> count = len = array.length</span><br><span class="line">    <span class="keyword">while</span> (count) &#123;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * len)</span><br><span class="line">        array.splice(index, <span class="number">0</span>, array.pop())</span><br><span class="line">        count--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> shuffle2 = <span class="function"><span class="params">array</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> count = len = array.length</span><br><span class="line">    <span class="keyword">while</span> (count) &#123;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * len)</span><br><span class="line">        array.splice(index, <span class="number">0</span>, array.shift())</span><br><span class="line">        count--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法三：简单随机抽样重组"><a href="#方法三：简单随机抽样重组" class="headerlink" title="方法三：简单随机抽样重组"></a>方法三：简单随机抽样重组</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shuffle3 = <span class="function"><span class="params">array</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> tempArr = <span class="built_in">Array</span>.of(...array)</span><br><span class="line">    <span class="keyword">let</span> newArr = []</span><br><span class="line">    <span class="keyword">let</span> count = tempArr.length</span><br><span class="line">    <span class="keyword">while</span> (count) &#123;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (count - <span class="number">1</span>))</span><br><span class="line">        newArr.push(tempArr.splice(index, <span class="number">1</span>)[<span class="number">0</span>])</span><br><span class="line">        count--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newArr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Awesome-Function-shuffle&quot;&gt;&lt;a href=&quot;#Awesome-Function-shuffle&quot; class=&quot;headerlink&quot; title=&quot;Awesome Function: shuffle&quot;&gt;&lt;/a&gt;Awesome Funct
      
    
    </summary>
    
    
      <category term="Dev" scheme="https://ushio-s.github.io/categories/Dev/"/>
    
    
      <category term="Javascript" scheme="https://ushio-s.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>[译文] APP以原生的方式在Web和移动端工作</title>
    <link href="https://ushio-s.github.io/2018-09-18/translation-apps-that-work-natively-on-the-web-and-mobile/"/>
    <id>https://ushio-s.github.io/2018-09-18/translation-apps-that-work-natively-on-the-web-and-mobile/</id>
    <published>2018-09-18T08:24:48.000Z</published>
    <updated>2020-06-09T08:57:42.785Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn-images-1.medium.com/max/1000/1*ab_36pX6F7h5x3JnuvGC4Q.png" alt="Shared Project"></p><p>今天，我们非常高兴地宣布了一种将Angular与NativeScript结合起来构建web和移动端应用的令人激动的新方式。</p><p>首先，介绍一些背景：从Angular一开始，你就可以使用NativeScript结合Angular来创建移动应用。</p><blockquote><p>NativeScript是一个使用JavaScript创建真实原生移动端应用的开源框架。它让你可以使用已有的Angular技术构建项目，最终得到的结果具有iOS和Android原生的UI和性能表现。</p></blockquote><p>但是，如果你需要<strong>同时</strong>构建web和原生移动应用，你还是得创建、开发和维护两个分离的项目。虽然这样也能完成任务，但显然我们可以比这做得更好。</p><h2 id="代码共享的梦想"><a href="#代码共享的梦想" class="headerlink" title="代码共享的梦想"></a>代码共享的梦想</h2><p>这一挑战引出一个梦想——<strong>代码共享项目</strong>。这是一个允许你将Web和移动应用的代码保存在同一处的项目。它也可以让我们在web、iOS和Android之间共享业务逻辑，同时保证在需要时包含平台特殊代码的灵活性。</p><p>随着 <strong>Schematics</strong> 和 <strong>ng add</strong> 的出现，我们有了一整套全新的可能性。</p><p>为了实现代码共享项目，Angular和NativeScript团队联手创建了 <a href="https://github.com/nativescript/nativescript-schematics" target="_blank" rel="noopener">nativescript-schematics</a>，一个能够从单一项目构建web和移动应用的程式示意图。</p><blockquote><p>请注意要使用@nativescript/schematics，必须保证@angular/cli是6.1.0以上版本。</p></blockquote><p>我们来看看哪些场景可以使用 Angular CLI 和 {N} Schematics：</p><ul><li>使用代码共享结构创建的新项目</li><li>将已有web项目转换成代码共享结构</li></ul><p>然后：</p><ul><li>将已存在组件和模块转化成代码共享格式</li><li>生成新的代码共享格式的组件和模块</li></ul><h3 id="共享或不共享"><a href="#共享或不共享" class="headerlink" title="共享或不共享"></a>共享或不共享</h3><p>这套工具的目的是尽可能多的共享代码，分离平台专有代码到单独的文件中。</p><p>这通常是说我们可以为下列功能共享代码：</p><ul><li>实现导航的<strong>路由</strong></li><li>为公共业务逻辑提供的<strong>服务</strong></li><li>管理组件公共行为的<strong>组件类定义</strong></li></ul><p>同时我们分离下列文件：</p><ul><li><strong>UI表现层（样式表和html文件)）</strong>——因为在web和NativeScript构建的原生APP中需要使用不同的用户界面。</li><li><strong>angular模块</strong>——这样我们可以导入平台专有的模块，避免web和移动端冲突。(例如，Angular Material Design——仅供Web)。</li></ul><p>下面这张示意图让我们能够从更高层面一览构建逻辑。</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*GW5nqEDJ48NndzZK1zj3vQ.png" alt="Build Process"></p><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>你可以从创建一个代码共享结构的新项目开始。只需要执行 <code>ng new</code> ，并制定collection变量为 <strong>@nativescript/schematics</strong>。</p><p>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng new --collection&#x3D;@nativescript&#x2F;schematics --name&#x3D;my-app --shared</span><br></pre></td></tr></table></figure><p>注意，你需要先安装 <strong>@nativescript/schematics</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --global @nativescript&#x2F;schematics</span><br></pre></td></tr></table></figure><p>或者我们可以扩展现有的web项目，使其能够使用NativeScript构建移动应用程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng add @nativescript&#x2F;schematics</span><br></pre></td></tr></table></figure><p>这条命令添加了以下 <strong>NativeScript专有</strong>文件：</p><ul><li>npm模块</li><li>AppModule定义</li><li>AppComponent定义</li><li>tsconfig</li></ul><h3 id="构建过程"><a href="#构建过程" class="headerlink" title="构建过程"></a>构建过程</h3><p>为了完成工作，我们还需要一个能够使用共享文件和平台专有文件的构建过程，来提供web或移动应用。</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*E6BqogQ_1g1N8nWyhVOCMw.png" alt="Shared Project"></p><h4 id="构建Web"><a href="#构建Web" class="headerlink" title="构建Web"></a><em>构建Web</em></h4><p>构建Web应用跟往常的一样，使用Angular CLI来完成工作。</p><p>当执行 <code>ng serve</code> 或 <code>ng build</code> 时，Angular CLI会忽略NativeScript专有文件——因为web文件不会引用任何.tns标识的文件。</p><p><code>ng serve</code> -&gt; 以代码共享目录启动web应用的服务</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"exclude"</span>: [</span><br><span class="line">  <span class="string">"**/*.ns.ts"</span>,</span><br><span class="line">  <span class="string">"**/*.tns.ts"</span>,</span><br><span class="line">  <span class="string">"**/*.android.ts"</span>,</span><br><span class="line">  <span class="string">"**/*.ios.ts"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="构建移动应用"><a href="#构建移动应用" class="headerlink" title="构建移动应用"></a><em>构建移动应用</em></h4><p>用 <strong>NativeScript</strong> 构建iOS或Android应用，我们需要使用<a href="https://www.npmjs.com/package/nativescript" target="_blank" rel="noopener">NativeScript CLI</a> 和 <a href="https://www.npmjs.com/package/nativescript-dev-webpack" target="_blank" rel="noopener">NativeScript Webpack plugin</a>。</p><p>调用：</p><ul><li><code>tns run ios --bundle</code> ——构建iOS应用</li><li><code>tns run android --bundle</code> ——构建Android应用</li></ul><p>在构建时，<strong>Webpack</strong> 会处理有提供了.tns标识的文件，然后隐藏web版的文件（实际上，像<strong>home.component.tns.html</strong>这样的文件，会被当作<strong>home.component.html</strong>来处理）。同时<strong>NativeScript CLI</strong> 的职责是构建原生移动应用。</p><h3 id="代码分离"><a href="#代码分离" class="headerlink" title="代码分离"></a>代码分离</h3><p>在共享代码之前，我们需要知道怎么分离Web和移动端代码。这非常重要，这样我们便可以简单无冲突地创建平台专有代码。</p><p>我们可以使用一个简单的 <strong>命名空间</strong> 来达到这个目的。通过在文件扩展名之前添加 <strong>.tns</strong>，用来表示这个文件是NativeScript专有的，同时没有使用 <strong>.tns</strong> 扩展的文件就被认为是Web专有的。如果我们只有一个文件没有使用 <strong>.tns</strong> 扩展，它就被当做一个共享文件。</p><h3 id="组件——代码共享的格式"><a href="#组件——代码共享的格式" class="headerlink" title="组件——代码共享的格式"></a>组件——代码共享的格式</h3><p>最常见的场景是一个组件的代码，我们经常有这些文件：</p><ul><li><strong>name.component.ts</strong>——组件类定义共享文件</li><li><strong>name.component.html</strong>——Web专有模板</li><li><strong>name.component.tns.html</strong>——移动专有模板</li><li><strong>name.component.css</strong>——Web专有样式表</li><li><strong>name.component.tns.css</strong>——移动专有模板</li></ul><p><img src="https://cdn-images-1.medium.com/max/1000/1*qKw7Ctykc2zB2E5OaqfXAg.png" alt="file namespace"></p><p>同样值得注意的是，在@Component装饰器中，templateUrl和styleUrls指向的文件不包括.tns扩展，因为这是由构建过程处理的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app-name'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./name.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./name.component.css'</span>],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Angular模块的代码分离方式：HttpClient"><a href="#Angular模块的代码分离方式：HttpClient" class="headerlink" title="Angular模块的代码分离方式：HttpClient"></a>Angular模块的代码分离方式：HttpClient</h3><p>配合NgModules来分离代码是非常有用的，因为你经常需要导入Web或NativeScript专有的模块。</p><p>一个非常好的例子是当你需要调用一个HTTP请求时，在Web应用中，你需要导入 <strong>HttpClientModule</strong> 模块，它提供了 <strong>HttpClient</strong> 的实现。</p><p>但是，浏览器里HTTP请求的执行方式与在iOS和Android里不同，在NativeScript中，你需要使用 <strong>NativeScriptHttpClientModule</strong> 模块，它提供了与 <strong>HttpClient</strong> 等价的执行。</p><p>现在，你可以使用代码分离技术创建两个版本的@NgModule——每个版本使用不同版本的 <strong>HttpClientModule</strong> 模块——然后在依赖注入的帮助下向服务提供正确的 <strong>HttpClient</strong> 实现。</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*ytfIpjgSZ-x0Q_4O0fpbsQ.png" alt="Code Separation"></p><ul><li><strong>my.module.ts</strong>——导入 <strong>HttpClientModule</strong> 的Web版模块文件<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; HttpClientModule &#125; <span class="keyword">from</span> <span class="string">'@angular/common/http'</span>;</span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  imports: [</span><br><span class="line">    HttpClientModule,</span><br><span class="line">    …</span><br><span class="line">  ]</span><br><span class="line">  …</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><strong>my.module.tns.ts</strong>——导入 <strong>NativeScriptHttpClientModule</strong> 的移动端版模块文件<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NativeScriptHttpClientModule &#125; <span class="keyword">from</span> <span class="string">'nativescript-angular/http-client'</span>;</span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  imports: [</span><br><span class="line">    NativeScriptHttpClientModule,</span><br><span class="line">    …</span><br><span class="line">  ]</span><br><span class="line">  …</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">MyModule</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure></li><li><strong>my.service.ts</strong>——注入<strong>HttpClient</strong> 的共享服务文件</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HttpClient &#125; <span class="keyword">from</span> <span class="string">'@angular/common/http'</span>;</span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(private http: HttpClient) &#123; &#125;</span><br><span class="line">  …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模块的代码分离是一种简单而优雅的解决方案。它使你能够将具有不同实现（针对Web和移动端应用）的功能整合到一起，从而最大化共享代码。</p><h2 id="示例项目"><a href="#示例项目" class="headerlink" title="示例项目"></a>示例项目</h2><p>如果你有兴趣看看实现了如下功能的共享项目：</p><ul><li>共享导航</li><li>懒加载</li><li>授权保护</li><li>基于NgModule的Angular Material组件和NativeScript UI插件的代码分离</li><li>一个独立的用户服务</li><li>共享组件和分离的UI组件</li><li>可爱宠物领养</li></ul><p>可以访问我们的示例项目<a href="https://github.com/sebawita/pet-bros-lite" target="_blank" rel="noopener">pet-bros-lite</a>，它展示了所有这些代码共享概念的实际应用！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如你所见，通过一个项目同时构建Web和移动应用相当简单。你可以从一个新项目开始（使用ng new），或者向已有项目中添加移动端代码（使用ng add）。还有一个简单的命名空间约定来支持代码分离，它使你可以覆盖到多数应用场景。</p><p><a href="https://docs.nativescript.org/code-sharing/intro" target="_blank" rel="noopener">尝试一下代码分离</a>，它是如此的简单。你与在Angular中进行代码分离只有简单的 <code>ng add</code> 或 <code>ng new</code>一步。</p>]]></content>
    
    <summary type="html">
    
      今天，我们非常高兴地宣布了一种将Angular与NativeScript结合起来构建web和移动端应用的令人激动的新方式。首先，介绍一些背景：从Angular一开始，你就可以使用NativeScript结合Angular来创建移动应用。
    
    </summary>
    
    
      <category term="Dev" scheme="https://ushio-s.github.io/categories/Dev/"/>
    
    
      <category term="Translation" scheme="https://ushio-s.github.io/tags/Translation/"/>
    
      <category term="Angular" scheme="https://ushio-s.github.io/tags/Angular/"/>
    
      <category term="NativeScript" scheme="https://ushio-s.github.io/tags/NativeScript/"/>
    
  </entry>
  
  <entry>
    <title>Vue源码探究-组件的持久活跃</title>
    <link href="https://ushio-s.github.io/2018-09-04/vue-keep-alive-component/"/>
    <id>https://ushio-s.github.io/2018-09-04/vue-keep-alive-component/</id>
    <published>2018-09-04T08:32:26.000Z</published>
    <updated>2020-06-09T08:55:05.091Z</updated>
    
    <content type="html"><![CDATA[<p>*本篇代码位于<a href="https://github.com/vuejs/vue/blob/v2.5.17-beta.0/src/core/components/keep-alive.js" target="_blank" rel="noopener">vue/src/core/components/keep-alive.js</a></p><p>较新版本的Vue增加了一个内置组件 <code>keep-alive</code>，用于存储组件状态，即便失活也能保持现有状态不变，切换回来的时候不会恢复到初始状态。由此可知，路由切换的钩子所触发的事件处理是无法适用于 <code>keep-alive</code> 组件的，那如果需要根据失活与否来给予组件事件通知，该怎么办呢？如前篇所述，<code>keep-alive</code> 组件有两个特有的生命周期钩子 <code>activated</code> 和 <code>deactivated</code>，用来响应失活状态的事件处理。</p><p>来看看 <code>keep-alive</code> 组件的实现，代码文件位于 <code>components</code> 里，目前入口文件里也只有 <code>keep-alive</code> 这一个内置组件，但这个模块的分离，会不会预示着官方将在未来开发更多具有特殊功能的内置组件呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入辅助函数</span></span><br><span class="line"><span class="keyword">import</span> &#123; isRegExp, remove &#125; <span class="keyword">from</span> <span class="string">'shared/util'</span></span><br><span class="line"><span class="keyword">import</span> &#123; getFirstComponentChild &#125; <span class="keyword">from</span> <span class="string">'core/vdom/helpers/index'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义VNodeCache静态类型</span></span><br><span class="line"><span class="comment">// 它是一个包含key名和VNode键值对的对象，可想而知它是用来存储组件的</span></span><br><span class="line">type VNodeCache = &#123; [key: string]: ?VNode &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义getComponentName函数，用于获取组件名称，传入组件配置对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getComponentName</span> (<span class="params">opts: ?VNodeComponentOptions</span>): ?<span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 先尝试获取配置对象中定义的name属性，或无则获取标签名称</span></span><br><span class="line">  <span class="keyword">return</span> opts &amp;&amp; (opts.Ctor.options.name || opts.tag)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义matches函数，进行模式匹配，传入匹配的模式类型数据和name属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">matches</span> (<span class="params">pattern: string | RegExp | Array&lt;string&gt;, name: string</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 匹配数组模式</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(pattern)) &#123;</span><br><span class="line">    <span class="comment">// 使用数组方法查找name，返回结果</span></span><br><span class="line">    <span class="keyword">return</span> pattern.indexOf(name) &gt; <span class="number">-1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> pattern === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="comment">// 匹配字符串模式</span></span><br><span class="line">    <span class="comment">// 将字符串转换成数组查找name，返回结果</span></span><br><span class="line">    <span class="keyword">return</span> pattern.split(<span class="string">','</span>).indexOf(name) &gt; <span class="number">-1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isRegExp(pattern)) &#123;</span><br><span class="line">    <span class="comment">// 匹配正则表达式</span></span><br><span class="line">    <span class="comment">// 使用正则匹配name，返回结果</span></span><br><span class="line">    <span class="keyword">return</span> pattern.test(name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* istanbul ignore next */</span></span><br><span class="line">  <span class="comment">// 未匹配正确模式则返回false</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义pruneCache函数，修剪keep-alive组件缓存对象</span></span><br><span class="line"><span class="comment">// 接受keep-alive组件实例和过滤函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pruneCache</span> (<span class="params">keepAliveInstance: any, filter: Function</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取组件的cache，keys，_vnode属性</span></span><br><span class="line">  <span class="keyword">const</span> &#123; cache, keys, _vnode &#125; = keepAliveInstance</span><br><span class="line">  <span class="comment">// 遍历cache对象</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> cache) &#123;</span><br><span class="line">    <span class="comment">// 获取缓存资源</span></span><br><span class="line">    <span class="keyword">const</span> cachedNode: ?VNode = cache[key]</span><br><span class="line">    <span class="comment">// 如果缓存资源存在</span></span><br><span class="line">    <span class="keyword">if</span> (cachedNode) &#123;</span><br><span class="line">      <span class="comment">// 获取该资源的名称</span></span><br><span class="line">      <span class="keyword">const</span> name: ?string = getComponentName(cachedNode.componentOptions)</span><br><span class="line">      <span class="comment">// 当名称存在 且不匹配缓存过滤时</span></span><br><span class="line">      <span class="keyword">if</span> (name &amp;&amp; !filter(name)) &#123;</span><br><span class="line">        <span class="comment">// 执行修剪缓存资源操作</span></span><br><span class="line">        pruneCacheEntry(cache, key, keys, _vnode)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义pruneCacheEntry函数，修剪缓存条目</span></span><br><span class="line"><span class="comment">// 接受keep-alive实例的缓存对象和键名缓存对象，资源键名和当前资源</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pruneCacheEntry</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  cache: VNodeCache,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  keys: Array&lt;string&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  current?: VNode</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 检查缓存对象里是否已经有以key值存储的资源</span></span><br><span class="line">  <span class="keyword">const</span> cached = cache[key]</span><br><span class="line">  <span class="comment">// 如果有旧资源并且没有传入新资源参数或新旧资源标签不同</span></span><br><span class="line">  <span class="keyword">if</span> (cached &amp;&amp; (!current || cached.tag !== current.tag)) &#123;</span><br><span class="line">    <span class="comment">// 销毁该资源</span></span><br><span class="line">    cached.componentInstance.$destroy()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 置空key键名存储资源</span></span><br><span class="line">  cache[key] = <span class="literal">null</span></span><br><span class="line">  <span class="comment">// 移除key值的存储</span></span><br><span class="line">  remove(keys, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义模式匹配接收的数据类型</span></span><br><span class="line"><span class="keyword">const</span> patternTypes: <span class="built_in">Array</span>&lt;<span class="built_in">Function</span>&gt; = [<span class="built_in">String</span>, <span class="built_in">RegExp</span>, <span class="built_in">Array</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出keep-alive组件实例的配置对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// 定义组件名称</span></span><br><span class="line">  name: <span class="string">'keep-alive'</span>,</span><br><span class="line">  <span class="comment">// 设置abstract属性</span></span><br><span class="line">  abstract: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// 设置组件接收的属性</span></span><br><span class="line">  props: &#123;</span><br><span class="line">    <span class="comment">// include用于包含模式匹配的资源，启用缓存</span></span><br><span class="line">    include: patternTypes,</span><br><span class="line">    <span class="comment">// exclude用于排除模式匹配的资源，不启用缓存</span></span><br><span class="line">    exclude: patternTypes,</span><br><span class="line">    <span class="comment">// 最大缓存数</span></span><br><span class="line">    max: [<span class="built_in">String</span>, <span class="built_in">Number</span>]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="comment">// 实例创建时定义cache属性为空对象，用于存储资源</span></span><br><span class="line">    <span class="keyword">this</span>.cache = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">    <span class="comment">// 设置keys数组，用于存储资源的key名</span></span><br><span class="line">    <span class="keyword">this</span>.keys = []</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  destroyed () &#123;</span><br><span class="line">    <span class="comment">// 实例销毁时一并销毁存储的资源并清空缓存对象</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> <span class="keyword">this</span>.cache) &#123;</span><br><span class="line">      pruneCacheEntry(<span class="keyword">this</span>.cache, key, <span class="keyword">this</span>.keys)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  mounted () &#123;</span><br><span class="line">    <span class="comment">// DOM加载完成后，观察include和exclude属性的变动</span></span><br><span class="line">    <span class="comment">// 回调执行修改缓存对象的操作</span></span><br><span class="line">    <span class="keyword">this</span>.$watch(<span class="string">'include'</span>, val =&gt; &#123;</span><br><span class="line">      pruneCache(<span class="keyword">this</span>, name =&gt; matches(val, name))</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">this</span>.$watch(<span class="string">'exclude'</span>, val =&gt; &#123;</span><br><span class="line">      pruneCache(<span class="keyword">this</span>, name =&gt; !matches(val, name))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="comment">// 实例渲染函数</span></span><br><span class="line">    <span class="comment">// 获取keep-alive包含的子组件结构</span></span><br><span class="line">    <span class="comment">// keep-alive组件并不渲染任何真实DOM节点，只渲染嵌套在其中的组件资源</span></span><br><span class="line">    <span class="keyword">const</span> slot = <span class="keyword">this</span>.$slots.default</span><br><span class="line">    <span class="comment">// 将嵌套组件dom结构转化成虚拟节点</span></span><br><span class="line">    <span class="keyword">const</span> vnode: VNode = getFirstComponentChild(slot)</span><br><span class="line">    <span class="comment">// 获取嵌套组件的配置对象</span></span><br><span class="line">    <span class="keyword">const</span> componentOptions: ?VNodeComponentOptions = vnode &amp;&amp; vnode.componentOptions</span><br><span class="line">    <span class="comment">// 如果配置对象存在</span></span><br><span class="line">    <span class="keyword">if</span> (componentOptions) &#123;</span><br><span class="line">      <span class="comment">// 检查是否缓存的模式匹配</span></span><br><span class="line">      <span class="comment">// check pattern</span></span><br><span class="line">      <span class="comment">// 获取嵌套组件名称</span></span><br><span class="line">      <span class="keyword">const</span> name: ?string = getComponentName(componentOptions)</span><br><span class="line">      <span class="comment">// 获取传入keep-alive组件的include和exclude属性</span></span><br><span class="line">      <span class="keyword">const</span> &#123; include, exclude &#125; = <span class="keyword">this</span></span><br><span class="line">      <span class="comment">// 如果有included，且该组件不匹配included中资源</span></span><br><span class="line">      <span class="comment">// 或者有exclude。且该组件匹配exclude中的资源</span></span><br><span class="line">      <span class="comment">// 则返回虚拟节点，不继续执行缓存</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        <span class="comment">// not included</span></span><br><span class="line">        (include &amp;&amp; (!name || !matches(include, name))) ||</span><br><span class="line">        <span class="comment">// excluded</span></span><br><span class="line">        (exclude &amp;&amp; name &amp;&amp; matches(exclude, name))</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="keyword">return</span> vnode</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获取keep-alive组件的cache和keys对象</span></span><br><span class="line">      <span class="keyword">const</span> &#123; cache, keys &#125; = <span class="keyword">this</span></span><br><span class="line">      <span class="comment">// 获取嵌套组件虚拟节点的key</span></span><br><span class="line">      <span class="keyword">const</span> key: ?string = vnode.key == <span class="literal">null</span></span><br><span class="line">        <span class="comment">// 同样的构造函数可能被注册为不同的本地组件，所以cid不是判断的充分条件</span></span><br><span class="line">        <span class="comment">// same constructor may get registered as different local components</span></span><br><span class="line">        <span class="comment">// so cid alone is not enough (#3269)</span></span><br><span class="line">        ? componentOptions.Ctor.cid + (componentOptions.tag ? <span class="string">`::<span class="subst">$&#123;componentOptions.tag&#125;</span>`</span> : <span class="string">''</span>)</span><br><span class="line">        : vnode.key</span><br><span class="line">      <span class="comment">// 如果缓存对象里有以key值存储的组件资源</span></span><br><span class="line">      <span class="keyword">if</span> (cache[key]) &#123;</span><br><span class="line">        <span class="comment">// 设置当前嵌套组件虚拟节点的componentInstance属性</span></span><br><span class="line">        vnode.componentInstance = cache[key].componentInstance</span><br><span class="line">        <span class="comment">// make current key freshest</span></span><br><span class="line">        <span class="comment">// 从keys中移除旧key，添加新key</span></span><br><span class="line">        remove(keys, key)</span><br><span class="line">        keys.push(key)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 缓存中没有该资源，则直接存储资源，并存储key值</span></span><br><span class="line">        cache[key] = vnode</span><br><span class="line">        keys.push(key)</span><br><span class="line">        <span class="comment">// 如果设置了最大缓存资源数，从最开始的序号开始删除存储资源</span></span><br><span class="line">        <span class="comment">// prune oldest entry</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.max &amp;&amp; keys.length &gt; <span class="built_in">parseInt</span>(<span class="keyword">this</span>.max)) &#123;</span><br><span class="line">          pruneCacheEntry(cache, keys[<span class="number">0</span>], keys, <span class="keyword">this</span>._vnode)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置该资源虚拟节点的keepAlive标识</span></span><br><span class="line">      vnode.data.keepAlive = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回虚拟节点或dom节点</span></span><br><span class="line">    <span class="keyword">return</span> vnode || (slot &amp;&amp; slot[<span class="number">0</span>])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>keep-alive</code> 组件的实现也就这百来行代码，分为两部分：第一部分是定义一些处理具体实现的函数，比如修剪缓存对象存储资源的函数，匹配组件包含和过滤存储的函数；第二部分是导出一份 <code>keep-alive</code> 组件的应用配置对象，仔细一下这跟我们在实际中使用的方式是一样的，但这个组件具有已经定义好的特殊功能<br>，就是缓存嵌套在它之中的组件资源，实现持久活跃。</p><p>那么实现原理是什么，在代码里可以清楚得看到，这里是利用转换组件真实DOM节点为虚拟节点将其存储到 <code>keep-alive</code> 实例的 <code>cache</code> 对象中，另外也一并存储了资源的 <code>key</code> 值方便查找，然后在渲染时检测其是否符合缓存条件再进行渲染。<code>keep-alive</code> 的实现就是以上这样简单。</p><hr><p>最初一瞥此段代码时，不知所云。然而当开始逐步分析代码之后，才发现原来只是没有仔细去看，误以为很深奥，由此可见，任何不用心的行为都不能直抵事物的本质，这是借由探索这一小部分代码而得到的教训。因为在实际中有使用过这个功能，所以体会更深，有时候难免会踩到一些坑，看了源码的实现之后，发现原来是自己使用方式不对，所以了解所用轮子的实现还是很有必要的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;*本篇代码位于&lt;a href=&quot;https://github.com/vuejs/vue/blob/v2.5.17-beta.0/src/core/components/keep-alive.js&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;vue/sr
      
    
    </summary>
    
    
      <category term="Dev" scheme="https://ushio-s.github.io/categories/Dev/"/>
    
      <category term="Explore Vue" scheme="https://ushio-s.github.io/categories/Dev/Explore-Vue/"/>
    
    
      <category term="Vue" scheme="https://ushio-s.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue源码探究-全局API</title>
    <link href="https://ushio-s.github.io/2018-09-03/vue-global-api/"/>
    <id>https://ushio-s.github.io/2018-09-03/vue-global-api/</id>
    <published>2018-09-03T06:36:30.000Z</published>
    <updated>2020-06-09T08:55:24.247Z</updated>
    
    <content type="html"><![CDATA[<p><em>本篇代码位于<a href="https://github.com/vuejs/vue/tree/v2.5.17-beta.0/src/core/global-api" target="_blank" rel="noopener">vue/src/core/global-api/</a></em></p><p>Vue暴露了一些全局API来强化功能开发，API的使用示例官网上都有说明，无需多言。这里主要来看一下全局API模块的实现。全局API的文件夹里有一个入口文件，各个功能分开定义，在这个入口文件中统一注入。</p><h2 id="入口文件index-js"><a href="#入口文件index-js" class="headerlink" title="入口文件index.js"></a>入口文件index.js</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @flow */</span></span><br><span class="line"><span class="comment">// 从各个模块导入功能函数</span></span><br><span class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">'../config'</span></span><br><span class="line"><span class="keyword">import</span> &#123; initUse &#125; <span class="keyword">from</span> <span class="string">'./use'</span></span><br><span class="line"><span class="keyword">import</span> &#123; initMixin &#125; <span class="keyword">from</span> <span class="string">'./mixin'</span></span><br><span class="line"><span class="keyword">import</span> &#123; initExtend &#125; <span class="keyword">from</span> <span class="string">'./extend'</span></span><br><span class="line"><span class="keyword">import</span> &#123; initAssetRegisters &#125; <span class="keyword">from</span> <span class="string">'./assets'</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">set</span>, del &#125; from '../observer/index'</span><br><span class="line">import &#123; ASSET_TYPES &#125; <span class="keyword">from</span> <span class="string">'shared/constants'</span></span><br><span class="line"><span class="keyword">import</span> builtInComponents <span class="keyword">from</span> <span class="string">'../components/index'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入内部辅助函数</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  warn,</span><br><span class="line">  extend,</span><br><span class="line">  nextTick,</span><br><span class="line">  mergeOptions,</span><br><span class="line">  defineReactive</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义并导出initGlobalAPI函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initGlobalAPI</span> (<span class="params">Vue: GlobalAPI</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定义全局配置对象</span></span><br><span class="line">  <span class="comment">// config</span></span><br><span class="line">  <span class="keyword">const</span> configDef = &#123;&#125;</span><br><span class="line">  <span class="comment">// 定义配置对象的取值器函数</span></span><br><span class="line">  configDef.get = <span class="function"><span class="params">()</span> =&gt;</span> config</span><br><span class="line">  <span class="comment">// 不允许在外部修改配置对象，非生产环境会给出警告</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    configDef.set = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">'Do not replace the Vue.config object, set individual fields instead.'</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定义Vue类的静态属性config</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(Vue, <span class="string">'config'</span>, configDef)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 暴露工具方法</span></span><br><span class="line">  <span class="comment">// exposed util methods.</span></span><br><span class="line">  <span class="comment">// 注意：这不是全局公共API的一部分，</span></span><br><span class="line">  <span class="comment">// 除非了解到它们会带来的风险否则请避免使用。</span></span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> these are not considered part of the public API - avoid relying on</span></span><br><span class="line">  <span class="comment">// them unless you are aware of the risk.</span></span><br><span class="line">  Vue.util = &#123;</span><br><span class="line">    warn,</span><br><span class="line">    extend,</span><br><span class="line">    mergeOptions,</span><br><span class="line">    defineReactive</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义Vue的静态方法set、delete、nextTick</span></span><br><span class="line">  Vue.set = <span class="keyword">set</span></span><br><span class="line">  Vue.delete = del</span><br><span class="line">  Vue.nextTick = nextTick</span><br><span class="line"></span><br><span class="line">  // 初始化Vue.options属性为空对象</span><br><span class="line">  Vue.options = Object.create(null)</span><br><span class="line">  // 初始化options属性的各个子属性为空对象</span><br><span class="line">  ASSET_TYPES.forEach(type =&gt; &#123;</span><br><span class="line">    Vue.options[type + <span class="string">'s'</span>] = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这用于标识“基础”构造函数</span></span><br><span class="line">  <span class="comment">// 以在Weex的多实例场景中扩展所有普通对象组件</span></span><br><span class="line">  <span class="comment">// this is used to identify the "base" constructor to extend all plain-object</span></span><br><span class="line">  <span class="comment">// components with in Weex's multi-instance scenarios.</span></span><br><span class="line">  Vue.options._base = Vue</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 扩展options.components属性，加入内建组件</span></span><br><span class="line">  extend(Vue.options.components, builtInComponents)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向Vue类挂载静态方法</span></span><br><span class="line">  initUse(Vue)</span><br><span class="line">  initMixin(Vue)</span><br><span class="line">  initExtend(Vue)</span><br><span class="line">  initAssetRegisters(Vue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>入口文件从总体来讲可以分为两个部分：</p><ul><li><strong>定义静态属性</strong><ul><li><code>config</code>：在最开始的部分定义了Vue的静态属性 <code>config</code>，这是全局配置对象。</li><li><code>options</code>：稍后定义的 <code>options</code> 对象是非常重要的属性，存放初始化的数据，我们平时在创建Vue实例时传入的配置对象最终要与这份配置属性合并，在实例初始化函数中的合并配置对象一部分可以初窥端倪。</li></ul></li><li><strong>定义静态方法</strong><ul><li><code>util</code>：虽然暴露了一些辅助方法，但官方并不将它们列入公共API中，不鼓励外部使用。</li><li><code>set</code>：设置响应式对象的响应式属性，强制触发视图更新，在数组更新中非常实用，不适用于根数据属性。</li><li><code>delete</code>：删除响应式属性强制触发视图更新， 使用情境较少。</li><li><code>nextTick</code>：结束此轮循环后执行回调，常用于需要等待DOM更新或加载完成后执行的功能。</li><li><code>use</code>：安装插件，自带规避重复安装。</li><li><code>mixin</code>：常用于混入插件功能，不推荐在应用代码中使用。</li><li><code>extend</code>：创建基于Vue的子类并扩展初始内容。</li><li><code>directive</code>：注册全局指令。</li><li><code>component</code>：注册全局组件。</li><li><code>filter</code>：注册全局过滤器。</li></ul></li></ul><p>除了后6个方法之外，其他的辅助函数和方法都已经在其他模块里见识过了，继续来详细探索一下剩下的6个功能。<code>initAssetRegisters</code> 方法为Vue类注册的全局函数包括了 <code>directive</code>、<code>component</code>、<code>filter</code>，三个方法合在一个模块里，其余都分了各自的模块来定义。</p><h2 id="全局API-use"><a href="#全局API-use" class="headerlink" title="全局API use"></a>全局API use</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入toArray辅助函数</span></span><br><span class="line"><span class="keyword">import</span> &#123; toArray &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义并导出initUse函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initUse</span> (<span class="params">Vue: GlobalAPI</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定义Vue类静态方法use，接受插件函数或对象</span></span><br><span class="line">  Vue.use = <span class="function"><span class="keyword">function</span> (<span class="params">plugin: Function | Object</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 定义内部属性installedPlugins，存放已安装插件</span></span><br><span class="line">    <span class="comment">// 首次应用时定义为空数组</span></span><br><span class="line">    <span class="keyword">const</span> installedPlugins = (<span class="keyword">this</span>._installedPlugins || (<span class="keyword">this</span>._installedPlugins = []))</span><br><span class="line">    <span class="comment">// 检测是否安装过传入的插件，已存在则返回</span></span><br><span class="line">    <span class="keyword">if</span> (installedPlugins.indexOf(plugin) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理附加参数，加入参数Vue</span></span><br><span class="line">    <span class="comment">// additional parameters</span></span><br><span class="line">    <span class="comment">// 将传入的参数转化为数组</span></span><br><span class="line">    <span class="keyword">const</span> args = toArray(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 插入Vue类本身为第一个元素</span></span><br><span class="line">    args.unshift(<span class="keyword">this</span>)</span><br><span class="line">    <span class="comment">// 如果插件有install方法，则在plugin对象上调用并传入新参数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> plugin.install === <span class="string">'function'</span>) &#123;</span><br><span class="line">      plugin.install.apply(plugin, args)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> plugin === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果plugin本身是函数，则直接调用并传入新参数</span></span><br><span class="line">      plugin.apply(<span class="literal">null</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向缓存插件数组中添加此插件并返回</span></span><br><span class="line">    installedPlugins.push(plugin)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>use</code> 方法的实现很简单，在内部定义了数组来缓存已经注册过的插件，并在下一次注册前检验是否已注册过，可以避免重复注册插件。接受的参数值得注意，如果插件本身就是一个函数，则直接调用；如果插件是对象，则必须有install方法，否则没有任何行为，这是Vue为了统一插件定义规范所设置的入口方法名称。</p><h2 id="全局API-mixin"><a href="#全局API-mixin" class="headerlink" title="全局API mixin"></a>全局API mixin</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入mergeOptions辅助函数</span></span><br><span class="line"><span class="keyword">import</span> &#123; mergeOptions &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义并导出initMixin函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initMixin</span> (<span class="params">Vue: GlobalAPI</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定义Vue的静态方法mixin</span></span><br><span class="line">  Vue.mixin = <span class="function"><span class="keyword">function</span> (<span class="params">mixin: Object</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 合并配置对象，重置Vue类的静态属性options</span></span><br><span class="line">    <span class="keyword">this</span>.options = mergeOptions(<span class="keyword">this</span>.options, mixin)</span><br><span class="line">    <span class="comment">// 返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mixin</code> 方法的实现更加简洁，在重用Vue类的所有状态下，只是重新合并了options属性。由于使用场景大都是用来混入插件功能的，所以创建项目时几乎没有运用，了解即可。</p><h2 id="全局API-extend"><a href="#全局API-extend" class="headerlink" title="全局API extend"></a>全局API extend</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入资源类型，模块方法和辅助方法</span></span><br><span class="line"><span class="keyword">import</span> &#123; ASSET_TYPES &#125; <span class="keyword">from</span> <span class="string">'shared/constants'</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineComputed, proxy &#125; <span class="keyword">from</span> <span class="string">'../instance/state'</span></span><br><span class="line"><span class="keyword">import</span> &#123; extend, mergeOptions, validateComponentName &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义并导出initExtend</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initExtend</span> (<span class="params">Vue: GlobalAPI</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 每个实例构造函数，包括Vue都有唯一的cid。</span></span><br><span class="line">  <span class="comment">// 这使我们能够为原型继承创建包装的“子构造函数”并缓存它们。</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Each instance constructor, including Vue, has a unique</span></span><br><span class="line"><span class="comment">   * cid. This enables us to create wrapped "child</span></span><br><span class="line"><span class="comment">   * constructors" for prototypal inheritance and cache them.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 设置Vue的cid为0</span></span><br><span class="line">  Vue.cid = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 定义cid变量</span></span><br><span class="line">  <span class="keyword">let</span> cid = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义类继承方法</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Class inheritance</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 定义Vue类静态方法extend，接受扩展选项对象</span></span><br><span class="line">  Vue.extend = <span class="function"><span class="keyword">function</span> (<span class="params">extendOptions: Object</span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">    <span class="comment">// extendOptions若未定义则设置为空对象</span></span><br><span class="line">    extendOptions = extendOptions || &#123;&#125;</span><br><span class="line">    <span class="comment">// 存储父类和父类的cid</span></span><br><span class="line">    <span class="keyword">const</span> Super = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">const</span> SuperId = Super.cid</span><br><span class="line">    <span class="comment">// 定义缓存构造器对象，如果扩展选项的_Ctor属性未定义则赋值空对象</span></span><br><span class="line">    <span class="keyword">const</span> cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = &#123;&#125;)</span><br><span class="line">    <span class="comment">// 如果缓存构造器已存有该构造器，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (cachedCtors[SuperId]) &#123;</span><br><span class="line">      <span class="keyword">return</span> cachedCtors[SuperId]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取扩展配置对象名称或父级配置对象名称属性，赋值给name</span></span><br><span class="line">    <span class="keyword">const</span> name = extendOptions.name || Super.options.name</span><br><span class="line">    <span class="comment">// 在非生产环境下验证name是否合法并给出警告</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; name) &#123;</span><br><span class="line">      validateComponentName(name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义子类构造函数</span></span><br><span class="line">    <span class="keyword">const</span> Sub = <span class="function"><span class="keyword">function</span> <span class="title">VueComponent</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>._init(options)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实现子类原型继承，原型指向父类原型，构造器指向Sub</span></span><br><span class="line">    Sub.prototype = <span class="built_in">Object</span>.create(Super.prototype)</span><br><span class="line">    Sub.prototype.constructor = Sub</span><br><span class="line">    <span class="comment">// 定义子类cid，并递增cid</span></span><br><span class="line">    Sub.cid = cid++</span><br><span class="line">    <span class="comment">// 定义子类options属性，合并配置对象</span></span><br><span class="line">    Sub.options = mergeOptions(</span><br><span class="line">      Super.options,</span><br><span class="line">      extendOptions</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 定义子类super属性，指向父类</span></span><br><span class="line">    Sub[<span class="string">'super'</span>] = Super</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于props和computed属性，扩展时在Vue实例上定义了代理getter。</span></span><br><span class="line">    <span class="comment">// 这避免了对每个创建的实例执行Object.defineProperty调用。</span></span><br><span class="line">    <span class="comment">// For props and computed properties, we define the proxy getters on</span></span><br><span class="line">    <span class="comment">// the Vue instances at extension time, on the extended prototype. This</span></span><br><span class="line">    <span class="comment">// avoids Object.defineProperty calls for each instance created.</span></span><br><span class="line">    <span class="comment">// 初始化子类的props</span></span><br><span class="line">    <span class="keyword">if</span> (Sub.options.props) &#123;</span><br><span class="line">      initProps(Sub)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化子类的计算属性</span></span><br><span class="line">    <span class="keyword">if</span> (Sub.options.computed) &#123;</span><br><span class="line">      initComputed(Sub)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义子类的全局API，扩展、混入和使用插件</span></span><br><span class="line">    <span class="comment">// allow further extension/mixin/plugin usage</span></span><br><span class="line">    Sub.extend = Super.extend</span><br><span class="line">    Sub.mixin = Super.mixin</span><br><span class="line">    Sub.use = Super.use</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子类的资源注册方法，允许子类有私有资源</span></span><br><span class="line">    <span class="comment">// create asset registers, so extended classes</span></span><br><span class="line">    <span class="comment">// can have their private assets too.</span></span><br><span class="line">    ASSET_TYPES.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">      Sub[type] = Super[type]</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 启用递归自查找</span></span><br><span class="line">    <span class="comment">// enable recursive self-lookup</span></span><br><span class="line">    <span class="keyword">if</span> (name) &#123;</span><br><span class="line">      Sub.options.components[name] = Sub</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在扩展时保持对父类配置对象的引用，</span></span><br><span class="line">    <span class="comment">// 以后实例化时可以检查父级配置对象是否更新</span></span><br><span class="line">    <span class="comment">// keep a reference to the super options at extension time.</span></span><br><span class="line">    <span class="comment">// later at instantiation we can check if Super's options have</span></span><br><span class="line">    <span class="comment">// been updated.</span></span><br><span class="line">    Sub.superOptions = Super.options</span><br><span class="line">    Sub.extendOptions = extendOptions</span><br><span class="line">    Sub.sealedOptions = extend(&#123;&#125;, Sub.options)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存子类构造函数</span></span><br><span class="line">    <span class="comment">// cache constructor</span></span><br><span class="line">    cachedCtors[SuperId] = Sub</span><br><span class="line">    <span class="comment">// 返回</span></span><br><span class="line">    <span class="keyword">return</span> Sub</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义初始化propss函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initProps</span> (<span class="params">Comp</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取配置对象的props属性</span></span><br><span class="line">  <span class="keyword">const</span> props = Comp.options.props</span><br><span class="line">  <span class="comment">// 设置代理</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">    proxy(Comp.prototype, <span class="string">`_props`</span>, key)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义初始化计算属性函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initComputed</span> (<span class="params">Comp</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取配置对象的computed属性</span></span><br><span class="line">  <span class="keyword">const</span> computed = Comp.options.computed</span><br><span class="line">  <span class="comment">// 设置代理</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> computed) &#123;</span><br><span class="line">    defineComputed(Comp.prototype, key, computed[key])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>extend</code> 方法是最为复杂的全局API了，它在扩展类实现继承时进行了很多处理：除去判断是否有已存储的子类构造函数之外，首先是实现类继承，原理是原型式继承；然后为子类初始化props和computed属性的代理：最后是扩展全局API。另外对继承的父类的属性也进行了引用存储。</p><h2 id="全局API-资源获取和注册"><a href="#全局API-资源获取和注册" class="headerlink" title="全局API 资源获取和注册"></a>全局API 资源获取和注册</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入资源类型和辅助函数</span></span><br><span class="line"><span class="keyword">import</span> &#123; ASSET_TYPES &#125; <span class="keyword">from</span> <span class="string">'shared/constants'</span></span><br><span class="line"><span class="keyword">import</span> &#123; isPlainObject, validateComponentName &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义并注册initAssetRegisters函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initAssetRegisters</span> (<span class="params">Vue: GlobalAPI</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建资源注册方法</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Create asset registration methods.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 遍历ASSET_TYPES数组，为Vue定义相应方法</span></span><br><span class="line">  <span class="comment">// ASSET_TYPES包括了directive、 component、filter</span></span><br><span class="line">  ASSET_TYPES.forEach(<span class="function"><span class="params">type</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 定义资源注册方法，参数是标识名称id，和定义函数或对象</span></span><br><span class="line">    Vue[type] = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">      id: string,</span></span></span><br><span class="line"><span class="function"><span class="params">      definition: Function | Object</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>): <span class="title">Function</span> | <span class="title">Object</span> | <span class="title">void</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 如果未传入definition，则视为获取该资源并返回</span></span><br><span class="line">      <span class="keyword">if</span> (!definition) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.options[type + <span class="string">'s'</span>][id]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则视为注册资源</span></span><br><span class="line">        <span class="comment">// 非生产环境下给出检验组件名称的错误警告</span></span><br><span class="line">        <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; type === <span class="string">'component'</span>) &#123;</span><br><span class="line">          validateComponentName(id)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是注册component，并且definition是对象类型</span></span><br><span class="line">        <span class="keyword">if</span> (type === <span class="string">'component'</span> &amp;&amp; isPlainObject(definition)) &#123;</span><br><span class="line">          <span class="comment">// 设置definition.name属性</span></span><br><span class="line">          definition.name = definition.name || id</span><br><span class="line">          <span class="comment">// 调用Vue.extend扩展定义，并重新赋值</span></span><br><span class="line">          definition = <span class="keyword">this</span>.options._base.extend(definition)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是注册directive且definition为函数</span></span><br><span class="line">        <span class="keyword">if</span> (type === <span class="string">'directive'</span> &amp;&amp; <span class="keyword">typeof</span> definition === <span class="string">'function'</span>) &#123;</span><br><span class="line">          <span class="comment">// 重新定义definition为格式化的对象</span></span><br><span class="line">          definition = &#123; <span class="attr">bind</span>: definition, <span class="attr">update</span>: definition &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存储资源并赋值</span></span><br><span class="line">        <span class="keyword">this</span>.options[type + <span class="string">'s'</span>][id] = definition</span><br><span class="line">        <span class="comment">// 返回definition</span></span><br><span class="line">        <span class="keyword">return</span> definition</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>initAssetRegisters</code> 包含有三，分别是 <code>directive</code>、<code>component</code>、<code>filter</code> 的注册并获取方法。方法的作用视参数而定，只传入资源标识名称ID未传定义函数或对象，则视为获取资源方法，如果都传则是资源注册方法，可谓是非常js化的。比较重要的是这里对于 <code>definition</code> 参数的重赋值，根据资源的种类不同，会进行不同的处理：组件主要是扩展Vue类，指令是格式化成定义对象，方便之后对指令的统一处理。</p><hr><p>全局API的细节大概就是以上这些，对于经常使用的方式，了解其具体实现可以帮助我们在应用时避免出现不必要的错误，对于不经常使用的方法，在探索其实现时可以学习它们的实现原理和良好的方式。重要是在实践中分清楚每一个方法的使用场景，选取最恰当的方式实现功能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;本篇代码位于&lt;a href=&quot;https://github.com/vuejs/vue/tree/v2.5.17-beta.0/src/core/global-api&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;vue/src/core/glob
      
    
    </summary>
    
    
      <category term="Dev" scheme="https://ushio-s.github.io/categories/Dev/"/>
    
      <category term="Explore Vue" scheme="https://ushio-s.github.io/categories/Dev/Explore-Vue/"/>
    
    
      <category term="Vue" scheme="https://ushio-s.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue源码探究-虚拟DOM的渲染</title>
    <link href="https://ushio-s.github.io/2018-08-27/vue-render-of-vnode/"/>
    <id>https://ushio-s.github.io/2018-08-27/vue-render-of-vnode/</id>
    <published>2018-08-27T07:06:16.000Z</published>
    <updated>2020-06-09T08:54:36.889Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://jylzs369.github.io/2018/08/16/vue-implement-of-vnode/" target="_blank" rel="noopener">虚拟节点的实现</a>一篇中，除了知道了 <code>VNode</code> 类的实现之外，还简要地整理了一下DOM渲染的路径。在这一篇中，主要来分析一下两条路径的具体实现代码。</p><p>按照创建 <code>Vue</code> 实例后的一般执行流程，首先来看看实例初始化时对渲染模块的初始处理。这也是开始 <code>mount</code> 路径的前一步。初始包括两部分，一是向 <code>Vue</code> 类原型对象上挂载渲染相关的方法，而是初始化渲染相关的属性。</p><h2 id="渲染的初始化"><a href="#渲染的初始化" class="headerlink" title="渲染的初始化"></a>渲染的初始化</h2><p><em>下面代码位于<a href="https://github.com/vuejs/vue/blob/v2.5.17-beta.0/src/core/instance/render.js" target="_blank" rel="noopener">vue/src/core/instance/render.js</a></em></p><h3 id="相关属性初始化"><a href="#相关属性初始化" class="headerlink" title="相关属性初始化"></a>相关属性初始化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义并导出initRender函数，接受vm</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initRender</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化实例的根虚拟节点</span></span><br><span class="line">  vm._vnode = <span class="literal">null</span> <span class="comment">// the root of the child tree</span></span><br><span class="line">  <span class="comment">// 定义实例的静态树节点</span></span><br><span class="line">  vm._staticTrees = <span class="literal">null</span> <span class="comment">// v-once cached trees</span></span><br><span class="line">  <span class="comment">// 获取配置对象</span></span><br><span class="line">  <span class="keyword">const</span> options = vm.$options</span><br><span class="line">  <span class="comment">// 设置父占位符节点</span></span><br><span class="line">  <span class="keyword">const</span> parentVnode = vm.$vnode = options._parentVnode <span class="comment">// the placeholder node in parent tree</span></span><br><span class="line">  <span class="comment">// renderContext存储父节点有无声明上下文</span></span><br><span class="line">  <span class="keyword">const</span> renderContext = parentVnode &amp;&amp; parentVnode.context</span><br><span class="line">  <span class="comment">// 将子虚拟节点转换成格式化的对象结构存储在实例的$slots属性</span></span><br><span class="line">  vm.$slots = resolveSlots(options._renderChildren, renderContext)</span><br><span class="line">  <span class="comment">// 初始化$scopedSlots属性为空对象</span></span><br><span class="line">  vm.$scopedSlots = emptyObject</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为实例绑定渲染虚拟节点函数_c和$createElement</span></span><br><span class="line">  <span class="comment">// 内部实际调用createElement函数，并获得恰当的渲染上下文</span></span><br><span class="line">  <span class="comment">// 参数按顺序分别是：标签、数据、子节点、标准化类型、是否标准化标识</span></span><br><span class="line">  <span class="comment">// bind the createElement fn to this instance</span></span><br><span class="line">  <span class="comment">// so that we get proper render context inside it.</span></span><br><span class="line">  <span class="comment">// args order: tag, data, children, normalizationType, alwaysNormalize</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 内部版本_c被从模板编译的渲染函数使用</span></span><br><span class="line">  <span class="comment">// internal version is used by render functions compiled from templates</span></span><br><span class="line">  vm._c = <span class="function">(<span class="params">a, b, c, d</span>) =&gt;</span> createElement(vm, a, b, c, d, <span class="literal">false</span>)</span><br><span class="line">  <span class="comment">// 用户写的渲染函数会总是应用执行标准化的公共版本</span></span><br><span class="line">  <span class="comment">// normalization is always applied for the public version, used in</span></span><br><span class="line">  <span class="comment">// user-written render functions.</span></span><br><span class="line">  vm.$createElement = <span class="function">(<span class="params">a, b, c, d</span>) =&gt;</span> createElement(vm, a, b, c, d, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为了更容易创建高阶组件，暴露了$attrs 和 $listeners</span></span><br><span class="line">  <span class="comment">// 并且需要保持属性的响应性以便能够实现更新，以下是对属性的响应处理</span></span><br><span class="line">  <span class="comment">// $attrs &amp; $listeners are exposed for easier HOC creation.</span></span><br><span class="line">  <span class="comment">// they need to be reactive so that HOCs using them are always updated</span></span><br><span class="line">  <span class="keyword">const</span> parentData = parentVnode &amp;&amp; parentVnode.data</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对属性和事件监听器进行响应处理，建立观察状态</span></span><br><span class="line">  <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    <span class="comment">// 在非生产环境时检测是否属于可读并发出警告</span></span><br><span class="line">    defineReactive(vm, <span class="string">'$attrs'</span>, parentData &amp;&amp; parentData.attrs || emptyObject, () =&gt; &#123;</span><br><span class="line">      !isUpdatingChildComponent &amp;&amp; warn(<span class="string">`$attrs is readonly.`</span>, vm)</span><br><span class="line">    &#125;, <span class="literal">true</span>)</span><br><span class="line">    defineReactive(vm, <span class="string">'$listeners'</span>, options._parentListeners || emptyObject, () =&gt; &#123;</span><br><span class="line">      !isUpdatingChildComponent &amp;&amp; warn(<span class="string">`$listeners is readonly.`</span>,  vm)</span><br><span class="line">    &#125;, <span class="literal">true</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    defineReactive(vm, <span class="string">'$attrs'</span>, parentData &amp;&amp; parentData.attrs || emptyObject, <span class="literal">null</span>, <span class="literal">true</span>)</span><br><span class="line">    defineReactive(vm, <span class="string">'$listeners'</span>, options._parentListeners || emptyObject, <span class="literal">null</span>, <span class="literal">true</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>initRender</code> 函数为实例进行了初始化处理，主要有三件事：</p><ul><li>初始化相关属性</li><li>设置绑定了上下文的生成虚拟节点的私有和共有版函数</li><li>对节点的属性和事件监听器进行状态观察</li></ul><p>生成虚拟节点函数主要会在流程中的 <code>render</code> 函数中使用。对节点属性和事件监听器的响应处理保证了在生命周期过程中节点属性和事件状态的更新。</p><h3 id="挂载方法初始化"><a href="#挂载方法初始化" class="headerlink" title="挂载方法初始化"></a>挂载方法初始化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出renderMixin函数，接收形参Vue，</span></span><br><span class="line"><span class="comment">// 使用Flow进行静态类型检查指定为Component类</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">renderMixin</span> (<span class="params">Vue: Class&lt;Component&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 为Vue原型对象绑定运行时相关的辅助方法</span></span><br><span class="line">  <span class="comment">// install runtime convenience helpers</span></span><br><span class="line">  installRenderHelpers(Vue.prototype)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 挂载Vue原型对象的$nextTick方法，接收函数类型的fn形参</span></span><br><span class="line">  Vue.prototype.$nextTick = <span class="function"><span class="keyword">function</span> (<span class="params">fn: Function</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 返回nextTick函数的执行结果</span></span><br><span class="line">    <span class="keyword">return</span> nextTick(fn, <span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 挂载Vue原型对象的_render方法，期望返回虚拟节点对象</span></span><br><span class="line">  <span class="comment">// _render方法即是根据配置对象在内部生成虚拟节点的方法</span></span><br><span class="line">  Vue.prototype._render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>): <span class="title">VNode</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将实例赋值给vm变量</span></span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// 导入vm的$options对象的render方法和_parentVnode对象</span></span><br><span class="line">    <span class="keyword">const</span> &#123; render, _parentVnode &#125; = vm.$options</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非生产环境下重置插槽上的_rendered标志以进行重复插槽检查</span></span><br><span class="line">    <span class="comment">// reset _rendered flag on slots for duplicate slot check</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> vm.$slots) &#123;</span><br><span class="line">        <span class="comment">// $flow-disable-line</span></span><br><span class="line">        vm.$slots[key]._rendered = <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有父级虚拟节点，定义并赋值实例的$scopedSlots属性</span></span><br><span class="line">    <span class="keyword">if</span> (_parentVnode) &#123;</span><br><span class="line">      vm.$scopedSlots = _parentVnode.data.scopedSlots || emptyObject</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置实例的父虚拟节点，允许render函数访问占位符节点的数据</span></span><br><span class="line">    <span class="comment">// set parent vnode. this allows render functions to have access</span></span><br><span class="line">    <span class="comment">// to the data on the placeholder node.</span></span><br><span class="line">    vm.$vnode = _parentVnode</span><br><span class="line">    <span class="comment">// 定义渲染节点</span></span><br><span class="line">    <span class="comment">// render self</span></span><br><span class="line">    <span class="keyword">let</span> vnode</span><br><span class="line">    <span class="comment">// 在实例的渲染代理对象上调用render方法，并传入$createElement参数</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      vnode = render.call(vm._renderProxy, vm.$createElement)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="comment">// 处理错误</span></span><br><span class="line">      handleError(e, vm, <span class="string">`render`</span>)</span><br><span class="line">      <span class="comment">// 返回错误渲染结果或者前一虚拟节点，防止渲染错误导致的空白组件</span></span><br><span class="line">      <span class="comment">// return error render result,</span></span><br><span class="line">      <span class="comment">// or previous vnode to prevent render error causing blank component</span></span><br><span class="line">      <span class="comment">// 非生产环境特殊处理渲染错误</span></span><br><span class="line">      <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vm.$options.renderError) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            handleError(e, vm, <span class="string">`renderError`</span>)</span><br><span class="line">            vnode = vm._vnode</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          vnode = vm._vnode</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vnode = vm._vnode</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在渲染函数出错时返回空虚拟节点</span></span><br><span class="line">    <span class="comment">// return empty vnode in case the render function errored out</span></span><br><span class="line">    <span class="keyword">if</span> (!(vnode <span class="keyword">instanceof</span> VNode)) &#123;</span><br><span class="line">      <span class="comment">// 非生产环境报错</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; <span class="built_in">Array</span>.isArray(vnode)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">'Multiple root nodes returned from render function. Render function '</span> +</span><br><span class="line">          <span class="string">'should return a single root node.'</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 创建空的虚拟节点</span></span><br><span class="line">      vnode = createEmptyVNode()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置父虚拟节点</span></span><br><span class="line">    <span class="comment">// set parent</span></span><br><span class="line">    vnode.parent = _parentVnode</span><br><span class="line">    <span class="comment">// 返回虚拟节点</span></span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染模块挂载了两个方法 <code>$nextTick</code> 公共方法和 <code>_render</code> 私有方法<code>$nextTick</code> 是实例的公有方法，这个很常见，就不多说；<code>_render</code> 是内部用来生成 <code>VNode</code> 的方法，内部调用了 <code>initRender</code> 函数中绑定的 <code>createElement</code> 函数，初始化实例一般会调用实例的公共版方法，如果是创建组件则会调用私有版方法。</p><p>另 <code>renderMixin</code> 函数在执行时还为Vue实例绑定了一些处理渲染的工具函数，具体可查看<a href="https://github.com/vuejs/vue/blob/v2.5.17-beta.0dev/src/core/instance/render-helpers/" target="_blank" rel="noopener">源代码</a>。</p><h2 id="mount-路径的具体实现"><a href="#mount-路径的具体实现" class="headerlink" title="mount 路径的具体实现"></a><code>mount</code> 路径的具体实现</h2><p>按照创建Vue实例的一般流程，初始化处理好之后，最后一步执行的 <code>vm.$mount(vm.$options.el)</code> 就宣告 <code>mount</code> 渲染路径的开始。记得好像还没有见过 <code>$mount</code> 的定义，因为这个函数是在运行时挂在到原型对象上的，web端的源代码在 <a href="https://github.com/vuejs/vue/blob/v2.5.17-beta.0/src/platforms/web/runtime/index.js" target="_blank" rel="noopener">platforms/web</a> 中，同样要值得注意的是原型的 <code>__patch__</code> 方法也是在运行时定义的。代码片段如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// install platform patch function</span></span><br><span class="line">Vue.prototype.__patch__ = inBrowser ? patch : noop</span><br><span class="line"></span><br><span class="line"><span class="comment">// public mount method</span></span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  el?: string | Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  el = el &amp;&amp; inBrowser ? query(el) : <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">return</span> mountComponent(<span class="keyword">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这两个方法都是在运行时才定义，但各自都是引用了核心代码中定义的实际实现函数：<code>mountComponent</code> 和 <code>patch</code>，下面就按照执行的流程一步步来解析这些实现渲染功能的函数。</p><h3 id="mountComponent"><a href="#mountComponent" class="headerlink" title="mountComponent"></a><code>mountComponent</code></h3><p>源代码位于<a href="https://github.com/vuejs/vue/blob/v2.5.17-beta.0/src/core/instance/lifecycle.js" target="_blank" rel="noopener">core/instance/lifecycle.js</a>中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义并导出mountComponent函数</span></span><br><span class="line"><span class="comment">// 接受Vue实例vm，DOM元素el、布尔标识hydrating参数</span></span><br><span class="line"><span class="comment">// 后两参数可选，返回组件实例</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vm: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  el: ?Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 设置实例的$el属性</span></span><br><span class="line">  vm.$el = el</span><br><span class="line">  <span class="comment">// 检测实例属性$options对象的render方法，未定义则设置为创建空节点</span></span><br><span class="line">  <span class="keyword">if</span> (!vm.$options.render) &#123;</span><br><span class="line">    vm.$options.render = createEmptyVNode</span><br><span class="line">    <span class="comment">// 非生产环境检测构建版本并警告</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> ((vm.$options.template &amp;&amp; vm.$options.template.charAt(<span class="number">0</span>) !== <span class="string">'#'</span>) ||</span><br><span class="line">        vm.$options.el || el) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">'You are using the runtime-only build of Vue where the template '</span> +</span><br><span class="line">          <span class="string">'compiler is not available. Either pre-compile the templates into '</span> +</span><br><span class="line">          <span class="string">'render functions, or use the compiler-included build.'</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">'Failed to mount component: template or render function not defined.'</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 调用生命周期钩子函数beforeMount，准备首次加载</span></span><br><span class="line">  callHook(vm, <span class="string">'beforeMount'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义updateComponent方法</span></span><br><span class="line">  <span class="keyword">let</span> updateComponent</span><br><span class="line">  <span class="comment">// 非生产环境加入性能评估</span></span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">    updateComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> name = vm._name</span><br><span class="line">      <span class="keyword">const</span> id = vm._uid</span><br><span class="line">      <span class="keyword">const</span> startTag = <span class="string">`vue-perf-start:<span class="subst">$&#123;id&#125;</span>`</span></span><br><span class="line">      <span class="keyword">const</span> endTag = <span class="string">`vue-perf-end:<span class="subst">$&#123;id&#125;</span>`</span></span><br><span class="line"></span><br><span class="line">      mark(startTag)</span><br><span class="line">      <span class="keyword">const</span> vnode = vm._render()</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(<span class="string">`vue <span class="subst">$&#123;name&#125;</span> render`</span>, startTag, endTag)</span><br><span class="line"></span><br><span class="line">      mark(startTag)</span><br><span class="line">      vm._update(vnode, hydrating)</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(<span class="string">`vue <span class="subst">$&#123;name&#125;</span> patch`</span>, startTag, endTag)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 定义updateComponent内部调用实例的_update方法</span></span><br><span class="line">    <span class="comment">// 参数为按实例状态生成的新虚拟节点树和hydrating标识</span></span><br><span class="line">    updateComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      vm._update(vm._render(), hydrating)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在Watcher类内部将此监听器设置到实例的_watcher上。</span></span><br><span class="line">  <span class="comment">// 由于初次patch可能调用$forceUpdate方法（例如在子组件的mounted钩子），</span></span><br><span class="line">  <span class="comment">// 这依赖于已经定义好的vm._watcher</span></span><br><span class="line">  <span class="comment">// we set this to vm._watcher inside the watcher's constructor</span></span><br><span class="line">  <span class="comment">// since the watcher's initial patch may call $forceUpdate (e.g. inside child</span></span><br><span class="line">  <span class="comment">// component's mounted hook), which relies on vm._watcher being already defined</span></span><br><span class="line">  <span class="comment">// 建立对渲染的观察，最末参数声明为渲染监听器，并传入监视器的before方法，</span></span><br><span class="line">  <span class="comment">// 在初次渲染之后，实例的_isMounted为true，在每次渲染更新之前会调用update钩子</span></span><br><span class="line">  <span class="keyword">new</span> Watcher(vm, updateComponent, noop, &#123;</span><br><span class="line">    before () &#123;</span><br><span class="line">      <span class="keyword">if</span> (vm._isMounted) &#123;</span><br><span class="line">        callHook(vm, <span class="string">'beforeUpdate'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>)</span><br><span class="line">  <span class="comment">// 设置hydrating标识为false</span></span><br><span class="line">  hydrating = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 手动安装的实例，mounted调用挂载在自身</span></span><br><span class="line">  <span class="comment">// 渲染创建的子组件在其插入的钩子中调用了mounted</span></span><br><span class="line">  <span class="comment">// manually mounted instance, call mounted on self</span></span><br><span class="line">  <span class="comment">// mounted is called for render-created child components in its inserted hook</span></span><br><span class="line">  <span class="comment">// vm.$vnode为空设置_isMounted属性为true，并调用mounted钩子</span></span><br><span class="line">  <span class="comment">// vm.$vnode为空是因为实例是根组件，没有父级节点。</span></span><br><span class="line">  <span class="keyword">if</span> (vm.$vnode == <span class="literal">null</span>) &#123;</span><br><span class="line">    vm._isMounted = <span class="literal">true</span></span><br><span class="line">    callHook(vm, <span class="string">'mounted'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回实例</span></span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="updateComponent"><a href="#updateComponent" class="headerlink" title="updateComponent"></a><code>updateComponent</code></h3><p><code>updateComponent</code> 函数在上一流程中定义，在执行过程中传入为待观察属性创建的监视器中，并在首次渲染时被调用。可以在上述代码中看出，其内部是执行了实例的 <code>_update</code> 方法，并传入实例 <code>_render</code> 方法的执行结果和 <code>hydrating</code> 参数，<code>hydrating</code> 似乎是与服务器端渲染有关的标识属性，暂时不太清楚具体的作用。</p><h3 id="render"><a href="#render" class="headerlink" title="_render"></a><code>_render</code></h3><p>在文首的 <code>renderMixin</code> 函数中定义，返回虚拟节点作为传入下一流程 <code>_update</code> 的第一个参数。</p><h3 id="update"><a href="#update" class="headerlink" title="_update"></a><code>_update</code></h3><p>在前文<a href="Vue源码探究-生命周期.md">生命周期</a>中的 <code>lifecycleMixin</code> 函数中定义，正是在这个方法中，发生了执行路径的分流，在 <code>mount</code> 路径中，执行首次渲染分支，将挂载的DOM元素和 <code>_render</code> 首次生成的虚拟节点传入 <code>patch</code> 函数中。</p><h3 id="patch"><a href="#patch" class="headerlink" title="patch"></a><code>patch</code></h3><p><code>patch</code> 方法定义在 <a href="https://github.com/vuejs/vue/blob/v2.5.17-beta.0/src/platforms/web/runtime/patch.js" target="_blank" rel="noopener">platforms/web/runtime/patch.js</a>中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> patch: <span class="built_in">Function</span> = createPatchFunction(&#123; nodeOps, modules &#125;)</span><br></pre></td></tr></table></figure><p>从最后一句代码可以看出，<code>patch</code> 得到的是 <code>createPatchFunction</code> 执行后内部返回的 <code>patch</code> 函数，传入的是平台特有的参数。在 <code>createPatchFunction</code> 函数执行过程中定义了一系列闭包函数来实现最终的DOM渲染，具体代码非常多，简单解释一下其内部定义的各种函数的用途，最后详细探索一下 <code>patch</code> 函数的具体实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义并导出createPatchFunction函数，接受backend参数</span></span><br><span class="line"><span class="comment">// backend参数是一个含有平台相关BOM操作的对象方法集</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createPatchFunction</span> (<span class="params">backend</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建空虚拟节点函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">emptyNodeAt</span> (<span class="params">elm</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建移除DOM节点回调</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">createRmCb</span> (<span class="params">childElm, listeners</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移除DOM节点</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">removeNode</span> (<span class="params">el</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否是未知元素</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">isUnknownElement</span> (<span class="params">vnode, inVPre</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建并插入DOM元素</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">createElm</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    vnode,</span></span></span><br><span class="line"><span class="function"><span class="params">    insertedVnodeQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">    parentElm,</span></span></span><br><span class="line"><span class="function"><span class="params">    refElm,</span></span></span><br><span class="line"><span class="function"><span class="params">    nested,</span></span></span><br><span class="line"><span class="function"><span class="params">    ownerArray,</span></span></span><br><span class="line"><span class="function"><span class="params">    index</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化组件</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">initComponent</span> (<span class="params">vnode, insertedVnodeQueue</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 激活组件</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reactivateComponent</span> (<span class="params">vnode, insertedVnodeQueue, parentElm, refElm</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插入DOM节点</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">insert</span> (<span class="params">parent, elm, ref</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建子DOM节点</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">createChildren</span> (<span class="params">vnode, children, insertedVnodeQueue</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断节点是否可对比更新</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">isPatchable</span> (<span class="params">vnode</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用创建钩子</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">invokeCreateHooks</span> (<span class="params">vnode, insertedVnodeQueue</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为组件作用域CSS设置范围id属性。</span></span><br><span class="line">  <span class="comment">// 这是作为一种特殊情况实现的，以避免通过正常的属性修补过程的开销。</span></span><br><span class="line">  <span class="comment">// set scope id attribute for scoped CSS.</span></span><br><span class="line">  <span class="comment">// this is implemented as a special case to avoid the overhead</span></span><br><span class="line">  <span class="comment">// of going through the normal attribute patching process.</span></span><br><span class="line">  <span class="comment">// 设置CSS作用域ID</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setScope</span> (<span class="params">vnode</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加虚拟节点，内部调用createElm</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">addVnodes</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用销毁钩子</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">invokeDestroyHook</span> (<span class="params">vnode</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移除虚拟节点，内部调用removeNode或removeAndInvokeRemoveHook</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">removeVnodes</span> (<span class="params">parentElm, vnodes, startIdx, endIdx</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用移除事件回调函数并移除节点</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">removeAndInvokeRemoveHook</span> (<span class="params">vnode, rm</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新子节点</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">updateChildren</span> (<span class="params">parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查重复key</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">checkDuplicateKeys</span> (<span class="params">children</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 寻找旧子节点索引</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">findIdxInOld</span> (<span class="params">node, oldCh, start, end</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对比并更新虚拟节点</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">patchVnode</span> (<span class="params">oldVnode, vnode, insertedVnodeQueue, removeOnly</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用插入钩子</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">invokeInsertHook</span> (<span class="params">vnode, queue, initial</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 渲染混合</span></span><br><span class="line">  <span class="comment">// 注意：这是一个仅限浏览器的函数，因此我们可以假设elms是DOM节点。</span></span><br><span class="line">  <span class="comment">// Note: this is a browser-only function so we can assume elms are DOM nodes.</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">hydrate</span> (<span class="params">elm, vnode, insertedVnodeQueue, inVPre</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断节点匹配</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">assertNodeMatch</span> (<span class="params">node, vnode, inVPre</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 节点补丁函数</span></span><br><span class="line">  <span class="comment">// 接受旧新虚拟节点，hydrating和removeOnly标识</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">patch</span> (<span class="params">oldVnode, vnode, hydrating, removeOnly</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果新虚拟节点未定义且存在旧节点，则调用销毁节点操作并返回</span></span><br><span class="line">    <span class="comment">// 这一步的判断是因为在旧虚拟节点存时，变动后没有生成新虚拟节点</span></span><br><span class="line">    <span class="comment">// 则说明新结构是不存在的，所以要清空旧节点。</span></span><br><span class="line">    <span class="keyword">if</span> (isUndef(vnode)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDef(oldVnode)) invokeDestroyHook(oldVnode)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化isInitialPatch标识和insertedVnodeQueue队列</span></span><br><span class="line">    <span class="keyword">let</span> isInitialPatch = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> insertedVnodeQueue = []</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下分两种情况构建节点：</span></span><br><span class="line">    <span class="comment">// 如果不存在旧虚拟节点</span></span><br><span class="line">    <span class="keyword">if</span> (isUndef(oldVnode)) &#123;</span><br><span class="line">      <span class="comment">// 空挂载（比如组件），会创建新的根元素</span></span><br><span class="line">      <span class="comment">// empty mount (likely as component), create new root element</span></span><br><span class="line">      <span class="comment">// 这种情况说明时首次渲染，设置isInitialPatch为true</span></span><br><span class="line">      isInitialPatch = <span class="literal">true</span></span><br><span class="line">      <span class="comment">// 根据虚拟节点创建新DOM节点</span></span><br><span class="line">      createElm(vnode, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 存在旧虚拟节点</span></span><br><span class="line">      <span class="comment">// 判断旧虚拟节点是否是真实的DOM元素</span></span><br><span class="line">      <span class="keyword">const</span> isRealElement = isDef(oldVnode.nodeType)</span><br><span class="line">      <span class="comment">// 如果不是真实DOM节点并且新旧虚拟节点根节点相同</span></span><br><span class="line">      <span class="keyword">if</span> (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123;</span><br><span class="line">        <span class="comment">// 执行比较新旧节点更新DOM操作</span></span><br><span class="line">        <span class="comment">// patch existing root node</span></span><br><span class="line">        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 新旧节点不相同的情况</span></span><br><span class="line">        <span class="comment">// 旧节点是DOM元素时先将旧节点转换成虚拟节点</span></span><br><span class="line">        <span class="keyword">if</span> (isRealElement) &#123;</span><br><span class="line">          <span class="comment">// 挂在到真实DOM元素</span></span><br><span class="line">          <span class="comment">// 检查是否是服务器渲染，然后执行合并操作</span></span><br><span class="line">          <span class="comment">// mounting to a real element</span></span><br><span class="line">          <span class="comment">// check if this is server-rendered content and if we can perform</span></span><br><span class="line">          <span class="comment">// a successful hydration.</span></span><br><span class="line">          <span class="comment">// 下面这两个if语句里的操作都是服务器渲染相关，暂不去了解</span></span><br><span class="line">          <span class="keyword">if</span> (oldVnode.nodeType === <span class="number">1</span> &amp;&amp; oldVnode.hasAttribute(SSR_ATTR)) &#123;</span><br><span class="line">            oldVnode.removeAttribute(SSR_ATTR)</span><br><span class="line">            hydrating = <span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (isTrue(hydrating)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hydrate(oldVnode, vnode, insertedVnodeQueue)) &#123;</span><br><span class="line">              invokeInsertHook(vnode, insertedVnodeQueue, <span class="literal">true</span>)</span><br><span class="line">              <span class="keyword">return</span> oldVnode</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">              warn(</span><br><span class="line">                <span class="string">'The client-side rendered virtual DOM tree is not matching '</span> +</span><br><span class="line">                <span class="string">'server-rendered content. This is likely caused by incorrect '</span> +</span><br><span class="line">                <span class="string">'HTML markup, for example nesting block-level elements inside '</span> +</span><br><span class="line">                <span class="string">'&lt;p&gt;, or missing &lt;tbody&gt;. Bailing hydration and performing '</span> +</span><br><span class="line">                <span class="string">'full client-side render.'</span></span><br><span class="line">              )</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 如果不是服务器渲染或合并失败，生成空的虚拟节点</span></span><br><span class="line">          <span class="comment">// either not server-rendered, or hydration failed.</span></span><br><span class="line">          <span class="comment">// create an empty node and replace it</span></span><br><span class="line">          oldVnode = emptyNodeAt(oldVnode)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义旧元素oldElm和其父元素</span></span><br><span class="line">        <span class="comment">// replacing existing element</span></span><br><span class="line">        <span class="keyword">const</span> oldElm = oldVnode.elm</span><br><span class="line">        <span class="keyword">const</span> parentElm = nodeOps.parentNode(oldElm)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据新虚拟节点创建新DOM元素，并且会插入到DOM树中</span></span><br><span class="line">        <span class="comment">// create new node</span></span><br><span class="line">        createElm(</span><br><span class="line">          vnode,</span><br><span class="line">          insertedVnodeQueue,</span><br><span class="line">          <span class="comment">// 以下参数是#4590问题的解决处理</span></span><br><span class="line">          <span class="comment">// extremely rare edge case: do not insert if old element is in a</span></span><br><span class="line">          <span class="comment">// leaving transition. Only happens when combining transition +</span></span><br><span class="line">          <span class="comment">// keep-alive + HOCs. (#4590)</span></span><br><span class="line">          oldElm._leaveCb ? <span class="literal">null</span> : parentElm,</span><br><span class="line">          nodeOps.nextSibling(oldElm)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果新的虚拟节点有父级则以递归方式更新父占位符节点元素</span></span><br><span class="line">        <span class="comment">// cbs是在生成patch函数时初始化好的事件监听器</span></span><br><span class="line">        <span class="comment">// 在此条件中也会被逐一触发</span></span><br><span class="line">        <span class="comment">// update parent placeholder node element, recursively</span></span><br><span class="line">        <span class="keyword">if</span> (isDef(vnode.parent)) &#123;</span><br><span class="line">          <span class="keyword">let</span> ancestor = vnode.parent</span><br><span class="line">          <span class="keyword">const</span> patchable = isPatchable(vnode)</span><br><span class="line">          <span class="keyword">while</span> (ancestor) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cbs.destroy.length; ++i) &#123;</span><br><span class="line">              cbs.destroy[i](ancestor)</span><br><span class="line">            &#125;</span><br><span class="line">            ancestor.elm = vnode.elm</span><br><span class="line">            <span class="keyword">if</span> (patchable) &#123;</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cbs.create.length; ++i) &#123;</span><br><span class="line">                cbs.create[i](emptyNode, ancestor)</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// #6513</span></span><br><span class="line">              <span class="comment">// invoke insert hooks that may have been merged by create hooks.</span></span><br><span class="line">              <span class="comment">// e.g. for directives that uses the "inserted" hook.</span></span><br><span class="line">              <span class="keyword">const</span> insert = ancestor.data.hook.insert</span><br><span class="line">              <span class="keyword">if</span> (insert.merged) &#123;</span><br><span class="line">                <span class="comment">// start at index 1 to avoid re-invoking component mounted hook</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; insert.fns.length; i++) &#123;</span><br><span class="line">                  insert.fns[i]()</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              registerRef(ancestor)</span><br><span class="line">            &#125;</span><br><span class="line">            ancestor = ancestor.parent</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 销毁旧节点</span></span><br><span class="line">        <span class="comment">// destroy old node</span></span><br><span class="line">        <span class="comment">// 如果旧节点的父级元素存在，则从其上移除旧节点</span></span><br><span class="line">        <span class="keyword">if</span> (isDef(parentElm)) &#123;</span><br><span class="line">          removeVnodes(parentElm, [oldVnode], <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.tag)) &#123;</span><br><span class="line">          <span class="comment">// 否则视为不存在旧DOM节点，此时如果虚拟节点有标签名</span></span><br><span class="line">          <span class="comment">// 则调用旧虚拟节点销毁钩子</span></span><br><span class="line">          invokeDestroyHook(oldVnode)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后调用新节点的插入钩子</span></span><br><span class="line">    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)</span><br><span class="line">    <span class="comment">// 返回虚拟节点的真实DOM元素</span></span><br><span class="line">    <span class="keyword">return</span> vnode.elm</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>createPatchFunction</code> 函数内容非常多，但大多数函数都是辅助性的，与节点处理和回调函数钩子相关。大致上了解作用即可。</p><p><code>patch</code> 方法的执行首先分了两条路线：</p><ul><li>不存在旧虚拟节点直接创建新节点插入到DOM树，这是首次渲染的执行路径，这种情况简单。</li><li>存在旧虚拟节点时需进行对比再更新，这种情况比较复杂，其中又要分旧节点是否是真实DOM的情况，是虚拟节点并且与新生成虚拟节点相等（这里的相等是指同样的虚拟根节点，具体可参照sameVnode的代码查看条件）则直接进行对比更新；若是真实节点要先进行到虚拟节点的转换还有与服务器渲染相关的判断，然后再根据得到的结果创建新的DOM节点插入页面，最后还要分情况进行父节点的递归更新和移除旧节点。</li></ul><p><code>patch</code> 方法的实现方式是有迹可循的，在这源代码中，可以看出之前划分的 <code>mount</code> 和 <code>update</code> 的执行流程，但要注意的是，上述的条件判断划分的路线和逻辑上划分的流程是稍有区别的，<code>mount</code> 路径其实在代码里体现为 <code>!oldVnode</code> 和 <code>oldVnode</code> 路线中是真实DOM元素的情况，跨越了两个条件，主要体现在直接调用了 <code>createElm</code> 创建并插入新节点，这是因为在渲染时分为有无声明挂载的真实DOM元素两种情况。而 <code>update</code> 直接进入的是 <code>patchVnode</code> 对比操作。虽然有点绕但是需要分清楚这种区别。然而具体如何实现节点的创建和对比更新还是得继续往里层看，由于这一条路径是讲 <code>mount</code> 情况，所以往下先看看与之接续的 <code>createElm</code> 函数。</p><h3 id="createElm"><a href="#createElm" class="headerlink" title="createElm"></a><code>createElm</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义createElm函数，一系列参数主要记住vnode，parentElm</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElm</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vnode,</span></span></span><br><span class="line"><span class="function"><span class="params">  insertedVnodeQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">  parentElm,</span></span></span><br><span class="line"><span class="function"><span class="params">  refElm,</span></span></span><br><span class="line"><span class="function"><span class="params">  nested,</span></span></span><br><span class="line"><span class="function"><span class="params">  ownerArray,</span></span></span><br><span class="line"><span class="function"><span class="params">  index</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果新虚拟节点存在真实DOM元素和ownerArray，</span></span><br><span class="line">  <span class="comment">// 则代表它在之前的渲染中用过。</span></span><br><span class="line">  <span class="comment">// 现在要被用作新节点时有潜在的错误</span></span><br><span class="line">  <span class="comment">// 所以将它改为从本身克隆的节点</span></span><br><span class="line">  <span class="keyword">if</span> (isDef(vnode.elm) &amp;&amp; isDef(ownerArray)) &#123;</span><br><span class="line">    <span class="comment">// This vnode was used in a previous render!</span></span><br><span class="line">    <span class="comment">// now it's used as a new node, overwriting its elm would cause</span></span><br><span class="line">    <span class="comment">// potential patch errors down the road when it's used as an insertion</span></span><br><span class="line">    <span class="comment">// reference node. Instead, we clone the node on-demand before creating</span></span><br><span class="line">    <span class="comment">// associated DOM element for it.</span></span><br><span class="line">    vnode = ownerArray[index] = cloneVNode(vnode)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置isRootInsert，为检查过度动画入口</span></span><br><span class="line">  vnode.isRootInsert = !nested <span class="comment">// for transition enter check</span></span><br><span class="line">  <span class="comment">// 下面判断用于keep-alive组件，若是普通组件则会返回undefined继续往下执行</span></span><br><span class="line">  <span class="keyword">if</span> (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取虚拟节点信息、子节点和标签名称</span></span><br><span class="line">  <span class="keyword">const</span> data = vnode.data</span><br><span class="line">  <span class="keyword">const</span> children = vnode.children</span><br><span class="line">  <span class="keyword">const</span> tag = vnode.tag</span><br><span class="line">  <span class="comment">// 下面三种情况创建普通节点、注释节点和文字节点</span></span><br><span class="line">  <span class="keyword">if</span> (isDef(tag)) &#123;</span><br><span class="line">    <span class="comment">// 具有标签名称，则创建普通节点</span></span><br><span class="line">    <span class="comment">// 非生产环境简则是否是正确的元素</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (data &amp;&amp; data.pre) &#123;</span><br><span class="line">        creatingElmInVPre++</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isUnknownElement(vnode, creatingElmInVPre)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">'Unknown custom element: &lt;'</span> + tag + <span class="string">'&gt; - did you '</span> +</span><br><span class="line">          <span class="string">'register the component correctly? For recursive components, '</span> +</span><br><span class="line">          <span class="string">'make sure to provide the "name" option.'</span>,</span><br><span class="line">          vnode.context</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据ns属性选择创建节点的方式创建节点</span></span><br><span class="line">    vnode.elm = vnode.ns</span><br><span class="line">      ? nodeOps.createElementNS(vnode.ns, tag)</span><br><span class="line">      : nodeOps.createElement(tag, vnode)</span><br><span class="line">    <span class="comment">// 设置节点的作用域ID</span></span><br><span class="line">    setScope(vnode)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是weex平台，可以根据参数调整节点树插入DOM的具体实现</span></span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (__WEEX__) &#123;</span><br><span class="line">      <span class="comment">// in Weex, the default insertion order is parent-first.</span></span><br><span class="line">      <span class="comment">// List items can be optimized to use children-first insertion</span></span><br><span class="line">      <span class="comment">// with append="tree".</span></span><br><span class="line">      <span class="keyword">const</span> appendAsTree = isDef(data) &amp;&amp; isTrue(data.appendAsTree)</span><br><span class="line">      <span class="keyword">if</span> (!appendAsTree) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isDef(data)) &#123;</span><br><span class="line">          invokeCreateHooks(vnode, insertedVnodeQueue)</span><br><span class="line">        &#125;</span><br><span class="line">        insert(parentElm, vnode.elm, refElm)</span><br><span class="line">      &#125;</span><br><span class="line">      createChildren(vnode, children, insertedVnodeQueue)</span><br><span class="line">      <span class="keyword">if</span> (appendAsTree) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isDef(data)) &#123;</span><br><span class="line">          invokeCreateHooks(vnode, insertedVnodeQueue)</span><br><span class="line">        &#125;</span><br><span class="line">        insert(parentElm, vnode.elm, refElm)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// web平台则先创建子节点插入父级后再一次插入DOM中</span></span><br><span class="line">      createChildren(vnode, children, insertedVnodeQueue)</span><br><span class="line">      <span class="keyword">if</span> (isDef(data)) &#123;</span><br><span class="line">        invokeCreateHooks(vnode, insertedVnodeQueue)</span><br><span class="line">      &#125;</span><br><span class="line">      insert(parentElm, vnode.elm, refElm)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; data &amp;&amp; data.pre) &#123;</span><br><span class="line">      creatingElmInVPre--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isTrue(vnode.isComment)) &#123;</span><br><span class="line">    <span class="comment">// 如果是注释节点，则创建注释节点并插入到DOM中</span></span><br><span class="line">    vnode.elm = nodeOps.createComment(vnode.text)</span><br><span class="line">    insert(parentElm, vnode.elm, refElm)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是文字节点，则创建文字节点并插入到DOM</span></span><br><span class="line">    vnode.elm = nodeOps.createTextNode(vnode.text)</span><br><span class="line">    insert(parentElm, vnode.elm, refElm)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>createElm</code> 函数包含了节点的创建和插入两部分，创建了虚拟节点对应的DOM元素之后，就会调用 <code>insert</code> 方法将它插入到页面DOM结构中。创建功能在这里遵循DOM的三种节点类型，即元素、注释和文字节点，实际与插入和移除方法一样都是使用了对应的原生方法 ，<code>nodeops</code> 对象即是在返回 <code>patch</code> 函数时预先导入了的原生DOM操作方法的集合，具体可以在<a href="https://github.com/vuejs/vue/blob/v2.5.17-beta.0/src/platforms/web/runtime/node-ops.js" target="_blank" rel="noopener">运行时的处理</a>中确认。之前生成的 <code>vnode</code> 决定了最终应该生成何种节点，在这个函数中就能够发现，最终生成的真实DOM节点是多么依赖于 <code>vnode</code> 所携带的信息，所以说虚拟节点是实现生成真实DOM的基础。</p><p>这个流程中最后一步再调用 <code>removeVnodes</code> 方法移除掉DOM树中的旧节点，到此为止 <code>mount</code> 路径的执行就结束了。</p><h2 id="update-路径的具体实现"><a href="#update-路径的具体实现" class="headerlink" title="update 路径的具体实现"></a><code>update</code> 路径的具体实现</h2><p>根据 <code>update</code> 的执行流程，前一部分是由 <code>watcher</code> 来响应的，就不再讨论，然后进入 <code>updateComponent</code> 流程，直至返回 <code>patch</code> 函数都与 <code>mount</code> 流程的实现一致，只是要执行不同的分支，整个流程中只有最后一步生成真实DOM的过程有所区别，就是 <code>patchVnode</code> 函数的执行。上面已经说过 <code>update</code> 流程中最后是要对比新旧节点然后再实现更新，这个功能即由 <code>patchVnode</code> 来完成，它的内部调用 <code>updateChildren</code> 来完成对比，实现逻辑非常有借鉴性，值得玩味。下面来看看这两个函数，</p><h3 id="patchVnode"><a href="#patchVnode" class="headerlink" title="patchVnode"></a>patchVnode</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义patchVnode函数，接收四个参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchVnode</span> (<span class="params">oldVnode, vnode, insertedVnodeQueue, removeOnly</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果新旧虚拟节点相同则结束对比</span></span><br><span class="line">  <span class="keyword">if</span> (oldVnode === vnode) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取并设置新虚拟节点的真实DOM元素</span></span><br><span class="line">  <span class="keyword">const</span> elm = vnode.elm = oldVnode.elm</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异步占位符节点的特殊处理</span></span><br><span class="line">  <span class="keyword">if</span> (isTrue(oldVnode.isAsyncPlaceholder)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDef(vnode.asyncFactory.resolved)) &#123;</span><br><span class="line">      hydrate(oldVnode.elm, vnode, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vnode.isAsyncPlaceholder = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为静态树重用元素</span></span><br><span class="line">  <span class="comment">// 只在克隆虚拟节点时使用，如非克隆节点则需要重新渲染</span></span><br><span class="line">  <span class="comment">// reuse element for static trees.</span></span><br><span class="line">  <span class="comment">// note we only do this if the vnode is cloned -</span></span><br><span class="line">  <span class="comment">// if the new node is not cloned it means the render functions have been</span></span><br><span class="line">  <span class="comment">// reset by the hot-reload-api and we need to do a proper re-render.</span></span><br><span class="line">  <span class="keyword">if</span> (isTrue(vnode.isStatic) &amp;&amp;</span><br><span class="line">    isTrue(oldVnode.isStatic) &amp;&amp;</span><br><span class="line">    vnode.key === oldVnode.key &amp;&amp;</span><br><span class="line">    (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))</span><br><span class="line">  ) &#123;</span><br><span class="line">    vnode.componentInstance = oldVnode.componentInstance</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果存在内联预处理钩子则调用</span></span><br><span class="line">  <span class="keyword">let</span> i</span><br><span class="line">  <span class="keyword">const</span> data = vnode.data</span><br><span class="line">  <span class="keyword">if</span> (isDef(data) &amp;&amp; isDef(i = data.hook) &amp;&amp; isDef(i = i.prepatch)) &#123;</span><br><span class="line">    i(oldVnode, vnode)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面是对一般情况的DOM更新处理</span></span><br><span class="line">  <span class="comment">// 获取虚拟节点子节点</span></span><br><span class="line">  <span class="keyword">const</span> oldCh = oldVnode.children</span><br><span class="line">  <span class="keyword">const</span> ch = vnode.children</span><br><span class="line">  <span class="comment">// 如果存在更新钩子则调用</span></span><br><span class="line">  <span class="keyword">if</span> (isDef(data) &amp;&amp; isPatchable(vnode)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode)</span><br><span class="line">    <span class="keyword">if</span> (isDef(i = data.hook) &amp;&amp; isDef(i = i.update)) i(oldVnode, vnode)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当新虚拟节点不存在text属性值，即不是文字节点时</span></span><br><span class="line">  <span class="keyword">if</span> (isUndef(vnode.text)) &#123;</span><br><span class="line">    <span class="comment">// 情况一：新旧虚拟节点子节点都存在时</span></span><br><span class="line">    <span class="keyword">if</span> (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</span><br><span class="line">      <span class="comment">// 不相等则更新子节点树</span></span><br><span class="line">      <span class="keyword">if</span> (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(ch)) &#123;</span><br><span class="line">      <span class="comment">// 情况二，只有新虚拟节点子节点存在，</span></span><br><span class="line">      <span class="comment">// 旧虚拟节点是文字节点，先置空元素文本内容</span></span><br><span class="line">      <span class="keyword">if</span> (isDef(oldVnode.text)) nodeOps.setTextContent(elm, <span class="string">''</span>)</span><br><span class="line">      <span class="comment">// 再向DOM元素插入新虚拟节点内容</span></span><br><span class="line">      addVnodes(elm, <span class="literal">null</span>, ch, <span class="number">0</span>, ch.length - <span class="number">1</span>, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldCh)) &#123;</span><br><span class="line">      <span class="comment">// 情况三，只有旧虚拟节点子节点存在，则移除DOM元素内容</span></span><br><span class="line">      removeVnodes(elm, oldCh, <span class="number">0</span>, oldCh.length - <span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.text)) &#123;</span><br><span class="line">      <span class="comment">// 情况四，新旧虚拟节点子节点不存在且旧虚拟节点是文字节点</span></span><br><span class="line">      <span class="comment">// 置空DOM元素文本内容</span></span><br><span class="line">      nodeOps.setTextContent(elm, <span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldVnode.text !== vnode.text) &#123;</span><br><span class="line">    <span class="comment">// 新虚拟节点是文字节点时，除非旧节点也是文字节点且内容相等</span></span><br><span class="line">    <span class="comment">// 直接将新文本内容设置到DOM元素中</span></span><br><span class="line">    nodeOps.setTextContent(elm, vnode.text)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果存在后处理钩子则调用</span></span><br><span class="line">  <span class="keyword">if</span> (isDef(data)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDef(i = data.hook) &amp;&amp; isDef(i = i.postpatch)) i(oldVnode, vnode)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>patchVnode</code> 的内容主要有三点，第一是处理异步虚拟节点；第二是处理静态可重用元素；第三是处理一般情况下的新旧节点更新。</p><p>一般情况下的新旧节点更新首先是按照新虚拟节点是否文字节点来分情况，因为DOM的更新决定权在于新的虚拟节点内容，如果是新节点是文字节点，则可以不用在意旧节点的情况，除非旧节点也是文本内容且内容无异时不需要处理，其他情况下都直接为DOM元素内容重置为新虚拟节点的文本。如果新节点不是文字节点，处理会再细分为四种情况：第一是新旧虚拟子节点都存在且不相等时，执行patch核心的更新操作 <code>updateChildren</code>。第二是只有新子节点存在而旧子节点不存在，如果旧节点是文字节点，先要置空就节点的文本内容，再向DOM元素添加新字节点的内容。第三是只有旧子节点存在而新子节点不存在时，说明更新后没有节点了，执行移除操作。第四是新旧子节点不存在而旧节点是文字节点时，清空DOM元素的文本内容。</p><p>这里要十分注意理清虚拟节点和其子节点的比较。只有当新旧虚拟节点与其各自子虚拟节点都存储的是元素节点时，才需要调用 <code>updateChildren</code> 函数来进行深入比较，其他的情况都可以比较简便的处理DOM节点的更新，这也避免了不必要的处理提高了渲染的性能。</p><p>最后来看看整个DOM节点对比更新的核心逻辑函数：</p><h3 id="updateChildren"><a href="#updateChildren" class="headerlink" title="updateChildren"></a>updateChildren</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义updateChildren函数，接受5个参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateChildren</span> (<span class="params">parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化逻辑需要的变量，由于此函数仅针对子节点，所以以下省略“子”字</span></span><br><span class="line">  <span class="keyword">let</span> oldStartIdx = <span class="number">0</span> <span class="comment">// 旧节点开始索引</span></span><br><span class="line">  <span class="keyword">let</span> newStartIdx = <span class="number">0</span> <span class="comment">// 新节点开始索引</span></span><br><span class="line">  <span class="keyword">let</span> oldEndIdx = oldCh.length - <span class="number">1</span> <span class="comment">// 旧节点结束索引</span></span><br><span class="line">  <span class="keyword">let</span> oldStartVnode = oldCh[<span class="number">0</span>] <span class="comment">// 当前旧首节点</span></span><br><span class="line">  <span class="keyword">let</span> oldEndVnode = oldCh[oldEndIdx] <span class="comment">// 当前旧尾节点</span></span><br><span class="line">  <span class="keyword">let</span> newEndIdx = newCh.length - <span class="number">1</span> <span class="comment">// 新节点结束索引</span></span><br><span class="line">  <span class="keyword">let</span> newStartVnode = newCh[<span class="number">0</span>] <span class="comment">// 当前新首节点</span></span><br><span class="line">  <span class="keyword">let</span> newEndVnode = newCh[newEndIdx] <span class="comment">// 当前新尾节点</span></span><br><span class="line">  <span class="keyword">let</span> oldKeyToIdx, idxInOld, vnodeToMove, refElm</span><br><span class="line"></span><br><span class="line">  <span class="comment">// removeOnly是仅用于&lt;transition-group&gt;情况下的特殊标识，</span></span><br><span class="line">  <span class="comment">// 确保移除的元素在离开过渡期间保持在正确的相对位置。</span></span><br><span class="line">  <span class="comment">// removeOnly is a special flag used only by &lt;transition-group&gt;</span></span><br><span class="line">  <span class="comment">// to ensure removed elements stay in correct relative positions</span></span><br><span class="line">  <span class="comment">// during leaving transitions</span></span><br><span class="line">  <span class="keyword">const</span> canMove = !removeOnly</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查新节点中有无重复key</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    checkDuplicateKeys(newCh)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以增加索引值模拟移动指针，逐一对比对应索引位置的节点</span></span><br><span class="line">  <span class="comment">// 循环仅在在新旧开始索引同时小于各自结束索引时才继续进行</span></span><br><span class="line">  <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="comment">// 对比具体分为7种情况：</span></span><br><span class="line">    <span class="keyword">if</span> (isUndef(oldStartVnode)) &#123;</span><br><span class="line">      <span class="comment">// 当前旧首节点不存在时，递增旧开始索引指向后一节点</span></span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx] <span class="comment">// Vnode has been moved left</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isUndef(oldEndVnode)) &#123;</span><br><span class="line">      <span class="comment">// 当前旧尾节点不存在时，递减旧结束索引指向前一节点</span></span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">      <span class="comment">// 当前新旧首节点相同，递归调用patchVnode对比子级</span></span><br><span class="line">      patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)</span><br><span class="line">      <span class="comment">// 递增新旧开始索引，当前新旧节点指向各自后一节点</span></span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">      <span class="comment">// 当前新旧尾节点相同，递归调用patchVnode对比子级</span></span><br><span class="line">      patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)</span><br><span class="line">      <span class="comment">// 递减新旧结束索引，当前新旧尾节点指向前一节点</span></span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">      newEndVnode = newCh[--newEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; <span class="comment">// Vnode moved right</span></span><br><span class="line">      <span class="comment">// 当前旧首节点与当前新尾节点相同，递归调用patchVnode对比</span></span><br><span class="line">      patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)</span><br><span class="line">      <span class="comment">// canMove为真则将当前旧首节点移动到下一兄弟节点前</span></span><br><span class="line">      canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br><span class="line">      <span class="comment">// 递增就开始索引，当前旧首节点指向后一节点</span></span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">      <span class="comment">// 递减新结束索引，当前新尾节点指向前一节点</span></span><br><span class="line">      newEndVnode = newCh[--newEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; <span class="comment">// Vnode moved left</span></span><br><span class="line">      <span class="comment">// 当前旧尾节点与当前新首节点相同，调用patchVnode</span></span><br><span class="line">      patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)</span><br><span class="line">      <span class="comment">// canMove为真则将当前旧尾节点移动到当前旧首节点前</span></span><br><span class="line">      canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)</span><br><span class="line">      <span class="comment">// 递减旧节点结束索引，当前旧尾节点指向前一节点</span></span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">      <span class="comment">// 递增新节点开始索引，当前新首节点指向后一节点</span></span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 其他情况下</span></span><br><span class="line">      <span class="comment">// oldKeyToIdx未定义时根据旧节点创建key和索引键值对集合</span></span><br><span class="line">      <span class="keyword">if</span> (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">      <span class="comment">// 如果当前新首节点的key存在，则idxInOld等于oldKeyToIdx中对应key的索引</span></span><br><span class="line">      <span class="comment">// 否则寻找旧节点数组中与当前新首节点相同的节点索引赋予idxInOld</span></span><br><span class="line">      idxInOld = isDef(newStartVnode.key)</span><br><span class="line">        ? oldKeyToIdx[newStartVnode.key]</span><br><span class="line">        : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">      <span class="comment">//  如果idxInOld不存在，则说明当前对比的新节点是新增节点</span></span><br><span class="line">      <span class="keyword">if</span> (isUndef(idxInOld)) &#123; <span class="comment">// New element</span></span><br><span class="line">        <span class="comment">// 创建新节点插入到父级对应位置</span></span><br><span class="line">        createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 在旧节点数组中找到了相应的节点的索引时</span></span><br><span class="line">        <span class="comment">// 将vnodeToMove赋值为相应的节点</span></span><br><span class="line">        vnodeToMove = oldCh[idxInOld]</span><br><span class="line">        <span class="comment">// 对比此节点和当前新首节点</span></span><br><span class="line">        <span class="keyword">if</span> (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class="line">          <span class="comment">// 如果相同，则继续对比子级</span></span><br><span class="line">          patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue)</span><br><span class="line">          <span class="comment">// 将旧节点数组中的该节点设置为undefined</span></span><br><span class="line">          oldCh[idxInOld] = <span class="literal">undefined</span></span><br><span class="line">          <span class="comment">// 移动找到的节点到当前旧首节点之前</span></span><br><span class="line">          canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 如不同，则说明虽然key相同，但是不同元素，当作新元素处理</span></span><br><span class="line">          <span class="comment">// same key but different element. treat as new element</span></span><br><span class="line">          <span class="comment">// 创建新元素闯入父级相应位置</span></span><br><span class="line">          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 递增新节点开始索引，当前新首节点指向下一节点</span></span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 新旧节点开始索引任一方大于其结束索引时结束循环</span></span><br><span class="line">  <span class="comment">// 当旧节点开始索引大于旧节点结束索引时</span></span><br><span class="line">  <span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">    <span class="comment">// 判断新节点数组中newEndIdx索引后的节点是否存在，若不存在refElm为null</span></span><br><span class="line">    <span class="comment">// 若存在则refElm为相应节点的elm值</span></span><br><span class="line">    refElm = isUndef(newCh[newEndIdx + <span class="number">1</span>]) ? <span class="literal">null</span> : newCh[newEndIdx + <span class="number">1</span>].elm</span><br><span class="line">    <span class="comment">// 向父节点相应位置添加该节点</span></span><br><span class="line">    addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">    <span class="comment">// 当新节点开始索引大于新节点结束索引时</span></span><br><span class="line">    <span class="comment">// 在父级中移除未处理的剩余旧节点，范围是oldStartIdx~oldEndIdx</span></span><br><span class="line">    removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>updateChildren</code> 函数的主要逻辑是利用索引来替换当前节点的引用，有如模拟指针移动指向的对象，来逐一进行对比，并且是递归进行的。指针移动的基准是参照新节点，条件满足下，根据当前的新节点来寻找旧节点中对应的节点，如果相等会递归进入子级，如果不相等当作新增节点处理，在处理之后会移动到下一个节点，继续新一轮的对比。在旧节点数组中将对比过的节点设置成 <code>undefined</code> 标志节点已处理过，避免了以后的多余对比。这里的处理逻辑是相当巧妙的，这就是节点对比更新的最基础的实现。</p><hr><p>终于把我认为Vue最核心的另一个主要功能给攻略了下来，真是激动人心。比起数据绑定，这一部分的实现也着实不简单，光是处理流就让人凌乱不堪。<code>patch</code> 所实际对应的 <code>createPatchFunction</code> 函数是这一模块的重中之重，理顺了更新渲染的流程，继而理解了这一函数的具体实现后，基本上能对Vue的渲染功能有了一定深度的把握。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在&lt;a href=&quot;https://jylzs369.github.io/2018/08/16/vue-implement-of-vnode/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;虚拟节点的实现&lt;/a&gt;一篇中，除了知道了 &lt;code&gt;VNode&lt;
      
    
    </summary>
    
    
      <category term="Dev" scheme="https://ushio-s.github.io/categories/Dev/"/>
    
      <category term="Explore Vue" scheme="https://ushio-s.github.io/categories/Dev/Explore-Vue/"/>
    
    
      <category term="Vue" scheme="https://ushio-s.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue源码探究-虚拟节点的实现</title>
    <link href="https://ushio-s.github.io/2018-08-16/vue-implement-of-vnode/"/>
    <id>https://ushio-s.github.io/2018-08-16/vue-implement-of-vnode/</id>
    <published>2018-08-16T08:53:22.000Z</published>
    <updated>2020-06-09T08:55:10.267Z</updated>
    
    <content type="html"><![CDATA[<p>页面初始化的所有状态都准备就绪之后，下一步就是要生成组件相应的虚拟节点—— <code>VNode</code>。初次进行组件初始化的时候，<code>VNode</code> 也会执行一次初始化并存储这时创建好的虚拟节点对象。在随后的生命周期中，组件内的数据发生变动时，会先生成新的 <code>VNode</code> 对象，然后再根据与之前存储的旧虚拟节点的对比来执行刷新页面 <code>DOM</code> 的操作。页面刷新的流程大致上可以这样简单的总结，但是其实现路程是非常复杂的，为了深入地了解虚拟节点生成和更新的过程，首先来看看 <code>VNode</code> 类的具体实现。</p><h2 id="VNode-类"><a href="#VNode-类" class="headerlink" title="VNode 类"></a>VNode 类</h2><p><code>VNode</code> 类的实现是支持页面渲染的基础，这个类的实现并不复杂，但无论是创建Vue组件实例还是使用动态JS扩展函数组件都运用到了渲染函数 <code>render</code>，它充分利用了 <code>VNode</code> 来构建虚拟DOM树。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义并导出VNode类</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 定义实例属性</span></span><br><span class="line">  tag: string | <span class="keyword">void</span>; <span class="comment">// 标签名称</span></span><br><span class="line">  data: VNodeData | <span class="keyword">void</span>; <span class="comment">// 节点数据</span></span><br><span class="line">  children: ?<span class="built_in">Array</span>&lt;VNode&gt;; <span class="comment">// 子虚拟节点列表</span></span><br><span class="line">  text: string | <span class="keyword">void</span>; <span class="comment">// 节点文字</span></span><br><span class="line">  elm: Node | <span class="keyword">void</span>; <span class="comment">// 对应DOM节点</span></span><br><span class="line">  ns: string | <span class="keyword">void</span>; <span class="comment">// 节点命名空间，针对svg标签的属性</span></span><br><span class="line">  context: Component | <span class="keyword">void</span>; <span class="comment">// rendered in this component's scope // 组件上下文</span></span><br><span class="line">  key: string | number | <span class="keyword">void</span>;  <span class="comment">// 节点唯一键</span></span><br><span class="line">  componentOptions: VNodeComponentOptions | <span class="keyword">void</span>; <span class="comment">// 虚拟节点组件配置对象</span></span><br><span class="line">  componentInstance: Component | <span class="keyword">void</span>; <span class="comment">// component instance // 组件实例</span></span><br><span class="line">  parent: VNode | <span class="keyword">void</span>; <span class="comment">// component placeholder node // 组件占位符节点</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 严格内部属性，有些属性是服务器渲染的情况使用的，暂时还不了解</span></span><br><span class="line">  <span class="comment">// strictly internal</span></span><br><span class="line">  <span class="comment">// 是否包含原始HTML。只有服务器端会使用</span></span><br><span class="line">  raw: boolean; <span class="comment">// contains raw HTML? (server only)</span></span><br><span class="line">  <span class="comment">// 是否静态节点，静态节点将会被提升</span></span><br><span class="line">  isStatic: boolean; <span class="comment">// hoisted static node</span></span><br><span class="line">  <span class="comment">// 是否在根节点插入，进入转换检查所必需的</span></span><br><span class="line">  isRootInsert: boolean; <span class="comment">// necessary for enter transition check</span></span><br><span class="line">  <span class="comment">// 是否空注释占位符</span></span><br><span class="line">  isComment: boolean; <span class="comment">// empty comment placeholder?</span></span><br><span class="line">  <span class="comment">// 是否拷贝节点</span></span><br><span class="line">  isCloned: boolean; <span class="comment">// is a cloned node?</span></span><br><span class="line">  <span class="comment">// 是否一次性节点</span></span><br><span class="line">  isOnce: boolean; <span class="comment">// is a v-once node?</span></span><br><span class="line">  <span class="comment">// 异步组件工厂方法</span></span><br><span class="line">  asyncFactory: <span class="built_in">Function</span> | <span class="keyword">void</span>; <span class="comment">// async component factory function</span></span><br><span class="line">  <span class="comment">// 异步源</span></span><br><span class="line">  asyncMeta: <span class="built_in">Object</span> | <span class="keyword">void</span>;</span><br><span class="line">  <span class="comment">// 是否异步占位符</span></span><br><span class="line">  isAsyncPlaceholder: boolean;</span><br><span class="line">  <span class="comment">// 服务器端上下文</span></span><br><span class="line">  ssrContext: <span class="built_in">Object</span> | <span class="keyword">void</span>;</span><br><span class="line">  <span class="comment">// 功能节点的实际实例上下文</span></span><br><span class="line">  fnContext: Component | <span class="keyword">void</span>; <span class="comment">// real context vm for functional nodes</span></span><br><span class="line">  <span class="comment">// 方法配置选项，只在服务器渲染使用</span></span><br><span class="line">  fnOptions: ?ComponentOptions; <span class="comment">// for SSR caching</span></span><br><span class="line">  <span class="comment">// 方法作用域id</span></span><br><span class="line">  fnScopeId: ?string; <span class="comment">// functional scope id support</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造函数，参数均可选，与上面定义对应</span></span><br><span class="line">  <span class="keyword">constructor</span> (</span><br><span class="line">    tag?: string,</span><br><span class="line">    data?: VNodeData,</span><br><span class="line">    children?: ?Array&lt;VNode&gt;,</span><br><span class="line">    text?: string,</span><br><span class="line">    elm?: Node,</span><br><span class="line">    context?: Component,</span><br><span class="line">    componentOptions?: VNodeComponentOptions,</span><br><span class="line">    asyncFactory?: Function</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// 实例初始化赋值</span></span><br><span class="line">    <span class="keyword">this</span>.tag = tag</span><br><span class="line">    <span class="keyword">this</span>.data = data</span><br><span class="line">    <span class="keyword">this</span>.children = children</span><br><span class="line">    <span class="keyword">this</span>.text = text</span><br><span class="line">    <span class="keyword">this</span>.elm = elm</span><br><span class="line">    <span class="keyword">this</span>.ns = <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">this</span>.context = context</span><br><span class="line">    <span class="keyword">this</span>.fnContext = <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">this</span>.fnOptions = <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">this</span>.fnScopeId = <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">this</span>.key = data &amp;&amp; data.key</span><br><span class="line">    <span class="keyword">this</span>.componentOptions = componentOptions</span><br><span class="line">    <span class="keyword">this</span>.componentInstance = <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">this</span>.parent = <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">this</span>.raw = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">this</span>.isStatic = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">this</span>.isRootInsert = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">this</span>.isComment = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">this</span>.isCloned = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">this</span>.isOnce = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">this</span>.asyncFactory = asyncFactory</span><br><span class="line">    <span class="keyword">this</span>.asyncMeta = <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">this</span>.isAsyncPlaceholder = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义child属性的取值器</span></span><br><span class="line">  <span class="comment">// 已弃用：用于向后compat的componentInstance的别名</span></span><br><span class="line">  <span class="comment">// DEPRECATED: alias for componentInstance for backwards compat.</span></span><br><span class="line">  <span class="comment">/* istanbul ignore next */</span></span><br><span class="line">  <span class="keyword">get</span> child (): Component | void &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.componentInstance</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义并导出createEmptyVNode函数，创建空虚拟节点</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createEmptyVNode = <span class="function">(<span class="params">text: string = <span class="string">''</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 实例化虚拟节点</span></span><br><span class="line">  <span class="keyword">const</span> node = <span class="keyword">new</span> VNode()</span><br><span class="line">  <span class="comment">// 设置节点文字为空，并设置为注释节点</span></span><br><span class="line">  node.text = text</span><br><span class="line">  node.isComment = <span class="literal">true</span></span><br><span class="line">  <span class="comment">// 返回节点</span></span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义并导出createTextVNode函数，创建文字虚拟节点</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createTextVNode</span> (<span class="params">val: string | number</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 置空实例初始化的标签名，数据，子节点属性，只传入文字</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> VNode(<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="built_in">String</span>(val))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化浅拷贝</span></span><br><span class="line"><span class="comment">// 用于静态节点和插槽节点，因为它们可以在多个渲染中重用，</span></span><br><span class="line"><span class="comment">// 当DOM操作依赖于它们的elm引用时，克隆它们可以避免错误</span></span><br><span class="line"><span class="comment">// optimized shallow clone</span></span><br><span class="line"><span class="comment">// used for static nodes and slot nodes because they may be reused across</span></span><br><span class="line"><span class="comment">// multiple renders, cloning them avoids errors when DOM manipulations rely</span></span><br><span class="line"><span class="comment">// on their elm reference.</span></span><br><span class="line"><span class="comment">// 定义并导出cloneVNode函数，拷贝节点</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">cloneVNode</span> (<span class="params">vnode: VNode</span>): <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 拷贝节点并返回</span></span><br><span class="line">  <span class="keyword">const</span> cloned = <span class="keyword">new</span> VNode(</span><br><span class="line">    vnode.tag,</span><br><span class="line">    vnode.data,</span><br><span class="line">    vnode.children,</span><br><span class="line">    vnode.text,</span><br><span class="line">    vnode.elm,</span><br><span class="line">    vnode.context,</span><br><span class="line">    vnode.componentOptions,</span><br><span class="line">    vnode.asyncFactory</span><br><span class="line">  )</span><br><span class="line">  cloned.ns = vnode.ns</span><br><span class="line">  cloned.isStatic = vnode.isStatic</span><br><span class="line">  cloned.key = vnode.key</span><br><span class="line">  cloned.isComment = vnode.isComment</span><br><span class="line">  cloned.fnContext = vnode.fnContext</span><br><span class="line">  cloned.fnOptions = vnode.fnOptions</span><br><span class="line">  cloned.fnScopeId = vnode.fnScopeId</span><br><span class="line">  cloned.asyncMeta = vnode.asyncMeta</span><br><span class="line">  cloned.isCloned = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">return</span> cloned</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>VNode</code> 类实现的源代码分两部分，第一部分是定义 <code>VNode</code> 类自身的实现，第二部分是定一些常用的节点创建方法，包括创建空的虚拟节点，文字虚拟节点和新拷贝节点。虚拟节点本身是一个包含了所有渲染所需信息的载体，从前面一部分的属性就可以看出，不仅有相应的 <code>DOM</code> 标签和属性信息，还包含了子虚拟节点列表，所以一个组件初始化之后得到的 <code>VNode</code> 也是一棵虚拟节点树，实质是抽象和信息化了的对应于 <code>DOM</code> 树的 <code>JS</code> 对象。</p><p><code>VNode</code> 的使用在服务器渲染中也有应用，关于这一部分暂时放到之后去研究。</p><p>认识到 <code>VNode</code> 的实质之后，对于它的基础性的作用还是不太清楚，为什么需要创建这种对象来呢？答案就在Vue的响应式刷新里。如前所述，观察系统实现了对数据变更的监视，在收到变更的通知之后处理权就移交到渲染系统手上，渲染系统首先进行的处理就是根据变动生成新虚拟节点树，然后再去对比旧的虚拟节点树，来实现这个抽象对象的更新，简单的来说就是通过新旧两个节点树的对照，来最终确定一个真实DOM建立起来所需要依赖的抽象对象，只要这个真实 <code>DOM</code> 所依赖的对象确定好，渲染函数会把它转化成真实的 <code>DOM</code> 树。</p><p>最后来概括地描述一下 <code>VNode</code> 渲染成真实 <code>DOM</code> 的路径：</p><h2 id="渲染路径"><a href="#渲染路径" class="headerlink" title="渲染路径"></a>渲染路径</h2><p><code>Vue</code> 的一般渲染有两条路径：</p><ul><li>组件实例初始创建生成DOM</li><li>组件数据更新刷新DOM</li></ul><p>在研究生命周期的时候知道，有 <code>mount</code> 和 <code>update</code> 两个钩子函数，这两个生命周期的过程分别代表了两条渲染路径的执行。</p><h3 id="组件实例初始创建生成DOM"><a href="#组件实例初始创建生成DOM" class="headerlink" title="组件实例初始创建生成DOM"></a>组件实例初始创建生成DOM</h3><p><code>Vue</code> 组件实例初始创建时，走的是 <code>mount</code> 这条路径，在这条路径上初始没有已暂存的旧虚拟节点，要经历第一轮 <code>VNode</code> 的生成。这一段代码的执行是从 <code>$mount</code> 函数开始的：</p><blockquote><p><strong><code>$mount =&gt; mountComponent =&gt; updateComponent =&gt; _render =&gt; _update =&gt; createPatchFunction(patch) =&gt; createElm =&gt; insert =&gt; removeVnodes</code></strong></p></blockquote><p>大致描述一下每一个流程中所进行的关于节点的处理：</p><ul><li><code>mountComponent</code> 接收了挂载的真实DOM节点，然后赋值给 <code>vm.$el</code></li><li><code>updateComponent</code> 调用 <code>_update</code>，并传入 <code>_render</code> 生成的新节点</li><li><code>_render</code> 生成新虚拟节点树，它内部是调用实例的 <code>createElement</code> 方法创建虚拟节点</li><li><code>_update</code> 方法接收到新的虚拟节点后，会根据是否已有存储的旧虚拟节点来分离执行路径，就这一个路径来说，初始储存的 <code>VNode</code> 是不存在的，接下来执行 <code>patch</code> 操作会传入挂载的真实DOM节点和新生成的虚拟节点。</li><li><code>createPatchFunction</code> 即是 <code>patch</code> 方法调用的实际函数，执行时会将传入的真实DOM节点转换成虚拟节点，然后执行 <code>createElm</code></li><li><code>createElm</code> 会根据新的虚拟节点生成真实DOM节点，内部同样调用 <code>createElement</code> 方法来创建节点。</li><li><code>insert</code> 方法将生成的真实DOM插入到DOM树中</li><li><code>removeVnodes</code> 最后将之前转换的真实DOM节点从DOM树中移除</li></ul><p>以上就是一般初始化Vue实例组件时渲染的路径，在这个过程中，初始 <code>VNode</code> 虽然不存在，但是由于挂在的真实 <code>DOM</code> 节点一定存在，所以代码会按照这样的流程来执行。</p><h3 id="组件数据更新刷新DOM"><a href="#组件数据更新刷新DOM" class="headerlink" title="组件数据更新刷新DOM"></a>组件数据更新刷新DOM</h3><p>一般情况下，数据变成会通知 <code>Watcher</code> 实例调用 <code>update</code> 方法，这个方法在一般情况下会把待渲染的数据观察对象加入到事件任务队列中，避免开销过高在一次处理中集中执行。所以在 <code>mount</code> 路径已经完成了之后，生命周期运行期间都是走的 <code>update</code> 路径，在每一次的事件处理中 <code>nextTick</code> 会调用 <code>flushSchedulerQueue</code> 来开始一轮页面刷新：</p><blockquote><p><strong><code>flushSchedulerQueue =&gt; watcher.run =&gt; watcher.getAndInvoke =&gt; watcher.get  =&gt; updateComponent =&gt; _render =&gt; _update =&gt; createPatchFunction(patch) =&gt; patchVnode =&gt; updateChildren</code></strong></p></blockquote><p>在这个流程中各个方法的大致处理如下：</p><ul><li><code>flushSchedulerQueue</code> 调用每一个变更了的数据的监视器的 <code>run</code> 方法</li><li><code>run</code> 执行调用实例的 <code>getAndInvoke</code> 方法，目的是获取新数据并调用监视器的回调函数</li><li><code>getAndInvoke</code> 执行的第一步是要获取变更后的新数据，在这时会调用取值器函数</li><li><code>get</code> 执行的取值器函数getter被设定为 <code>updateComponent</code>，所以会执行继续执行它</li><li><code>updateComponent</code> =&gt; <code>createPatchFunction</code> 之间的流程与另一条路径相同，只是其中基于新旧虚拟节点的判断不一样，如果存在旧虚拟节点就执行 <code>patchVnode</code> 操作。</li><li><code>patchVnode</code> 方法是实际更新节点的实现，在这个函数的执行中，会得到最终的真实DOM</li></ul><p>生命周期中的渲染主要是以上两条路径，调用的入口不同，但中间有一部分逻辑是公用的，再根据判断来选择分离的路程来更新 <code>VNode</code> 和刷新节点。在这个过程可以看出 <code>VNode</code> 的重要作用。</p><p>虽然路径大致可以这样总结，但其中的实现比较复杂。不仅在流程判断上非常有跳跃性，实现更新真实节点树的操作也都是复杂递归的调用。</p><hr><p>总的来说虚拟节点的实现是非常平易近人，但是在节点渲染的过程中却被运用的十分复杂，段位不够高看了很多遍测试了很多遍才弄清楚整个执行流，这之外还有关于服务器端渲染和持久活跃组件的部分暂时都忽略了。不过关于节点渲染这一部分的实现逻辑非常值得去好好研究。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;页面初始化的所有状态都准备就绪之后，下一步就是要生成组件相应的虚拟节点—— &lt;code&gt;VNode&lt;/code&gt;。初次进行组件初始化的时候，&lt;code&gt;VNode&lt;/code&gt; 也会执行一次初始化并存储这时创建好的虚拟节点对象。在随后的生命周期中，组件内的数据发生变动时，会
      
    
    </summary>
    
    
      <category term="Dev" scheme="https://ushio-s.github.io/categories/Dev/"/>
    
      <category term="Explore Vue" scheme="https://ushio-s.github.io/categories/Dev/Explore-Vue/"/>
    
    
      <category term="Vue" scheme="https://ushio-s.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue源码探究-状态初始化</title>
    <link href="https://ushio-s.github.io/2018-08-10/vue-initial-of-states/"/>
    <id>https://ushio-s.github.io/2018-08-10/vue-initial-of-states/</id>
    <published>2018-08-10T06:23:31.000Z</published>
    <updated>2020-06-09T08:55:07.483Z</updated>
    
    <content type="html"><![CDATA[<p><em>本篇代码位于<a href="https://github.com/vuejs/vue/blob/v2.5.17-beta.0/src/core/instance/state.js" target="_blank" rel="noopener">vue/src/core/instance/state.js</a></em></p><p>继续随着核心类的初始化展开探索其他的模块，这一篇来研究一下Vue的状态初始化。这里的状态初始化指的就是在创建实例的时候，在配置对象里定义的属性、数据变量、方法等是如何进行初始处理的。由于随后的数据更新变动都交给观察系统来负责，所以在事先弄明白了数据绑定的原理之后，就只需要将目光集中在这一部分。</p><p>来仔细看看在核心类中首先执行的关于 <code>state</code> 部分的源码：</p><h2 id="initState"><a href="#initState" class="headerlink" title="initState"></a>initState</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义并导出initState函数，接收参数vm</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initState</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化实例的私有属性_watchers</span></span><br><span class="line">  <span class="comment">// 这就是在观察系统里会使用到的存储所有显式监视器的对象</span></span><br><span class="line">  vm._watchers = []</span><br><span class="line">  <span class="comment">// 获取实例的配置对象</span></span><br><span class="line">  <span class="keyword">const</span> opts = vm.$options</span><br><span class="line">  <span class="comment">// 如果定义了props，则初始化props</span></span><br><span class="line">  <span class="keyword">if</span> (opts.props) initProps(vm, opts.props)</span><br><span class="line">  <span class="comment">// 如果定义了methods，则初始化methods</span></span><br><span class="line">  <span class="keyword">if</span> (opts.methods) initMethods(vm, opts.methods)</span><br><span class="line">  <span class="comment">// 如果定义了data，则初始化data</span></span><br><span class="line">  <span class="keyword">if</span> (opts.data) &#123;</span><br><span class="line">    initData(vm)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 否则初始化实例的私有属性_data为空对象，并开启观察</span></span><br><span class="line">    observe(vm._data = &#123;&#125;, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果定义了computed，则初始化计算属性</span></span><br><span class="line">  <span class="keyword">if</span> (opts.computed) initComputed(vm, opts.computed)</span><br><span class="line">  <span class="comment">// 如果定义了watch并且不是nativeWatch，则初始化watch</span></span><br><span class="line">  <span class="comment">// nativeWatch是火狐浏览器下定义的对象的原型方法</span></span><br><span class="line">  <span class="keyword">if</span> (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</span><br><span class="line">    initWatch(vm, opts.watch)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码非常直白，主要用来执行配置对象里定义的了状态的初始化。这里分别有 <code>props</code>、<code>data</code>、<code>methods</code>、<code>computed</code>、<code>watch</code> 五个配置对象，分别有各自的初始化方法。在仔细研究它们的具体实现之前，先来看一段将在各个初始化函数里用到的辅助函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义共享属性定义描述符对象sharedPropertyDefinition</span></span><br><span class="line"><span class="comment">// 描述符对象的枚举和可配置属性都设置为true</span></span><br><span class="line"><span class="comment">// get、set方法设置为空函数</span></span><br><span class="line"><span class="keyword">const</span> sharedPropertyDefinition = &#123;</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  <span class="keyword">get</span>: noop,</span><br><span class="line">  <span class="keyword">set</span>: noop</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义并导出proxy函数，该函数用来为在目标对象上定义并代理属性</span><br><span class="line">// 接收目标对象target，路径键名sourceKey，属性键名三个参数</span><br><span class="line">export function proxy (target: Object, sourceKey: string, key: string) &#123;</span><br><span class="line">  <span class="comment">// 设置属性描述符对象的get方法</span></span><br><span class="line">  sharedPropertyDefinition.get = <span class="function"><span class="keyword">function</span> <span class="title">proxyGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[sourceKey][key]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置属性描述性对象的set犯法</span></span><br><span class="line">  sharedPropertyDefinition.set = <span class="function"><span class="keyword">function</span> <span class="title">proxySetter</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>[sourceKey][key] = val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在目标对象上定义属性</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, key, sharedPropertyDefinition)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>proxy</code> 函数的定义非常重要，在下面要探究的各个初始化函数中它，它会将我们在配置对象中设置的属性全部定义到实例对象中，但是我们对这些属性的操作是通过各部分相应的代理属性上来执行的。<code>get</code> 和 <code>set</code> 方法的实现非常明白的表示出这一过程，然后再将属性定义到实例中。由这个函数作为基础，继续来看看其他五个状态的初始化函数的内容。</p><h3 id="initProps"><a href="#initProps" class="headerlink" title="initProps"></a>initProps</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义initProps函数，接收vm，propsOptions两个参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initProps</span> (<span class="params">vm: Component, propsOptions: Object</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 赋值propsData，propsData是全局扩展传入的赋值对象</span></span><br><span class="line">  <span class="comment">// 在使用extend的时候会用到，实际开发里运用较少</span></span><br><span class="line">  <span class="keyword">const</span> propsData = vm.$options.propsData || &#123;&#125;</span><br><span class="line">  <span class="comment">// 定义实例的_props私有属性，并赋值给props</span></span><br><span class="line">  <span class="keyword">const</span> props = vm._props = &#123;&#125;</span><br><span class="line">  <span class="comment">// 缓存prop键，以便将来props更新可以使用Array而不是动态对象键枚举进行迭代。</span></span><br><span class="line">  <span class="comment">// cache prop keys so that future props updates can iterate using Array</span></span><br><span class="line">  <span class="comment">// instead of dynamic object key enumeration.</span></span><br><span class="line">  <span class="keyword">const</span> keys = vm.$options._propKeys = []</span><br><span class="line">  <span class="comment">// 是否是根实例</span></span><br><span class="line">  <span class="keyword">const</span> isRoot = !vm.$parent</span><br><span class="line">  <span class="comment">// 对于非根实例，关闭观察标识</span></span><br><span class="line">  <span class="comment">// root instance props should be converted</span></span><br><span class="line">  <span class="keyword">if</span> (!isRoot) &#123;</span><br><span class="line">    toggleObserving(<span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遍历props配置对象</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> propsOptions) &#123;</span><br><span class="line">    <span class="comment">// 向缓存键值数组中添加键名</span></span><br><span class="line">    keys.push(key)</span><br><span class="line">    <span class="comment">// 验证prop的值，validateProp执行对初始化定义的props的类型检查和默认赋值</span></span><br><span class="line">    <span class="comment">// 如果有定义类型检查，布尔值没有默认值时会被赋予false，字符串默认undefined</span></span><br><span class="line">    <span class="comment">// 对propsOptions的比较也是在使用extend扩展时才有意义</span></span><br><span class="line">    <span class="comment">// 具体实现可以参考 src/core/util/props.js，没有难点这里不详细解释</span></span><br><span class="line">    <span class="keyword">const</span> value = validateProp(key, propsOptions, propsData, vm)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非生产环境下进行检查和提示</span></span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="comment">// 进行键名的转换，将驼峰式转换成连字符式的键名</span></span><br><span class="line">      <span class="keyword">const</span> hyphenatedKey = hyphenate(key)</span><br><span class="line">      <span class="comment">// 对与保留变量名冲突的键名给予提示</span></span><br><span class="line">      <span class="keyword">if</span> (isReservedAttribute(hyphenatedKey) ||</span><br><span class="line">          config.isReservedAttr(hyphenatedKey)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`"<span class="subst">$&#123;hyphenatedKey&#125;</span>" is a reserved attribute and cannot be used as component prop.`</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 对属性建立观察，并在直接使用属性时给予警告</span></span><br><span class="line">      defineReactive(props, key, value, () =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (vm.$parent &amp;&amp; !isUpdatingChildComponent) &#123;</span><br><span class="line">          warn(</span><br><span class="line">            <span class="string">`Avoid mutating a prop directly since the value will be `</span> +</span><br><span class="line">            <span class="string">`overwritten whenever the parent component re-renders. `</span> +</span><br><span class="line">            <span class="string">`Instead, use a data or computed property based on the prop's `</span> +</span><br><span class="line">            <span class="string">`value. Prop being mutated: "<span class="subst">$&#123;key&#125;</span>"`</span>,</span><br><span class="line">            vm</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 非生产环境下直接对属性进行存取器包装，建立依赖观察</span></span><br><span class="line">      defineReactive(props, key, value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用Vue.extend()方法扩展属性时，已经对静态属性进行了代理</span></span><br><span class="line">    <span class="comment">// 这里只需要针对实例化时的属性执行代理操作</span></span><br><span class="line">    <span class="comment">// static props are already proxied on the component's prototype</span></span><br><span class="line">    <span class="comment">// during Vue.extend(). We only need to proxy props defined at</span></span><br><span class="line">    <span class="comment">// instantiation here.</span></span><br><span class="line">    <span class="comment">// 当实例上没有同名属性时，对属性进行代理操作</span></span><br><span class="line">    <span class="comment">// 将对键名的引用指向vm._props对象中</span></span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">      proxy(vm, <span class="string">`_props`</span>, key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 开启观察状态标识</span></span><br><span class="line">  toggleObserving(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>initProps</code> 函数的最主要内容有两点，一是对定义的数据建立观察，二是对数据进行代理，这就是私有变量 <code>_props</code> 的作用，之后获取和设置的变量都是作为 <code>_props</code> 的属性被操作。</p><p>另外初始化 <code>props</code> 的过程中有针对 <code>extend</code> 方法会使用到的 <code>propsData</code> 属性的初始化。具体使用是在扩展对象时定义一些 props，然后在创建实例的过程中传入  propsData 配置对象，扩展对象里相应的props属性会接收 propsData 传入的值。与在父组件传入 props 的值类似，只是这里要显式的通过 <code>propsData</code> 配置对象来传入值。</p><h3 id="initData"><a href="#initData" class="headerlink" title="initData"></a>initData</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义initData函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initData</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取配置对象的data属性</span></span><br><span class="line">  <span class="keyword">let</span> data = vm.$options.data</span><br><span class="line">  <span class="comment">// 判断data是否是函数</span></span><br><span class="line">  <span class="comment">// 若是函数则将getData函数的返回赋值给data和实例私有属性_data</span></span><br><span class="line">  <span class="comment">// 否则直接将data赋值给实例_data属性，并在无data时赋值空对象</span></span><br><span class="line">  data = vm._data = <span class="keyword">typeof</span> data === <span class="string">'function'</span></span><br><span class="line">    ? getData(data, vm)</span><br><span class="line">    : data || &#123;&#125;</span><br><span class="line">  <span class="comment">// 如果data不是对象则将data赋值为空对象</span></span><br><span class="line">  <span class="comment">// 进一步保证data是对象类型</span></span><br><span class="line">  <span class="keyword">if</span> (!isPlainObject(data)) &#123;</span><br><span class="line">    data = &#123;&#125;</span><br><span class="line">    <span class="comment">// 在非生产环境下给出警告提示</span></span><br><span class="line">    process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">      <span class="string">'data functions should return an object:\n'</span> +</span><br><span class="line">      <span class="string">'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function'</span>,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 实例对象代理data</span></span><br><span class="line">  <span class="comment">// proxy data on instance</span></span><br><span class="line">  <span class="comment">// 获取所有data键值</span></span><br><span class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(data)</span><br><span class="line">  <span class="comment">// 获取配置对象的props</span></span><br><span class="line">  <span class="keyword">const</span> props = vm.$options.props</span><br><span class="line">  <span class="comment">// 获取配置对象的methods</span></span><br><span class="line">  <span class="keyword">const</span> methods = vm.$options.methods</span><br><span class="line">  <span class="comment">// 遍历keys</span></span><br><span class="line">  <span class="keyword">let</span> i = keys.length</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = keys[i]</span><br><span class="line">    <span class="comment">// 非生产环境给出与methods定义的方法名冲突的警告</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (methods &amp;&amp; hasOwn(methods, key)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`Method "<span class="subst">$&#123;key&#125;</span>" has already been defined as a data property.`</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检测是否与props冲突</span></span><br><span class="line">    <span class="keyword">if</span> (props &amp;&amp; hasOwn(props, key)) &#123;</span><br><span class="line">      <span class="comment">// 非生产环境给出冲突警告</span></span><br><span class="line">      process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">        <span class="string">`The data property "<span class="subst">$&#123;key&#125;</span>" is already declared as a prop. `</span> +</span><br><span class="line">        <span class="string">`Use prop default value instead.`</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    <span class="comment">// 没有与props冲突并且非保留字时，代理键名到实例的_data对象上</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isReserved(key)) &#123;</span><br><span class="line">      proxy(vm, <span class="string">`_data`</span>, key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 观察数据</span></span><br><span class="line">  <span class="comment">// observe data</span></span><br><span class="line">  observe(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义并导出getData函数，接受函数类型的data对象，和Vue实例对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getData</span> (<span class="params">data: Function, vm: Component</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="comment">// pushTarget和popTarget是为了解决Vue依赖性检测的缺陷可能导致冗余依赖性的问题</span></span><br><span class="line">  <span class="comment">// 具体可参阅 https://github.com/vuejs/vue/issues/7573</span></span><br><span class="line">  <span class="comment">// 此操作会设置Dep.target为undefined，在初始化option时调用dep.depend()也不会建立依赖</span></span><br><span class="line">  <span class="comment">// #7573 调用数据getter时禁用dep集合</span></span><br><span class="line">  <span class="comment">// #7573 disable dep collection when invoking data getters</span></span><br><span class="line">  pushTarget()</span><br><span class="line">  <span class="comment">// 尝试在vm上调用data函数并返回执行结果</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> data.call(vm, vm)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// 如果捕获到错误则处理错误，并返回空对象</span></span><br><span class="line">    handleError(e, vm, <span class="string">`data()`</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    popTarget()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与 props 的处理类似，<code>initData</code> 函数的作用也是为了对数据建立观察的依赖关系，并且代理数据到私有变量 <code>_data</code> 上，另外包括了对 data 与其他配置对象属性的键名冲突的检测。</p><h3 id="initComputed"><a href="#initComputed" class="headerlink" title="initComputed"></a>initComputed</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置computedWatcherOptions对象</span></span><br><span class="line"><span class="keyword">const</span> computedWatcherOptions = &#123; <span class="attr">computed</span>: <span class="literal">true</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义initComputed函数，接受实例vm，和computed对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initComputed</span> (<span class="params">vm: Component, computed: Object</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="comment">// 定义watchers和实例_computedWatchers属性，初始赋值空对象</span></span><br><span class="line">  <span class="keyword">const</span> watchers = vm._computedWatchers = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  <span class="comment">// 是否是服务器渲染，computed属性在服务器渲染期间只能是getter</span></span><br><span class="line">  <span class="comment">// computed properties are just getters during SSR</span></span><br><span class="line">  <span class="keyword">const</span> isSSR = isServerRendering()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历computed</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> computed) &#123;</span><br><span class="line">    <span class="comment">// 获取用户定义的值</span></span><br><span class="line">    <span class="keyword">const</span> userDef = computed[key]</span><br><span class="line">    <span class="comment">// 如果用户定义的是函数则赋值给getter否则j将userDef.get方法赋值给getter</span></span><br><span class="line">    <span class="keyword">const</span> getter = <span class="keyword">typeof</span> userDef === <span class="string">'function'</span> ? userDef : userDef.get</span><br><span class="line">    <span class="comment">// 非生产环境抛出缺少计算属性错误警告</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; getter == <span class="literal">null</span>) &#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">`Getter is missing for computed property "<span class="subst">$&#123;key&#125;</span>".`</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非服务器渲染下</span></span><br><span class="line">    <span class="keyword">if</span> (!isSSR) &#123;</span><br><span class="line">      <span class="comment">// 为计算属性创建内部监视器</span></span><br><span class="line">      <span class="comment">// create internal watcher for the computed property.</span></span><br><span class="line">      watchers[key] = <span class="keyword">new</span> Watcher(</span><br><span class="line">        vm,</span><br><span class="line">        getter || noop,</span><br><span class="line">        noop,</span><br><span class="line">        computedWatcherOptions</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组件定义的内部计算属性已经在组件的原型上定义好了</span></span><br><span class="line">    <span class="comment">// 所以这里只要关注实例初始化时用户定义的计算属性</span></span><br><span class="line">    <span class="comment">// component-defined computed properties are already defined on the</span></span><br><span class="line">    <span class="comment">// component prototype. We only need to define computed properties defined</span></span><br><span class="line">    <span class="comment">// at instantiation here.</span></span><br><span class="line">    <span class="comment">// 键名非实例根属性时，定义计算属性，具体参照defineComputed函数</span></span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">      defineComputed(vm, key, userDef)</span><br><span class="line">    <span class="comment">// 非生产环境下，检测与data属性名的冲突并给出警告</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (key <span class="keyword">in</span> vm.$data) &#123;</span><br><span class="line">        warn(<span class="string">`The computed property "<span class="subst">$&#123;key&#125;</span>" is already defined in data.`</span>, vm)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vm.$options.props &amp;&amp; key <span class="keyword">in</span> vm.$options.props) &#123;</span><br><span class="line">        warn(<span class="string">`The computed property "<span class="subst">$&#123;key&#125;</span>" is already defined as a prop.`</span>, vm)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义并导出defineComputed哈数</span></span><br><span class="line"><span class="comment">// 接收实例target，计算属性键名key，计算属性值userDef参数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineComputed</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  target: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  userDef: Object | Function</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在非服务器渲染下设置缓存</span></span><br><span class="line">  <span class="keyword">const</span> shouldCache = !isServerRendering()</span><br><span class="line">  <span class="comment">// 计算属性值是函数时</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> userDef === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="comment">// 设置计算属性的getter，setter为空函数</span></span><br><span class="line">    sharedPropertyDefinition.get = shouldCache</span><br><span class="line">      ? createComputedGetter(key)</span><br><span class="line">      : userDef</span><br><span class="line">    sharedPropertyDefinition.set = noop</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 当计算属性是对象时，设置计算属性的getter和setter</span></span><br><span class="line">    sharedPropertyDefinition.get = userDef.get</span><br><span class="line">      ? shouldCache &amp;&amp; userDef.cache !== <span class="literal">false</span></span><br><span class="line">        ? createComputedGetter(key)</span><br><span class="line">        : userDef.get</span><br><span class="line">      : noop</span><br><span class="line">    sharedPropertyDefinition.set = userDef.set</span><br><span class="line">      ? userDef.set</span><br><span class="line">      : noop</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 非生产环境下，如果没哟定义计算属性的setter</span></span><br><span class="line">  <span class="comment">// 想设置计算属性时给出警告</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">      sharedPropertyDefinition.set === noop) &#123;</span><br><span class="line">    sharedPropertyDefinition.set = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">`Computed property "<span class="subst">$&#123;key&#125;</span>" was assigned to but it has no setter.`</span>,</span><br><span class="line">        <span class="keyword">this</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 以重新设置的属性描述符为基础在实例对象上定义计算属性</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, key, sharedPropertyDefinition)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义createComputedGetter，创建计算属性getter</span></span><br><span class="line"><span class="comment">// 目的是在非服务器渲染情况下建立计算属性的观察依赖，</span></span><br><span class="line"><span class="comment">// 并根据其依赖属性返回计算后的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComputedGetter</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">computedGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> watcher = <span class="keyword">this</span>._computedWatchers &amp;&amp; <span class="keyword">this</span>._computedWatchers[key]</span><br><span class="line">    <span class="keyword">if</span> (watcher) &#123;</span><br><span class="line">      watcher.depend()</span><br><span class="line">      <span class="keyword">return</span> watcher.evaluate()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算属性的初始化相对复杂一些，首先要对计算属性建立观察，然后再在实例上重新定义计算属性，并且执行属性代理。由于加入了服务器渲染的功能，在定义计算属性的时候对使用环境做判断，是非服务器渲染会影响到计算属性的定义，这是由于服务器渲染下使用框架时，计算属性是不提供 setter 的；另外也要根据用户定义的值是函数或者对象来对计算属性重新定义 getter 和 setter。从这段代码里可以看出一个非常重要的程序，即在获取计算属性的时候才去计算它的值，这正是懒加载的实现。</p><h3 id="initMethods"><a href="#initMethods" class="headerlink" title="initMethods"></a>initMethods</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义initMethods方法，接受实例vm，配置属性methods</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initMethods</span> (<span class="params">vm: Component, methods: Object</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取实例的props</span></span><br><span class="line">  <span class="keyword">const</span> props = vm.$options.props</span><br><span class="line">  <span class="comment">// 遍历methods对象</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> methods) &#123;</span><br><span class="line">    <span class="comment">// 非生产环境下给出警告</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="comment">// 未赋值方法警告</span></span><br><span class="line">      <span class="keyword">if</span> (methods[key] == <span class="literal">null</span>) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`Method "<span class="subst">$&#123;key&#125;</span>" has an undefined value in the component definition. `</span> +</span><br><span class="line">          <span class="string">`Did you reference the function correctly?`</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 与props属性名冲突警告</span></span><br><span class="line">      <span class="keyword">if</span> (props &amp;&amp; hasOwn(props, key)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`Method "<span class="subst">$&#123;key&#125;</span>" has already been defined as a prop.`</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 与保留字冲突警告</span></span><br><span class="line">      <span class="keyword">if</span> ((key <span class="keyword">in</span> vm) &amp;&amp; isReserved(key)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`Method "<span class="subst">$&#123;key&#125;</span>" conflicts with an existing Vue instance method. `</span> +</span><br><span class="line">          <span class="string">`Avoid defining component methods that start with _ or $.`</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在实例上定义方法，赋值为用户未定义函数或空函数</span></span><br><span class="line">    vm[key] = methods[key] == <span class="literal">null</span> ? noop : bind(methods[key], vm)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>initMethods</code> 函数非常简单，除了一大段在非生产环境里报告检查冲突的代码，唯一的内容就是在实例上定义相应的方法并且把上下文绑定到实例对象上，这样即便不是使用箭头函数，在方法内也默认用 this 指代了实例对象。</p><h3 id="initWatch"><a href="#initWatch" class="headerlink" title="initWatch"></a>initWatch</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义initWatch函数，接受实例vm和配置属性watch</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initWatch</span> (<span class="params">vm: Component, watch: Object</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 遍历watch</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> watch) &#123;</span><br><span class="line">    <span class="comment">// 暂存属性的值</span></span><br><span class="line">    <span class="keyword">const</span> handler = watch[key]</span><br><span class="line">    <span class="comment">// 如果handler是数组</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(handler)) &#123;</span><br><span class="line">      <span class="comment">// 遍历数组为每一个元素创建相应watcher</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; handler.length; i++) &#123;</span><br><span class="line">        createWatcher(vm, key, handler[i])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 窦否则handler应该是函数，直接为key创建watcher</span></span><br><span class="line">      createWatcher(vm, key, handler)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义createWatcher函数</span></span><br><span class="line"><span class="comment">// 接受实例vm、表达式或函数expOrFn，处理器handler，可选的options</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWatcher</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vm: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  expOrFn: string | Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  handler: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  options?: Object</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果handler是对象</span></span><br><span class="line">  <span class="keyword">if</span> (isPlainObject(handler)) &#123;</span><br><span class="line">    <span class="comment">// 将handler赋值给options.</span></span><br><span class="line">    options = handler</span><br><span class="line">    <span class="comment">// 重新赋值handler</span></span><br><span class="line">    handler = handler.handler</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果handler是字符串，在实例上寻找handler并赋值给handler</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> handler === <span class="string">'string'</span>) &#123;</span><br><span class="line">    handler = vm[handler]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建观察并返回</span></span><br><span class="line">  <span class="keyword">return</span> vm.$watch(expOrFn, handler, options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>initWatcher</code> 为传入的观察对象创建监视器，比较简单。值得注意的是参数的传入类型，观察对象 <code>expOrFn</code> 可以有两种方式，一种是字符串，一种是函数，在 <code>Watcher</code> 类中对此参数进行了检测，而在初始化的函数里不对它做任何处理。<code>handler</code> 对象也可以接受对象或字符串类型，在代码中对这两种传入方式做判断，最终找到handler引用的函数传入 <code>$watch</code>。</p><h2 id="stateMixin"><a href="#stateMixin" class="headerlink" title="stateMixin"></a>stateMixin</h2><p>探索完了 <code>initState</code> 函数之后，继续来看看 <code>state</code> 混入的方法 <code>stateMixin</code>，在这个函数里会提供上面还未曾提到的 <code>$watch</code> 方法的具体实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义并导出stateMixin函数，接收参数Vue</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">stateMixin</span> (<span class="params">Vue: Class&lt;Component&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 使用 Object.defineProperty 方法直接声明定义对象时，flow会发生问题</span></span><br><span class="line">  <span class="comment">// 所以必须在此程序化定义对象</span></span><br><span class="line">  <span class="comment">// flow somehow has problems with directly declared definition object</span></span><br><span class="line">  <span class="comment">// when using Object.defineProperty, so we have to procedurally build up</span></span><br><span class="line">  <span class="comment">// the object here.</span></span><br><span class="line">  <span class="comment">// 定义dataDef对象</span></span><br><span class="line">  <span class="keyword">const</span> dataDef = &#123;&#125;</span><br><span class="line">  <span class="comment">// 定义dataDef的get方法，返回Vue实例私有属性_data</span></span><br><span class="line">  dataDef.get = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>._data &#125;</span><br><span class="line">  <span class="comment">// 定义propsDef对象</span></span><br><span class="line">  <span class="keyword">const</span> propsDef = &#123;&#125;</span><br><span class="line">  <span class="comment">// 定义propsDef的get方法，返回Vue实例私有属性_props</span></span><br><span class="line">  propsDef.get = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>._props &#125;</span><br><span class="line">  <span class="comment">// 非生产环境下，定义dataDef和propsDef的set方法</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    <span class="comment">// dataDef的set方法接收Object类型的newData形参</span></span><br><span class="line">    dataDef.set = <span class="function"><span class="keyword">function</span> (<span class="params">newData: Object</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 提示避免传入对象覆盖属性$data</span></span><br><span class="line">      <span class="comment">// 推荐使用嵌套的数据属性代替</span></span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">'Avoid replacing instance root $data. '</span> +</span><br><span class="line">        <span class="string">'Use nested data properties instead.'</span>,</span><br><span class="line">        <span class="keyword">this</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置propsDef的set方法为只读</span></span><br><span class="line">    propsDef.set = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      warn(<span class="string">`$props is readonly.`</span>, <span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定义Vue原型对象公共属性$data，并赋值为dataDef</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">'$data'</span>, dataDef)</span><br><span class="line">  <span class="comment">// 定义Vue原型对象公共属性$props，并赋值为propsDef</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">'$props'</span>, propsDef)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义Vue原型对象的$set方法，并赋值为从观察者导入的set函数</span></span><br><span class="line">  Vue.prototype.$<span class="keyword">set</span> = <span class="keyword">set</span></span><br><span class="line">  // 定义Vue原型对象的$delete方法，并赋值为从观察者导入的del函数</span><br><span class="line">  Vue.prototype.$delete = del</span><br><span class="line"></span><br><span class="line">  // 定义Vue原型对象的$watch方法</span><br><span class="line">  // 接收字符串或函数类型的expOrFn，从命名中可看出希望为表达式或函数</span><br><span class="line">  // 接收任何类型的cb，这里希望为回调函数或者是一个对象</span><br><span class="line">  // 接收对象类型的options</span><br><span class="line">  // 要求返回函数类型</span><br><span class="line">  Vue.prototype.$watch = function (</span><br><span class="line">    expOrFn: string | Function,</span><br><span class="line">    cb: any,</span><br><span class="line">    options?: Object</span><br><span class="line">  ): Function &#123;</span><br><span class="line">    <span class="comment">// 把实例赋值给vm变量，类型需为Component</span></span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// 如果cb是纯粹的对象类型</span></span><br><span class="line">    <span class="keyword">if</span> (isPlainObject(cb)) &#123;</span><br><span class="line">      <span class="comment">// 返回createWatcher函数</span></span><br><span class="line">      <span class="keyword">return</span> createWatcher(vm, expOrFn, cb, options)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义观察目标的options，大多数情况下为undefined</span></span><br><span class="line">    options = options || &#123;&#125;</span><br><span class="line">    <span class="comment">// 定义options的user属性值为true，标识为用户定义</span></span><br><span class="line">    options.user = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 创建watcher实例</span></span><br><span class="line">    <span class="keyword">const</span> watcher = <span class="keyword">new</span> Watcher(vm, expOrFn, cb, options)</span><br><span class="line">    <span class="comment">// 如果options的immediate为真</span></span><br><span class="line">    <span class="keyword">if</span> (options.immediate) &#123;</span><br><span class="line">      <span class="comment">// 在vm上调用cb回调函数，并传入watcher.value作为参数</span></span><br><span class="line">      cb.call(vm, watcher.value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回unwatchFn函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unwatchFn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 执行watcher.teardown()方法清除观察</span></span><br><span class="line">      watcher.teardown()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>stateMixin执行的是关于状态观察的一系列方法的混入，主要是三个方面：</p><ul><li>定义实例 $data 和 $props 属性的存取器</li><li>定义实例的 $set、$delete 方法，具体实在定义在观察者模块中</li><li>定义实例的 $watch 方法</li></ul><p>到这里，关于状态初始化的部分就探索完毕了，接下来要继续研究另一个与开发过程紧密关联的部分——虚拟节点和模板渲染。</p><hr><p>状态初始化是与我们在开发的时候最息息相关的部分，在创建实例对象的配置对象中，我们设置了这些属性和方法，实例初始化的过程中对这些传入的配置进行了很多预先的处理，这就是状态初始化背后的逻辑。在探索到这一部分的时候才真正的感到，终于与平时的开发关联起来了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;本篇代码位于&lt;a href=&quot;https://github.com/vuejs/vue/blob/v2.5.17-beta.0/src/core/instance/state.js&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;vue/src/co
      
    
    </summary>
    
    
      <category term="Dev" scheme="https://ushio-s.github.io/categories/Dev/"/>
    
      <category term="Explore Vue" scheme="https://ushio-s.github.io/categories/Dev/Explore-Vue/"/>
    
    
      <category term="Vue" scheme="https://ushio-s.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue源码探究-数据绑定的实现</title>
    <link href="https://ushio-s.github.io/2018-08-07/vue-implement-of-data-binding/"/>
    <id>https://ushio-s.github.io/2018-08-07/vue-implement-of-data-binding/</id>
    <published>2018-08-07T03:18:29.000Z</published>
    <updated>2020-06-09T08:55:18.685Z</updated>
    
    <content type="html"><![CDATA[<p><em>本篇代码位于<a href="https://github.com/vuejs/vue/tree/v2.5.17-beta.0/src/core/observer" target="_blank" rel="noopener">vue/src/core/observer/</a></em></p><p>在总结完<a href="https://jylzs369.github.io/2018/07/31/vue-logic-of-data-binding/" target="_blank" rel="noopener">数据绑定实现的逻辑架构</a>一篇后，已经对Vue的数据观察系统的角色和各自的功能有了比较透彻的了解，这一篇继续仔细分析下源码的具体实现。</p><h2 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Observer类用来附加到每个观察对象上。</span></span><br><span class="line"><span class="comment">// 将被观察目标对象的属性键名转换成存取器,</span></span><br><span class="line"><span class="comment">// 以此收集依赖和派发更新</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Observer class that is attached to each observed</span></span><br><span class="line"><span class="comment"> * object. Once attached, the observer converts the target</span></span><br><span class="line"><span class="comment"> * object's property keys into getter/setters that</span></span><br><span class="line"><span class="comment"> * collect dependencies and dispatch updates.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">// 定义并导出 Observer 类</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化观测对象，依赖对象，实例计数器三个实例属性</span></span><br><span class="line">  value: any;</span><br><span class="line">  dep: Dep;</span><br><span class="line">  vmCount: number; <span class="comment">// number of vms that has this object as root $data</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造函数接受被观测对象参数</span></span><br><span class="line">  <span class="keyword">constructor</span> (value: any) &#123;</span><br><span class="line">    <span class="comment">// 将传入的观测对象赋予实例的value属性</span></span><br><span class="line">    <span class="keyword">this</span>.value = value</span><br><span class="line">    <span class="comment">// 创建新的Dep依赖对象实例赋予dep属性</span></span><br><span class="line">    <span class="keyword">this</span>.dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="comment">// 初始化实例的vmCount为0</span></span><br><span class="line">    <span class="keyword">this</span>.vmCount = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 将实例挂载到观测对象的'__ob__‘属性上</span></span><br><span class="line">    def(value, <span class="string">'__ob__'</span>, <span class="keyword">this</span>)</span><br><span class="line">    <span class="comment">// 如果观测对象是数组</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      <span class="comment">// 判断是否可以使用__proto__属性，以此甚至augment含糊</span></span><br><span class="line">      <span class="keyword">const</span> augment = hasProto</span><br><span class="line">        ? protoAugment</span><br><span class="line">        : copyAugment</span><br><span class="line">      <span class="comment">// 拦截原型对象并重新添加数组原型方法</span></span><br><span class="line">      <span class="comment">// 这里应该是为了修复包装存取器破坏了数组对象的原型继承方法的问题</span></span><br><span class="line">      augment(value, arrayMethods, arrayKeys)</span><br><span class="line">      <span class="comment">// 观察数组中的对象</span></span><br><span class="line">      <span class="keyword">this</span>.observeArray(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 遍历每一个对象属性转换成包装后的存取器</span></span><br><span class="line">      <span class="keyword">this</span>.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// walk方法用来遍历对象的每一个属性，并转化成存取器</span></span><br><span class="line">  <span class="comment">// 只在观测值是对象的情况下调用</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Walk through each property and convert them into</span></span><br><span class="line"><span class="comment">   * getter/setters. This method should only be called when</span></span><br><span class="line"><span class="comment">   * value type is Object.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  walk (obj: <span class="built_in">Object</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">      <span class="comment">// 将每一个对象属性转换成存取器</span></span><br><span class="line">      defineReactive(obj, keys[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 观察数组对象</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Observe a list of Array items.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  observeArray (items: <span class="built_in">Array</span>&lt;any&gt;) &#123;</span><br><span class="line">    <span class="comment">// 遍历每一个数组对象，并继续观察</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">      observe(items[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是两个辅助函数，用来根据是否可以使用对象的 __proto__属性来拦截原型</span></span><br><span class="line"><span class="comment">// 函数比较简单，不详细解释了</span></span><br><span class="line"><span class="comment">// helpers</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Augment an target Object or Array by intercepting</span></span><br><span class="line"><span class="comment"> * the prototype chain using __proto__</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">protoAugment</span> (<span class="params">target, src: Object, keys: any</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* eslint-disable no-proto */</span></span><br><span class="line">  target.__proto__ = src</span><br><span class="line">  <span class="comment">/* eslint-enable no-proto */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Augment an target Object or Array by defining</span></span><br><span class="line"><span class="comment"> * hidden properties.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* istanbul ignore next */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyAugment</span> (<span class="params">target: Object, src: Object, keys: Array&lt;string&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = keys.length; i &lt; l; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = keys[i]</span><br><span class="line">    def(target, key, src[key])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// observe函数用来为观测值创建观察目标实例</span></span><br><span class="line"><span class="comment">// 如果成功被观察则返回观察目标，或返回已存在观察目标</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Attempt to create an observer instance for a value,</span></span><br><span class="line"><span class="comment"> * returns the new observer if successfully observed,</span></span><br><span class="line"><span class="comment"> * or the existing observer if the value already has one.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">// 定义并导出observe函数，接受观测值和是否作为data的根属性两个参数</span></span><br><span class="line"> <span class="comment">// 返回Observer类型对象或空值</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">observe</span> (<span class="params">value: any, asRootData: ?boolean</span>): <span class="title">Observer</span> | <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否为所要求的对象，否则不继续执行</span></span><br><span class="line">  <span class="keyword">if</span> (!isObject(value) || value <span class="keyword">instanceof</span> VNode) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定义Observer类型或空值的ob变量</span></span><br><span class="line">  <span class="keyword">let</span> ob: Observer | <span class="keyword">void</span></span><br><span class="line">  <span class="comment">// 如果观测值具有__ob__属性，并且其值是Observer实例，将其赋予ob</span></span><br><span class="line">  <span class="keyword">if</span> (hasOwn(value, <span class="string">'__ob__'</span>) &amp;&amp; value.__ob__ <span class="keyword">instanceof</span> Observer) &#123;</span><br><span class="line">    ob = value.__ob__</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    <span class="comment">// 如果shouldObserve为真，且不是服务器渲染，观测值是数组或者对象</span></span><br><span class="line">    <span class="comment">// 观测值可扩展，且观测值不是Vue实例，则创建新的观察目标实例赋予ob</span></span><br><span class="line">    <span class="comment">// 这里发现了在Vue核心类创建实例的时候设置的_isVue的用途了</span></span><br><span class="line">    shouldObserve &amp;&amp;</span><br><span class="line">    !isServerRendering() &amp;&amp;</span><br><span class="line">    (<span class="built_in">Array</span>.isArray(value) || isPlainObject(value)) &amp;&amp;</span><br><span class="line">    <span class="built_in">Object</span>.isExtensible(value) &amp;&amp;</span><br><span class="line">    !value._isVue</span><br><span class="line">  ) &#123;</span><br><span class="line">    ob = <span class="keyword">new</span> Observer(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果asRootData为真且ob对象存在，ob.vmCount自增</span></span><br><span class="line">  <span class="keyword">if</span> (asRootData &amp;&amp; ob) &#123;</span><br><span class="line">    ob.vmCount++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回ob</span></span><br><span class="line">  <span class="keyword">return</span> ob</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// defineReactive函数用来为观测值包赚存取器</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Define a reactive property on an Object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 定义并导出defineReactive函数，接受参数观测源obj，属性key, 值val,</span></span><br><span class="line"><span class="comment">// 自定义setter方法customSetter，是否进行递归转换shallow五个参数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  obj: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  val: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  customSetter?: ?Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  shallow?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建依赖对象实例</span></span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取obj的属性描述符</span></span><br><span class="line">  <span class="keyword">const</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key)</span><br><span class="line">  <span class="comment">// 如果该属性不可配置则不继续执行</span></span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.configurable === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 提供预定义的存取器函数</span></span><br><span class="line">  <span class="comment">// cater for pre-defined getter/setters</span></span><br><span class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.get</span><br><span class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.set</span><br><span class="line">  <span class="comment">// 如果不存在getter或存在settter，且函数只传入2个参数，手动设置val值</span></span><br><span class="line">  <span class="comment">// 这里主要是Obserber的walk方法里使用的情况，只传入两个参数</span></span><br><span class="line">  <span class="keyword">if</span> ((!getter || setter) &amp;&amp; <span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</span><br><span class="line">    val = obj[key]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断是否递归观察子对象，并将子对象属性都转换成存取器，返回子观察目标</span></span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val)</span><br><span class="line">  <span class="comment">// 重新定义属性</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 设置getter</span></span><br><span class="line">    <span class="keyword">get</span>: function reactiveGetter () &#123;</span><br><span class="line">      <span class="comment">// 如果预定义的getter存在则value等于getter调用的返回值</span></span><br><span class="line">      <span class="comment">// 否则直接赋予属性值</span></span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="comment">// 如果存在当前依赖目标，即监视器对象，则建立依赖</span></span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dep.depend()</span><br><span class="line">        <span class="comment">// 如果子观察目标存在，建立子对象的依赖关系</span></span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          childOb.dep.depend()</span><br><span class="line">          <span class="comment">// 如果属性是数组，则特殊处理收集数组对象依赖</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">            dependArray(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 返回属性值</span></span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 设置setter，接收新值newVal参数</span></span><br><span class="line">    <span class="keyword">set</span>: function reactiveSetter (newVal) &#123;</span><br><span class="line">      <span class="comment">// 如果预定义的getter存在则value等于getter调用的返回值</span></span><br><span class="line">      <span class="comment">// 否则直接赋予属性值</span></span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="comment">// 如果新值等于旧值或者新值旧值为null则不执行</span></span><br><span class="line">      <span class="comment">/* eslint-disable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 非生产环境下如果customSetter存在，则调用customSetter</span></span><br><span class="line">      <span class="comment">/* eslint-enable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">        customSetter()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果预定义setter存在则调用，否则直接更新新值</span></span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        setter.call(obj, newVal)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 判断是否递归观察子对象并返回子观察目标</span></span><br><span class="line">      childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class="line">      <span class="comment">// 发布变更通知</span></span><br><span class="line">      dep.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是单独定义并导出的动态增减属性时观测的函数</span></span><br><span class="line"><span class="comment">// set函数用来对程序执行中动态添加的属性进行观察并转换存取器，不详细解释</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set a property on an object. Adds the new property and</span></span><br><span class="line"><span class="comment"> * triggers change notification if the property doesn't</span></span><br><span class="line"><span class="comment"> * already exist.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">set</span> (<span class="params">target: Array&lt;any&gt; | Object, key: any, val: any</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">    (isUndef(target) || isPrimitive(target))</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(<span class="string">`Cannot set reactive property on undefined, null, or primitive value: <span class="subst">$&#123;(target: any)&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">    target.length = <span class="built_in">Math</span>.max(target.length, key)</span><br><span class="line">    target.splice(key, <span class="number">1</span>, val)</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (key <span class="keyword">in</span> target &amp;&amp; !(key <span class="keyword">in</span> <span class="built_in">Object</span>.prototype)) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> ob = (target: any).__ob__</span><br><span class="line">  <span class="keyword">if</span> (target._isVue || (ob &amp;&amp; ob.vmCount)) &#123;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">      <span class="string">'Avoid adding reactive properties to a Vue instance or its root $data '</span> +</span><br><span class="line">      <span class="string">'at runtime - declare it upfront in the data option.'</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!ob) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  defineReactive(ob.value, key, val)</span><br><span class="line">  ob.dep.notify()</span><br><span class="line">  <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete函数用来对程序执行中动态删除的属性发布变更通知，不详细解释</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Delete a property and trigger change if necessary.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">del</span> (<span class="params">target: Array&lt;any&gt; | Object, key: any</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">    (isUndef(target) || isPrimitive(target))</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(<span class="string">`Cannot delete reactive property on undefined, null, or primitive value: <span class="subst">$&#123;(target: any)&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">    target.splice(key, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> ob = (target: any).__ob__</span><br><span class="line">  <span class="keyword">if</span> (target._isVue || (ob &amp;&amp; ob.vmCount)) &#123;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">      <span class="string">'Avoid deleting properties on a Vue instance or its root $data '</span> +</span><br><span class="line">      <span class="string">'- just set it to null.'</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!hasOwn(target, key)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> target[key]</span><br><span class="line">  <span class="keyword">if</span> (!ob) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  ob.dep.notify()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特殊处理数组的依赖收集的函数，递归的对数组中的成员执行依赖收集</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Collect dependencies on array elements when the array is touched, since</span></span><br><span class="line"><span class="comment"> * we cannot intercept array element access like property getters.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dependArray</span> (<span class="params">value: Array&lt;any&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> e, i = <span class="number">0</span>, l = value.length; i &lt; l; i++) &#123;</span><br><span class="line">    e = value[i]</span><br><span class="line">    e &amp;&amp; e.__ob__ &amp;&amp; e.__ob__.dep.depend()</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(e)) &#123;</span><br><span class="line">      dependArray(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// dep是个可观察对象，可以有多个指令订阅它</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A dep is an observable that can have multiple</span></span><br><span class="line"><span class="comment"> * directives subscribing to it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 定义并导出Dep类</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 定义变量</span></span><br><span class="line">  <span class="comment">// 私有变量，当前评估watcher对象</span></span><br><span class="line">  <span class="keyword">static</span> target: ?Watcher;</span><br><span class="line">  <span class="comment">// dep实例Id</span></span><br><span class="line">  id: number;</span><br><span class="line">  <span class="comment">// dep实例监视器/订阅者数组</span></span><br><span class="line">  subs: <span class="built_in">Array</span>&lt;Watcher&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义构造器</span></span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="comment">// 初始化时赋予递增的id</span></span><br><span class="line">    <span class="keyword">this</span>.id = uid++</span><br><span class="line">    <span class="keyword">this</span>.subs = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义addSub方法，接受Watcher类型的sub参数</span></span><br><span class="line">  addSub (sub: Watcher) &#123;</span><br><span class="line">    <span class="comment">// 向subs数组里添加新的watcher</span></span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义removeSub方法，接受Watcher类型的sub参数</span></span><br><span class="line">  removeSub (sub: Watcher) &#123;</span><br><span class="line">    <span class="comment">// 从subs数组里移除指定watcher</span></span><br><span class="line">    remove(<span class="keyword">this</span>.subs, sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义depend方法，将观察对象和watcher建立依赖</span></span><br><span class="line">  depend () &#123;</span><br><span class="line">    <span class="comment">// 在创建Wacther的时候会将在创建的Watcher赋值给Dep.target</span></span><br><span class="line">    <span class="comment">// 建立依赖时如果存在Watcher，则会调用Watcher的addDep方法</span></span><br><span class="line">    <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">      Dep.target.addDep(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义notify方法，通知更新</span></span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="comment">// 调用每个订阅者的update方法实现更新</span></span><br><span class="line">    <span class="comment">// stabilize the subscriber list first</span></span><br><span class="line">    <span class="keyword">const</span> subs = <span class="keyword">this</span>.subs.slice()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dep.target用来存放目前正在评估的watcher</span></span><br><span class="line"><span class="comment">// 全局唯一，并且一次也只能有一个watcher被评估</span></span><br><span class="line"><span class="comment">// the current target watcher being evaluated.</span></span><br><span class="line"><span class="comment">// this is globally unique because there could be only one</span></span><br><span class="line"><span class="comment">// watcher being evaluated at any time.</span></span><br><span class="line">Dep.target = <span class="literal">null</span></span><br><span class="line"><span class="comment">// targetStack用来存放watcher栈</span></span><br><span class="line"><span class="keyword">const</span> targetStack = []</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义并导出pushTarget函数，接受Watcher类型的参数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">pushTarget</span> (<span class="params">_target: ?Watcher</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 入栈并将当前watcher赋值给Dep.target</span></span><br><span class="line">  <span class="keyword">if</span> (Dep.target) targetStack.push(Dep.target)</span><br><span class="line">  Dep.target = _target</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义并导出popTarget函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">popTarget</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 出栈操作</span></span><br><span class="line">  Dep.target = targetStack.pop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// watcher用来解析表达式，收集依赖对象，并在表达式的值变动时执行回调函数</span></span><br><span class="line"><span class="comment">// 全局的$watch()方法和指令都以同样方式实现</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A watcher parses an expression, collects dependencies,</span></span><br><span class="line"><span class="comment"> * and fires callback when the expression value changes.</span></span><br><span class="line"><span class="comment"> * This is used for both the $watch() api and directives.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 定义并导出Watcher类</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 定义变量</span></span><br><span class="line">  vm: Component; <span class="comment">// 实例</span></span><br><span class="line">  expression: string; <span class="comment">// 表达式</span></span><br><span class="line">  cb: <span class="built_in">Function</span>; <span class="comment">// 回调函数</span></span><br><span class="line">  id: number; <span class="comment">// watcher实例Id</span></span><br><span class="line">  deep: boolean; <span class="comment">// 是否深层依赖</span></span><br><span class="line">  user: boolean; <span class="comment">// 是否用户定义</span></span><br><span class="line">  computed: boolean; <span class="comment">// 是否计算属性</span></span><br><span class="line">  sync: boolean; <span class="comment">// 是否同步</span></span><br><span class="line">  dirty: boolean;  <span class="comment">// 是否为脏监视器</span></span><br><span class="line">  active: boolean; <span class="comment">// 是否激活中</span></span><br><span class="line">  dep: Dep; <span class="comment">// 依赖对象</span></span><br><span class="line">  deps: <span class="built_in">Array</span>&lt;Dep&gt;; <span class="comment">// 依赖对象数组</span></span><br><span class="line">  newDeps: <span class="built_in">Array</span>&lt;Dep&gt;; <span class="comment">// 新依赖对象数组</span></span><br><span class="line">  depIds: SimpleSet;  <span class="comment">// 依赖id集合</span></span><br><span class="line">  newDepIds: SimpleSet; <span class="comment">// 新依赖id集合</span></span><br><span class="line">  before: ?<span class="built_in">Function</span>; <span class="comment">// 先行调用函数</span></span><br><span class="line">  getter: <span class="built_in">Function</span>; <span class="comment">// 指定getter</span></span><br><span class="line">  value: any; <span class="comment">// 观察值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义构造函数</span></span><br><span class="line">  <span class="comment">// 接收vue实例，表达式对象，回调函数，配置对象，是否渲染监视器5个参数</span></span><br><span class="line">  <span class="keyword">constructor</span> (</span><br><span class="line">    vm: Component,</span><br><span class="line">    expOrFn: string | Function,</span><br><span class="line">    cb: Function,</span><br><span class="line">    options?: ?Object,</span><br><span class="line">    isRenderWatcher?: boolean</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// 下面是对实例属性的赋值</span></span><br><span class="line">    <span class="keyword">this</span>.vm = vm</span><br><span class="line">    <span class="comment">// 如果是渲染监视器则将它赋值给实例的_watcher属性</span></span><br><span class="line">    <span class="keyword">if</span> (isRenderWatcher) &#123;</span><br><span class="line">      vm._watcher = <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加到vm._watchers数组中</span></span><br><span class="line">    vm._watchers.push(<span class="keyword">this</span>)</span><br><span class="line">    <span class="comment">// 如果配置对象存在，初始化一些配置属性</span></span><br><span class="line">    <span class="comment">// options</span></span><br><span class="line">    <span class="keyword">if</span> (options) &#123;</span><br><span class="line">      <span class="keyword">this</span>.deep = !!options.deep</span><br><span class="line">      <span class="keyword">this</span>.user = !!options.user</span><br><span class="line">      <span class="keyword">this</span>.computed = !!options.computed</span><br><span class="line">      <span class="keyword">this</span>.sync = !!options.sync</span><br><span class="line">      <span class="keyword">this</span>.before = options.before</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则将配属性设为false</span></span><br><span class="line">      <span class="keyword">this</span>.deep = <span class="keyword">this</span>.user = <span class="keyword">this</span>.computed = <span class="keyword">this</span>.sync = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.cb = cb</span><br><span class="line">    <span class="keyword">this</span>.id = ++uid <span class="comment">// uid for batching</span></span><br><span class="line">    <span class="keyword">this</span>.active = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">this</span>.dirty = <span class="keyword">this</span>.computed <span class="comment">// for computed watchers</span></span><br><span class="line">    <span class="keyword">this</span>.deps = []</span><br><span class="line">    <span class="keyword">this</span>.newDeps = []</span><br><span class="line">    <span class="keyword">this</span>.depIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="keyword">this</span>.newDepIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="keyword">this</span>.expression = process.env.NODE_ENV !== <span class="string">'production'</span></span><br><span class="line">      ? expOrFn.toString()</span><br><span class="line">      : <span class="string">''</span></span><br><span class="line">    <span class="comment">// 设置监视器的getter方法</span></span><br><span class="line">    <span class="comment">// parse expression for getter</span></span><br><span class="line">    <span class="comment">// 如果传入的expOrFn参数是函数直接赋值给getter属性</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.getter = expOrFn</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则解析传入的表达式的路径，返回最后一级数据对象</span></span><br><span class="line">      <span class="comment">// 这里是支持使用点符号获取属性的表达式来获取嵌套需观测数据</span></span><br><span class="line">      <span class="keyword">this</span>.getter = parsePath(expOrFn)</span><br><span class="line">      <span class="comment">// 不存在getter则设置空函数</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.getter) &#123;</span><br><span class="line">        <span class="keyword">this</span>.getter = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">        process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">          <span class="string">`Failed watching path: "<span class="subst">$&#123;expOrFn&#125;</span>" `</span> +</span><br><span class="line">          <span class="string">'Watcher only accepts simple dot-delimited paths. '</span> +</span><br><span class="line">          <span class="string">'For full control, use a function instead.'</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是计算属性，创建dep属性</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.computed) &#123;</span><br><span class="line">      <span class="keyword">this</span>.value = <span class="literal">undefined</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="keyword">this</span>.dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 负责调用get方法获取观测值</span></span><br><span class="line">      <span class="keyword">this</span>.value = <span class="keyword">this</span>.get()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 评估getter，并重新收集依赖项</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Evaluate the getter, and re-collect dependencies.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">get</span> () &#123;</span><br><span class="line">    <span class="comment">// 将实例添加到watcher栈中</span></span><br><span class="line">    pushTarget(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">let</span> value</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="keyword">this</span>.vm</span><br><span class="line">    <span class="comment">// 尝试调用vm的getter方法</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      value = <span class="keyword">this</span>.getter.call(vm, vm)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="comment">// 捕捉到错误时，如果是用户定义的watcher则处理异常</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">        handleError(e, vm, <span class="string">`getter for watcher "<span class="subst">$&#123;<span class="keyword">this</span>.expression&#125;</span>"`</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> e</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 最终执行“触摸”每个属性的操作，以便将它们全部跟踪为深度监视的依赖关系</span></span><br><span class="line">      <span class="comment">// "touch" every property so they are all tracked as</span></span><br><span class="line">      <span class="comment">// dependencies for deep watching</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.deep) &#123;</span><br><span class="line">        <span class="comment">// traverse方法递归每一个对象，将对象的每级属性收集为深度依赖项</span></span><br><span class="line">        traverse(value)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 执行出栈</span></span><br><span class="line">      popTarget()</span><br><span class="line">      <span class="comment">// 调用实例cleanupDeps方法</span></span><br><span class="line">      <span class="keyword">this</span>.cleanupDeps()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回观测数据</span></span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加依赖</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Add a dependency to this directive.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 定义addDep方法，接收Dep类型依赖实例对象</span></span><br><span class="line">  addDep (dep: Dep) &#123;</span><br><span class="line">    <span class="keyword">const</span> id = dep.id</span><br><span class="line">    <span class="comment">// 如果不存在依赖，将新依赖对象id和对象添加进相应数组中</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(id)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.newDepIds.add(id)</span><br><span class="line">      <span class="keyword">this</span>.newDeps.push(dep)</span><br><span class="line">      <span class="comment">// 并在dep对象中添加监视器自身</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.depIds.has(id)) &#123;</span><br><span class="line">        dep.addSub(<span class="keyword">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清理依赖项集合</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Clean up for dependency collection.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 定义cleanupDeps方法</span></span><br><span class="line">  cleanupDeps () &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="keyword">this</span>.deps.length</span><br><span class="line">    <span class="comment">// 遍历依赖列表</span></span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      <span class="keyword">const</span> dep = <span class="keyword">this</span>.deps[i]</span><br><span class="line">      <span class="comment">// 如果监视器的依赖对象列表中含有当前依赖对象</span></span><br><span class="line">      <span class="comment">// 从依赖对象中移除该监视器</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(dep.id)) &#123;</span><br><span class="line">        dep.removeSub(<span class="keyword">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重置监视器的依赖相关属性，</span></span><br><span class="line">    <span class="comment">// 将新建立的依赖转换成常规依赖</span></span><br><span class="line">    <span class="comment">// 并清空新依赖列表</span></span><br><span class="line">    <span class="keyword">let</span> tmp = <span class="keyword">this</span>.depIds</span><br><span class="line">    <span class="keyword">this</span>.depIds = <span class="keyword">this</span>.newDepIds</span><br><span class="line">    <span class="keyword">this</span>.newDepIds = tmp</span><br><span class="line">    <span class="keyword">this</span>.newDepIds.clear()</span><br><span class="line">    tmp = <span class="keyword">this</span>.deps</span><br><span class="line">    <span class="keyword">this</span>.deps = <span class="keyword">this</span>.newDeps</span><br><span class="line">    <span class="keyword">this</span>.newDeps = tmp</span><br><span class="line">    <span class="keyword">this</span>.newDeps.length = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 订阅者接口，当依赖项变更时调用</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Subscriber   .</span></span><br><span class="line"><span class="comment">   * Will be called when a dependency changes.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 定义update方法</span></span><br><span class="line">  update () &#123;</span><br><span class="line">    <span class="comment">// 如果是计算属性</span></span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.computed) &#123;</span><br><span class="line">      <span class="comment">// 计算属性的观察有两种模式：懒模式和立即模式</span></span><br><span class="line">      <span class="comment">// 默认都设置为懒模式，要使用立即模式需要至少有一个订阅者，</span></span><br><span class="line">      <span class="comment">// 典型情况下是另一个计算属性或渲染函数</span></span><br><span class="line">      <span class="comment">// A computed property watcher has two modes: lazy and activated.</span></span><br><span class="line">      <span class="comment">// It initializes as lazy by default, and only becomes activated when</span></span><br><span class="line">      <span class="comment">// it is depended on by at least one subscriber, which is typically</span></span><br><span class="line">      <span class="comment">// another computed property or a component's render function.</span></span><br><span class="line">      <span class="comment">// 当不存在依赖列表</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.dep.subs.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 设置dirty属性为true，这是因为在懒模式下只在需要的时候才执行计算，</span></span><br><span class="line">        <span class="comment">// 所以为了稍后执行先把dirty属性设置成true,这样在属性被访问的时候</span></span><br><span class="line">        <span class="comment">// 才会执行真实的计算过程。</span></span><br><span class="line">        <span class="comment">// In lazy mode, we don't want to perform computations until necessary,</span></span><br><span class="line">        <span class="comment">// so we simply mark the watcher as dirty. The actual computation is</span></span><br><span class="line">        <span class="comment">// performed just-in-time in this.evaluate() when the computed property</span></span><br><span class="line">        <span class="comment">// is accessed.</span></span><br><span class="line">        <span class="keyword">this</span>.dirty = <span class="literal">true</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 在立即执行模式中，需要主动执行计算</span></span><br><span class="line">        <span class="comment">// 但只在值真正变化的时候才通知订阅者</span></span><br><span class="line">        <span class="comment">// In activated mode, we want to proactively perform the computation</span></span><br><span class="line">        <span class="comment">// but only notify our subscribers when the value has indeed changed.</span></span><br><span class="line">        <span class="comment">// 调用getAndInvoke函数，判断是否观测值真正变化，并发布更新通知</span></span><br><span class="line">        <span class="keyword">this</span>.getAndInvoke(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.dep.notify()</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sync) &#123;</span><br><span class="line">      <span class="comment">// 如果同步执行，则调用实例run方法</span></span><br><span class="line">      <span class="keyword">this</span>.run()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则将监视器添加进待评估队列</span></span><br><span class="line">      queueWatcher(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调度工作接口，会被调度器调用</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Scheduler job interface.</span></span><br><span class="line"><span class="comment">   * Will be called by the scheduler.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 定义run方法</span></span><br><span class="line">  run () &#123;</span><br><span class="line">    <span class="comment">// 如果当前监视器处于活跃状态，则立即调用getAndInvoke方法</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.active) &#123;</span><br><span class="line">      <span class="keyword">this</span>.getAndInvoke(<span class="keyword">this</span>.cb)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义getAndInvoke方法，接收一个回调函数参数</span></span><br><span class="line">  getAndInvoke (cb: <span class="built_in">Function</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取新观测值</span></span><br><span class="line">    <span class="keyword">const</span> value = <span class="keyword">this</span>.get()</span><br><span class="line">    <span class="comment">// 当旧值与新值不相等，或者挂厕纸是对象，或需要深度观察时</span></span><br><span class="line">    <span class="comment">// 触发变更，发布通知</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      value !== <span class="keyword">this</span>.value ||</span><br><span class="line">      <span class="comment">// 因为对象或数组即使相等时，其值可能发生变异所以也需要触发更新</span></span><br><span class="line">      <span class="comment">// Deep watchers and watchers on Object/Arrays should fire even</span></span><br><span class="line">      <span class="comment">// when the value is the same, because the value may</span></span><br><span class="line">      <span class="comment">// have mutated.</span></span><br><span class="line">      isObject(value) ||</span><br><span class="line">      <span class="keyword">this</span>.deep</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// 更细观测值，并设置置否dirty属性</span></span><br><span class="line">      <span class="comment">// set new value</span></span><br><span class="line">      <span class="keyword">const</span> oldValue = <span class="keyword">this</span>.value</span><br><span class="line">      <span class="keyword">this</span>.value = value</span><br><span class="line">      <span class="keyword">this</span>.dirty = <span class="literal">false</span></span><br><span class="line">      <span class="comment">// 如果是用户自定义监视器，则在调用回调函数时设置错误捕捉</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          cb.call(<span class="keyword">this</span>.vm, value, oldValue)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          handleError(e, <span class="keyword">this</span>.vm, <span class="string">`callback for watcher "<span class="subst">$&#123;<span class="keyword">this</span>.expression&#125;</span>"`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cb.call(<span class="keyword">this</span>.vm, value, oldValue)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 评估和返回观测值方法，只在计算属性时被调用</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Evaluate and return the value of the watcher.</span></span><br><span class="line"><span class="comment">   * This only gets called for computed property watchers.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 定义evaluate方法</span></span><br><span class="line">  evaluate () &#123;</span><br><span class="line">    <span class="comment">// 如果是计算属性，获取观测是，并返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.dirty) &#123;</span><br><span class="line">      <span class="keyword">this</span>.value = <span class="keyword">this</span>.get()</span><br><span class="line">      <span class="keyword">this</span>.dirty = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 建立监视器的依赖方法，只在计算属性调用</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Depend on this watcher. Only for computed property watchers.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 定义depend方法</span></span><br><span class="line">  depend () &#123;</span><br><span class="line">    <span class="comment">// 如果依赖对象存在且存在当前运行监视器，建立依赖</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.dep &amp;&amp; Dep.target) &#123;</span><br><span class="line">      <span class="keyword">this</span>.dep.depend()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 销毁监视器方法，将自身从依赖数组中移除</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Remove self from all dependencies' subscriber list.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 定义teardown方法</span></span><br><span class="line">  teardown () &#123;</span><br><span class="line">    <span class="comment">// 当监视器处于活跃状态，执行销毁</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.active) &#123;</span><br><span class="line">      <span class="comment">// 从监视器列表中移除监视器是高开销操作</span></span><br><span class="line">      <span class="comment">// 所以如果实例正在销毁中则跳过销毁</span></span><br><span class="line">      <span class="comment">// remove self from vm's watcher list</span></span><br><span class="line">      <span class="comment">// this is a somewhat expensive operation so we skip it</span></span><br><span class="line">      <span class="comment">// if the vm is being destroyed.</span></span><br><span class="line">      <span class="comment">// 当实例正常运行中，从监视器列表中移除监视器</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.vm._isBeingDestroyed) &#123;</span><br><span class="line">        remove(<span class="keyword">this</span>.vm._watchers, <span class="keyword">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 从所有依赖列表中移除该监视器</span></span><br><span class="line">      <span class="keyword">let</span> i = <span class="keyword">this</span>.deps.length</span><br><span class="line">      <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        <span class="keyword">this</span>.deps[i].removeSub(<span class="keyword">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将监视器的活跃状态置否</span></span><br><span class="line">      <span class="keyword">this</span>.active = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本篇主要是关于源码的解释，可以翻看观察系统的原理篇来对照理解。</p><hr><p>在这里记录下了Vue的数据绑定具体实现的源代码的个人理解，有些细节的地方或许还认识的不够充分，观察系统里的三个类兜兜转转，关联性很强，在各自的方法中交叉地引用自身与其他类的实例，很容易让人头晕目眩，不管怎样，对于整体功能逻辑有清晰的认识，以后便能向更高层面迈进。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;本篇代码位于&lt;a href=&quot;https://github.com/vuejs/vue/tree/v2.5.17-beta.0/src/core/observer&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;vue/src/core/observ
      
    
    </summary>
    
    
      <category term="Dev" scheme="https://ushio-s.github.io/categories/Dev/"/>
    
      <category term="Explore Vue" scheme="https://ushio-s.github.io/categories/Dev/Explore-Vue/"/>
    
    
      <category term="Vue" scheme="https://ushio-s.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue源码探究-数据绑定逻辑架构</title>
    <link href="https://ushio-s.github.io/2018-07-31/vue-logic-of-data-binding/"/>
    <id>https://ushio-s.github.io/2018-07-31/vue-logic-of-data-binding/</id>
    <published>2018-07-31T01:37:55.000Z</published>
    <updated>2020-06-09T08:54:52.735Z</updated>
    
    <content type="html"><![CDATA[<p>数据观察系统是Vue实现数据绑定、异步更新的核心模块，数据观察系统的实现也是Vue源码里最为复杂的部分，在仔细研究具体实现之前，先对整个数据绑定的逻辑架构进行一个充分的认识，会更有助于解读源码。</p><p>先说明一下，因为三个类的名称比较容易让人误解，所以在以后把Observer称作观察目标，Watcher称作监视器，Dep称作依赖对象。</p><h2 id="数据绑定逻辑架构"><a href="#数据绑定逻辑架构" class="headerlink" title="数据绑定逻辑架构"></a>数据绑定逻辑架构</h2><p>Vue的数据观察系统是基于发布者/订阅者模式，数据更新触发刷新页面的过程主要依赖数据观察系统里铁三角关系。在这个系统中，主要角色分别是 <code>Observer</code>、<code>Dep</code>、<code>Watcher</code> 这三个对象，对于每一个角色在观察数据更新的流程中各自承担的职责需要深入进行理解。下面请出三个主角登场，来介绍一下它们：</p><h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><p><code>Observer</code> 相当于观察目标类，在数据绑定逻辑架构中的职责是收集需要观察的数据对象，进行变量存取器的包装，并递归地对每一个需要观察的对象注册发布者对象，再由发布者去注册相应的监视器。这里非常巧妙的是触发通知监视器数据更新的事件的注册，一般的发布订阅模式需要建立一个事件管理器或者调度中心来统一管理各种事件的注册，然而Vue的数据绑定不需要这样的机制，它借用 <code>Object.defineProperty</code> 方法来为每一个被监视的数据设置了存取器，依靠数据的存取行为自然地实现了事件的触发。在初始化Vue实例中设置的 <code>data</code> 属性时，对这些输入的数据对象对行了依赖追踪，包装后的变量存放在 <code>_data</code> 属性中，这个过程中发布者和监视器的依赖添加是不可见的；而通过配置 <code>watch</code> 属性显式设置的监视器，就可以在实例的 <code>_watchers</code> 私有属性中查看到。每个组件初始化后有一个唯一的 <code>_watcher</code> 对象，它是一个用来监视在 <code>data</code> 中注册的数据变动从而更新视图的监视器，它也默认被添加到了各属性的依赖监视数组中。在每个修改为可观察状态的属性中，都含有一个 <code>Dep</code> 实例即发布者，这个对象的 <code>subs</code> 属性就是用来存放依赖的所有监视器 <code>Watcher</code> 实例对象，<code>subs</code> 可以理解为订阅者，即所有订阅了该数据对象变动的监视器的数组集合。之所以需要在一开始为数据收集依赖，参考另一些开发者的总结是由于并非所有的数据都值得监视，要知道监视没有用到的数据就是对性能的浪费，在实例观察中也确实发现，页面中没有用到的属性，没有被初始化为依赖项，这样即便改变了它的数值，页面也不会触发多余的刷新。</p><h3 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h3><p><code>Dep</code> 在Vue的数据观察者系统里充当发布者的角色，它不仅用来触发数据更新和建立依赖的事件，还用来存放每一个可监视数据所依赖的监视器，这个正是在第一步收集依赖时的重要一环。实例初始化的过程中收集了所有需要跟踪变化的数据，在运用 <code>Observer</code> 重新包装每一个属性的同时，创建了各自的 <code>dep</code> 对象，并在get和set方法中分别使用了 <code>Dep</code>的两个方法：<code>depend</code> 建立依赖，<code>notify</code> 通知变动。另外 <code>Dep</code> 还负责维护依赖监视器的增减。在构造 <code>Dep</code> 类的过程中，定义了全局的 <code>Dep.target</code> 对象和 <code>targetStack</code> 数组，<code>targetStack</code> 数组是用来存放待执行的 <code>watcher</code> 栈，<code>Dep.target</code> 是用来指代当前的监视器，必须唯一，它的存在对于建立监视器的依赖起到重要作用，在重置数据的 <code>getter</code> 时，当它存在时才执行建立数据与监视器的依赖，即只有显式配置了 <code>watch</code> 或创建了 <code>computed</code> 变量时才会在实例的私有属性里看到监视器。</p><h3 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h3><p><code>Watcher</code> 是这个架构中的监视器，充当观察者的角色。在Vue实例初始化的过程中，一定会默认创建一个监视器，这个监视器就是用来监视实例对象的数据变化用来更新视图的，实例的私有属性 <code>_watcher</code> 用来存放它。在创建可观察的数据时，每一个数据的 <code>Dep</code> 对象会收集监视器并建立依赖，当数据变化时，<code>Dep</code> 对象通知所有的监视器执行更新，执行更新有两种模式，如果依赖是通过配置 <code>computed</code> 变量创建的，则会立即触发相关的更新操作，如果数据的 <code>dep.subs</code> 数组中没有依赖的监视器，则默认惰性更新模式。<code>Watcher</code> 类最主要的作用是通知视图更新，众所周知视图的更新是非常花费时间，会影响程序性能，为了尽量减少视图更新导致的性能损失，在通知视图执行更新操作之前会有一个缓冲时段，在这个时段中会收集最后一次监视器收到的变更，减少不必要的重复更新，实现最优性能。</p><h3 id="架构图示"><a href="#架构图示" class="headerlink" title="架构图示"></a>架构图示</h3><p>充分了解了数据观察系统的三个主角之后，再来看看官网贴出的示意图，就会发现终于能摸清Vue的数据观察系统的架构了，只不过渲染视图的具体实现与数据观察系统的交互暂时还没有去摸索，以后会仔细地去探索，现在终于比较清晰地弄懂了Vue的数据绑定的原理了。</p><p><img src="https://cn.vuejs.org/images/data.png" alt="Vue数据观察系统架构"></p><h2 id="一个简单的实例"><a href="#一个简单的实例" class="headerlink" title="一个简单的实例"></a>一个简单的实例</h2><p>为了更清晰初步了解数据绑定相关的初始化过程，创建了一个非常简单的实例，data配置了两个属性，其中 <code>name</code> 变量并不在页面中使用，还显式设置了一个依赖 <code>msg</code> 的监视器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      msg: <span class="string">'hello'</span>,</span><br><span class="line">      name: <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    <span class="string">'msg'</span> (value) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'msg更新了'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>下面截图是实例的相关监视器私有属性，<code>_watcher</code> 是跟踪页面渲染的监视器，每个实例唯一；<code>_wacthers</code> 是实例所拥有的所有监视器的集合。显式设置的 <code>watcher</code> 在是数组中的第一个对象。这里虽然看不到 <code>Observer</code> 背后的包装过程，但改变了 <code>msg</code> 属性之后，可以看到监视器执行的回调显示。</p><div style="text-align: left;">![相关的私有属性](https://upload-images.jianshu.io/upload_images/3497104-9f03070c84e68358.jpg)<p><img src="https://upload-images.jianshu.io/upload_images/3497104-07706eb31473fb1a.jpg" alt="显式设置的wacther"></p><p><img src="https://upload-images.jianshu.io/upload_images/3497104-d625a4f7fcea08cd.jpg" alt="实例所有的watcher"></p></div>---<p>从Vue对象实例化着手到开始分析数据绑定的核心实现，这一路过来还没有真正遇到值得困扰的问题。但未曾想到的是，数据绑定这个Vue的核心特色功能竟然让我苦苦研读了好几天，似乎以前对于设计模式的了解显得那样无力。期间去搜索了一些前人做的分析说明文章以求从各个角度深入理解，但大多数解读读完后依然觉得没能很透彻地理解这个模块，后来读到了一个<a href="https://www.jb51.net/article/107927.htm" target="_blank" rel="noopener">简易实现Vue观察者系统的文章</a>，让我忽然对核心逻辑是如何实现的有了比较清晰的认识，而且对于设计模式也有了更深入的理解。也许第一次读源码的时候太多非核心的技术实现干扰了对于核心部分的理解，也因为之前的一些知识不牢固，所以从这一次学习中得到了一个很好的经验，要更加关注本质。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;数据观察系统是Vue实现数据绑定、异步更新的核心模块，数据观察系统的实现也是Vue源码里最为复杂的部分，在仔细研究具体实现之前，先对整个数据绑定的逻辑架构进行一个充分的认识，会更有助于解读源码。&lt;/p&gt;
&lt;p&gt;先说明一下，因为三个类的名称比较容易让人误解，所以在以后把Obs
      
    
    </summary>
    
    
      <category term="Dev" scheme="https://ushio-s.github.io/categories/Dev/"/>
    
      <category term="Explore Vue" scheme="https://ushio-s.github.io/categories/Dev/Explore-Vue/"/>
    
    
      <category term="Vue" scheme="https://ushio-s.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue源码探究-事件系统</title>
    <link href="https://ushio-s.github.io/2018-07-16/vue-events-system/"/>
    <id>https://ushio-s.github.io/2018-07-16/vue-events-system/</id>
    <published>2018-07-16T03:09:34.000Z</published>
    <updated>2020-06-09T08:55:35.649Z</updated>
    
    <content type="html"><![CDATA[<p><em>本章代码位于<a href="https://github.com/vuejs/vue/blob/v2.5.17-beta.0/src/core/instance/events.js" target="_blank" rel="noopener">vue/src/core/instance/events.js</a></em></p><p>紧跟着生命周期之后的就是继续初始化事件相关的属性和方法。整个事件系统的代码相对其他模块来说非常简短，分几个部分来详细看看它的具体实现。</p><h2 id="头部引用"><a href="#头部引用" class="headerlink" title="头部引用"></a>头部引用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  tip,</span><br><span class="line">  toArray,</span><br><span class="line">  hyphenate,</span><br><span class="line">  handleError,</span><br><span class="line">  formatComponentName</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></span><br><span class="line"><span class="keyword">import</span> &#123; updateListeners &#125; <span class="keyword">from</span> <span class="string">'../vdom/helpers/index'</span></span><br></pre></td></tr></table></figure><p>头部先是引用了的一些工具方法，没有什么难点，具体可以查看相应文件。唯一值得注意的是引用自虚拟节点模块的一个叫 <code>updateListeners</code> 方法。顾名思义，是用来更新监听器的，至于为什么要有这样的一个方法，主要是因为如果该实例的父组件已经存在一些事件监听器，为了正确捕获到事件并向上冒泡，父级事件是需要继承下来的，这个原因在下面的初始化代码中有佐证；另外，如果在实例初始化的时候绑定了同名的事件处理器，也需要为同名事件添加新的处理器，以实现同一事件的多个监听器的绑定。</p><h2 id="事件初始化"><a href="#事件初始化" class="headerlink" title="事件初始化"></a>事件初始化</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义并导出initEvents函数，接受Component类型的vm参数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initEvents</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建例的_events属性，初始化为空对象</span></span><br><span class="line">  vm._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  <span class="comment">// 创建实例的_hasHookEvent属性，初始化为false</span></span><br><span class="line">  vm._hasHookEvent = <span class="literal">false</span></span><br><span class="line">  <span class="comment">// 初始化父级附属事件</span></span><br><span class="line">  <span class="comment">// init parent attached events</span></span><br><span class="line">  <span class="keyword">const</span> listeners = vm.$options._parentListeners</span><br><span class="line">  <span class="comment">// 如果父级事件存在，则更新实例事件监听器</span></span><br><span class="line">  <span class="keyword">if</span> (listeners) &#123;</span><br><span class="line">    updateComponentListeners(vm, listeners)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置target值，目标是引用实例</span></span><br><span class="line"><span class="keyword">let</span> target: any</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加事件函数，接受事件名称、事件处理器、是否一次性执行三个参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">event, fn, once</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (once) &#123;</span><br><span class="line">    target.$once(event, fn)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    target.$on(event, fn)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除事件函数，接受事件名称和时间处理器两个参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span> (<span class="params">event, fn</span>) </span>&#123;</span><br><span class="line">  target.$off(event, fn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义并导出函数updateComponentListeners，接受实例对象，新旧监听器参数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">updateComponentListeners</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vm: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  listeners: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  oldListeners: ?Object</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 设置target为vm</span></span><br><span class="line">  target = vm</span><br><span class="line">  <span class="comment">// 执行更新监听器函数，传入新旧事件监听对象、添加事件与移除事件函数、实例对象</span></span><br><span class="line">  updateListeners(listeners, oldListeners || &#123;&#125;, add, remove, vm)</span><br><span class="line">  <span class="comment">// 置空引用</span></span><br><span class="line">  target = <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上述代码所示，事件监听系统的初始化首先是创建了私有的事件对象和是否有事件钩子的标志两个属性，然后根据父级是否有事件处理器来决定是否更新当前实例的事件监听器，具体如何实现监听器的更新，贴上这段位于<a href="https://github.com/vuejs/vue/blob/v2.5.17-beta.0/src/core/vdom/helpers/update-listeners.js" target="_blank" rel="noopener">虚拟节点模块的辅助函数</a>中的代码片段来仔细看看。</p><h3 id="更新事件监听器"><a href="#更新事件监听器" class="headerlink" title="更新事件监听器"></a>更新事件监听器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义并导出updateListeners哈数</span></span><br><span class="line"><span class="comment">// 接受新旧事件监听器对象，事件添加和移除函数以及实例对象参数。</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">updateListeners</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  on: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  oldOn: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  add: Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  remove: Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  vm: Component</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定义一些辅助变量</span></span><br><span class="line">  <span class="keyword">let</span> name, def, cur, old, event</span><br><span class="line">  <span class="comment">// 遍历新的监听器对象</span></span><br><span class="line">  <span class="keyword">for</span> (name <span class="keyword">in</span> on) &#123;</span><br><span class="line">    <span class="comment">// 为def和cur赋值为新的事件对象</span></span><br><span class="line">    def = cur = on[name]</span><br><span class="line">    <span class="comment">// 为old赋值为旧的事件对象</span></span><br><span class="line">    old = oldOn[name]</span><br><span class="line">    <span class="comment">// 标准化事件对象并赋值给event。</span></span><br><span class="line">    <span class="comment">// normalizeEvent函数主要用于将传入的带有特殊前缀的事件修饰符分解为具有特定值的事件对象</span></span><br><span class="line">    event = normalizeEvent(name)</span><br><span class="line">    <span class="comment">// 下面代码是weex框架专用，处理cur变量和格式化好的事件对象的参数属性</span></span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (__WEEX__ &amp;&amp; isPlainObject(def)) &#123;</span><br><span class="line">      cur = def.handler</span><br><span class="line">      event.params = def.params</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果新事件不存在，在非生产环境中提供报错信息，否则不执行任何操作</span></span><br><span class="line">    <span class="keyword">if</span> (isUndef(cur)) &#123;</span><br><span class="line">      process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">        <span class="string">`Invalid handler for event "<span class="subst">$&#123;event.name&#125;</span>": got `</span> + <span class="built_in">String</span>(cur),</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    <span class="comment">// 当旧事件不存在时</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isUndef(old)) &#123;</span><br><span class="line">      <span class="comment">// 如果新事件对象cur的fns属性不存在</span></span><br><span class="line">      <span class="keyword">if</span> (isUndef(cur.fns)) &#123;</span><br><span class="line">        <span class="comment">// 创建函数调用器并重新复制给cur和on[name]</span></span><br><span class="line">        cur = on[name] = createFnInvoker(cur)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 添加新的事件处理器</span></span><br><span class="line">      add(event.name, cur, event.once, event.capture, event.passive, event.params)</span><br><span class="line">    <span class="comment">// 如果新旧事件不完全相等</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur !== old) &#123;</span><br><span class="line">      <span class="comment">// 用新事件处理函数覆盖旧事件对象的fns属性</span></span><br><span class="line">      old.fns = cur</span><br><span class="line">      <span class="comment">// 将事件对象重新复制给on</span></span><br><span class="line">      on[name] = old</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遍历旧事件监听器</span></span><br><span class="line">  <span class="keyword">for</span> (name <span class="keyword">in</span> oldOn) &#123;</span><br><span class="line">    <span class="comment">// 如果新事件对象不存在</span></span><br><span class="line">    <span class="keyword">if</span> (isUndef(on[name])) &#123;</span><br><span class="line">      <span class="comment">// 标准化事件对象</span></span><br><span class="line">      event = normalizeEvent(name)</span><br><span class="line">      <span class="comment">// 移除事件处理器</span></span><br><span class="line">      remove(event.name, oldOn[name], event.capture)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中用到了 <code>normalizeEvent</code> 和 <code>createFnInvoker</code> 两个主要的函数来完成更新监听器的实现，代码与 <code>updateListeners</code> 函数位于同一文件中。</p><ul><li><code>normalizeEvent</code>：主要是用于返回一个定制化的事件对象，这个函数接受4个必选参数和2两个可选参数，分别是事件名称name属性、是否一次性执行的once属性、是否捕获事件的capture属性、是否使用被动模式passive属性、事件处理器handler方法、事件处理器参数params数组。属性的含义都比较好理解，特别注意一下 <code>once</code>、<code>capture</code>、<code>passive</code> 属性，这三个属性是用来修饰事件的，分别对应了 <code>~</code>、<code>!</code>、<code>&amp;</code> 修饰符，贴上一个官方文档中的使用示例，引用自<a href="https://cn.vuejs.org/v2/guide/render-function.html#事件-amp-按键修饰符" target="_blank" rel="noopener">事件 &amp; 按键修饰符</a>。启动被动模式的用途是使事件处理器无法阻止默认事件，比如 <code>&lt;a&gt;</code> 标签自带的链接跳转事件，如果设置passive为true，则事件处理器即便是设置了阻止默认事件也是没办法阻止跳转的。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">on: &#123;</span><br><span class="line">  <span class="string">'!click'</span>: <span class="keyword">this</span>.doThisInCapturingMode,</span><br><span class="line">  <span class="string">'~keyup'</span>: <span class="keyword">this</span>.doThisOnce,</span><br><span class="line">  <span class="string">'~!mouseover'</span>: <span class="keyword">this</span>.doThisOnceInCapturingMode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>createFnInvoker</code>： 接受一个fns参数，可以传入一个事件处理器函数，也可以传入一个包含多个处理器的数组。在该函数内部定义了一个 <code>invoker</code> 函数并且最终返回它，函数有一个fns属性是用来存放所传入的处理器的，调用这个函数后，会按fns的类型来分别执行处理器数组的调用或单个处理器的调用。这个实现即是真正执行事件处理器调用的过程。</li></ul><h2 id="事件相关的原型方法"><a href="#事件相关的原型方法" class="headerlink" title="事件相关的原型方法"></a>事件相关的原型方法</h2><p>在事件的初始化过程里有用到几个以 <code>&amp;</code> 开头的类原型方法，它们是在mixin函数里挂载到核心类上的。初始化的时候定义的方法都是在这些方法的基础上再进行了一次封装，其绑定事件、触发事件和移除事件的具体实现都在这些方法中，当然不会放过对这些细节的探索。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出eventsMixin函数，接收形参Vue，</span></span><br><span class="line"><span class="comment">// 使用Flow进行静态类型检查指定为Component类</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">eventsMixin</span> (<span class="params">Vue: Class&lt;Component&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定义hook正则检验</span></span><br><span class="line">  <span class="keyword">const</span> hookRE = <span class="regexp">/^hook:/</span></span><br><span class="line">  <span class="comment">// 给Vue原型对象挂载$on方法</span></span><br><span class="line">  <span class="comment">// 参数event可为字符串或数组类型，fn是事件监听函数</span></span><br><span class="line">  <span class="comment">// 方法返回实例对象本身</span></span><br><span class="line">  Vue.prototype.$on = <span class="function"><span class="keyword">function</span> (<span class="params">event: string | Array&lt;string&gt;, fn: Function</span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义实例变量</span></span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// 如果传入的event参数是数组，遍历event数组，为所有事件注册fn监听函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(event)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = event.length; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$on(event[i], fn)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// event参数为字符串时，检查event事件监听函数数组是否存在</span></span><br><span class="line">      <span class="comment">// 已存在事件监听数组则直接添加新监听函数</span></span><br><span class="line">      <span class="comment">// 否则建立空的event事件监听函数数组，再添加新监听函数</span></span><br><span class="line">      (vm._events[event] || (vm._events[event] = [])).push(fn)</span><br><span class="line">      <span class="comment">// 此处做了性能优化，使用正则检验hook:是否存在的布尔值</span></span><br><span class="line">      <span class="comment">// 而不是hash值查找设置实例对象的_hasHookEvent值</span></span><br><span class="line">      <span class="comment">// 此次优化是很久之前版本的修改，暂时不太清楚以前hash值查找是什么逻辑，留待以后查证</span></span><br><span class="line">      <span class="comment">// optimize hook:event cost by using a boolean flag marked at registration</span></span><br><span class="line">      <span class="comment">// instead of a hash lookup</span></span><br><span class="line">      <span class="keyword">if</span> (hookRE.test(event)) &#123;</span><br><span class="line">        vm._hasHookEvent = <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回实例本身</span></span><br><span class="line">    <span class="keyword">return</span> vm</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 为Vue原型对象挂载$once方法</span></span><br><span class="line">  <span class="comment">// 参数event只接受字符串，fn是监听函数</span></span><br><span class="line">  Vue.prototype.$once = <span class="function"><span class="keyword">function</span> (<span class="params">event: string, fn: Function</span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义实例变量</span></span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// 创建on函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">on</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 函数执行后先清除event事件绑定的on监听函数，即函数本身</span></span><br><span class="line">      <span class="comment">// 这样以后就不会再继续监听event事件</span></span><br><span class="line">      vm.$off(event, on)</span><br><span class="line">      <span class="comment">// 在实例上运行fn监听函数</span></span><br><span class="line">      fn.apply(vm, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为on函数设置fn属性，保证在on函数内能够正确找到fn函数</span></span><br><span class="line">    on.fn = fn</span><br><span class="line">    <span class="comment">// 为event事件注册on函数</span></span><br><span class="line">    vm.$on(event, on)</span><br><span class="line">    <span class="comment">// 返回实例本身</span></span><br><span class="line">    <span class="keyword">return</span> vm</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 为Vue原型对象挂载$off方法</span></span><br><span class="line">  <span class="comment">// event参数可为字符串或数组类型</span></span><br><span class="line">  <span class="comment">// fn是监听函数，为可选参数</span></span><br><span class="line">  Vue.prototype.$off = <span class="function"><span class="keyword">function</span> (<span class="params">event?: string | Array&lt;string&gt;, fn?: Function</span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义实例变量</span></span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// 如果没有传入参数，则清除实例对象的所有事件</span></span><br><span class="line">    <span class="comment">// 将实例对象的_events私有属性设置为null，并返回实例</span></span><br><span class="line">   <span class="comment">// all</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">arguments</span>.length) &#123;</span><br><span class="line">      vm._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">      <span class="keyword">return</span> vm</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果event参数传入数组，清除所有event事件的fn监听函数返回实例</span></span><br><span class="line">    <span class="comment">// 这里是$off方法递归执行，最终会以单一事件为基础来实现监听的清除</span></span><br><span class="line">    <span class="comment">// array of events</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(event)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = event.length; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$off(event[i], fn)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> vm</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果指定单一事件，将事件的监听函数数组赋值给cbs变量</span></span><br><span class="line">    <span class="comment">// specific event</span></span><br><span class="line">    <span class="keyword">const</span> cbs = vm._events[event]</span><br><span class="line">    <span class="comment">// 如果没有注册此事件监听则返回实例</span></span><br><span class="line">    <span class="keyword">if</span> (!cbs) &#123;</span><br><span class="line">      <span class="keyword">return</span> vm</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有指定监听函数，则清除所有该事件的监听函数，返回实例</span></span><br><span class="line">    <span class="keyword">if</span> (!fn) &#123;</span><br><span class="line">      vm._events[event] = <span class="literal">null</span></span><br><span class="line">      <span class="keyword">return</span> vm</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果指定监听函数，则遍历事件监听函数数组，移除指定监听函数返回实例</span></span><br><span class="line">    <span class="keyword">if</span> (fn) &#123;</span><br><span class="line">      <span class="comment">// specific handler</span></span><br><span class="line">      <span class="keyword">let</span> cb</span><br><span class="line">      <span class="keyword">let</span> i = cbs.length</span><br><span class="line">      <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        cb = cbs[i]</span><br><span class="line">        <span class="keyword">if</span> (cb === fn || cb.fn === fn) &#123;</span><br><span class="line">          cbs.splice(i, <span class="number">1</span>)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vm</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 为Vue原型对象挂载$emit方法，只接受单一event</span></span><br><span class="line">  Vue.prototype.$emit = <span class="function"><span class="keyword">function</span> (<span class="params">event: string</span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义实例变量</span></span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// 在非生产环境下，传入的事件字符串如果是驼峰值且有相应的小写监听事件</span></span><br><span class="line">    <span class="comment">// 则提示事件已注册，且无法使用驼峰式注册事件</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> lowerCaseEvent = event.toLowerCase()</span><br><span class="line">      <span class="keyword">if</span> (lowerCaseEvent !== event &amp;&amp; vm._events[lowerCaseEvent]) &#123;</span><br><span class="line">        tip(</span><br><span class="line">          <span class="string">`Event "<span class="subst">$&#123;lowerCaseEvent&#125;</span>" is emitted in component `</span> +</span><br><span class="line">          <span class="string">`<span class="subst">$&#123;formatComponentName(vm)&#125;</span> but the handler is registered for "<span class="subst">$&#123;event&#125;</span>". `</span> +</span><br><span class="line">          <span class="string">`Note that HTML attributes are case-insensitive and you cannot use `</span> +</span><br><span class="line">          <span class="string">`v-on to listen to camelCase events when using in-DOM templates. `</span> +</span><br><span class="line">          <span class="string">`You should probably use "<span class="subst">$&#123;hyphenate(event)&#125;</span>" instead of "<span class="subst">$&#123;event&#125;</span>".`</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将事件监听函数数组赋值 给cbs</span></span><br><span class="line">    <span class="keyword">let</span> cbs = vm._events[event]</span><br><span class="line">    <span class="comment">// 如果监听函数数组存在</span></span><br><span class="line">    <span class="keyword">if</span> (cbs) &#123;</span><br><span class="line">      <span class="comment">// 重置cbs变量，为何要使用toArray方法转换一次数组不太明白？</span></span><br><span class="line">      cbs = cbs.length &gt; <span class="number">1</span> ? toArray(cbs) : cbs</span><br><span class="line">      <span class="comment">// 将event之后传入的所有参数定义为args数组</span></span><br><span class="line">      <span class="keyword">const</span> args = toArray(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">      <span class="comment">// 遍历所有监听函数，为实例执行每一个监听函数，并传入args参数数组</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = cbs.length; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          cbs[i].apply(vm, args)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          handleError(e, vm, <span class="string">`event handler for "<span class="subst">$&#123;event&#125;</span>"`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vm</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>eventsMixin的内容非常直观，分别为实例原型对象挂载了<code>$on</code>、<code>$once</code>、<code>$off</code>、<code>$emit</code>四个方法。这是实例事件监听函数的注册、一次性注册、移除和触发的内部实现。在使用的过程中会对这些实现有一个更清晰的理解。</p><hr><p>终于对Vue的事件系统的实现有了一个大致了解，没有什么特别高深的处理，但完整的事件系统的实现有很多细致的功能这里其实并没有特别详细地探讨，比如事件修饰符，可以参考官方文档里的解说会有一个更清晰的了解。事件系统的重要作用首先是为实例制定了一套处理事件的方案和标准，其次是在实例数据更新的过程中保持对事件监听器的更新，这两个部分的处理是最需要细致去琢磨的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;本章代码位于&lt;a href=&quot;https://github.com/vuejs/vue/blob/v2.5.17-beta.0/src/core/instance/events.js&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;vue/src/c
      
    
    </summary>
    
    
      <category term="Dev" scheme="https://ushio-s.github.io/categories/Dev/"/>
    
      <category term="Explore Vue" scheme="https://ushio-s.github.io/categories/Dev/Explore-Vue/"/>
    
    
      <category term="Vue" scheme="https://ushio-s.github.io/tags/Vue/"/>
    
  </entry>
  
</feed>
