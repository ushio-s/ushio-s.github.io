<!DOCTYPE html>
<html  lang=zh-CN>
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  
    
    <link rel="shortcut icon" href="/images/favicon.ico ">
    
    
    <link rel="icon" type="image/png" href="/images/favicon-android.png " sizes="192x192">
    
    
    <link rel="apple-touch-icon" href="/images/favicon-apple.png " sizes="180x180">
    
  
  <!-- title -->
  <title>Shio&#39;s Psycology Life Vue源码探究-虚拟DOM的渲染 </title>
  <!-- styles -->
  <!-- styles -->

<link rel="stylesheet" href="/styles/global.css">

  <!-- rss -->
  
  <link rel="alternate" href="/atom.xml" title="Shio&#39;s Psycology Life" type="application/atom+xml" />
  
<meta name="generator" content="Hexo 4.2.1"></head>
  <body>
    <header id="header">
  
  <nav class="menu menu--right">
  
    <a class="menu__item" href="/">主页</a>
    <a class="menu__item" href="/archives/">归档</a>
    <a class="menu__item" href="/categories/">专题</a>
    <a class="menu__item" href="/tags/">标签</a>
    <!-- <a class="menu__item" href="/">作品</a> -->
    <!-- <a class="menu__item" href="/about/">关于</a> -->
  </nav>
</header>
    <main>
      <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post__header">
  <h1 class="post__title">Vue源码探究-虚拟DOM的渲染</h1>
  
  
  <div class="post__meta">
    
<time class="post__date" datetime="2018-08-27T07:06:16.000Z" itemprop="datePublished">
  
  <i class="blogfont">&#xedff;</i>
  
  2018-08-27 15:06:16
</time>

    
<div class="post__category">
  <i class="blogfont">&#xe62d;</i>
  <a class="category-link" href="/categories/Dev/">Dev</a>, <a class="category-link" href="/categories/Dev/Explore-Vue/">Explore Vue</a>
</div>
  

    
<div class="post__tag">
  <i class="blogfont">&#xe7ec;</i>
  <a class="tag-link" href="/tags/Vue/" rel="tag">Vue</a>
</div>


    <div id="/2018-08-27/vue-render-of-vnode/" class="leancloud_visitors post__stat" data-flag-title="Vue源码探究-虚拟DOM的渲染">
  <i class="blogfont">&#xe672;</i>
  <span class="leancloud-visitors-count">loading...</span>
</div>
  </div>
</header>
  <aside class="post__aside">
  <div class="post__actions">
    <a id="backTop" class="post__top" href="javascript:">
      <i class="blogfont">&#xe6b1;</i><!-- 回到顶部 -->
    </a>
    <!-- <a id="share" class="post__share" href="javascript:">
      <i class="blogfont">&#xe6c1;</i>
    </a> -->
  </div>
  <ol class="post__toc"><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#渲染的初始化"><span class="post__toc-text">渲染的初始化</span></a><ol class="post__toc-child"><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#相关属性初始化"><span class="post__toc-text">相关属性初始化</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#挂载方法初始化"><span class="post__toc-text">挂载方法初始化</span></a></li></ol></li><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#mount-路径的具体实现"><span class="post__toc-text">mount 路径的具体实现</span></a><ol class="post__toc-child"><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#mountComponent"><span class="post__toc-text">mountComponent</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#updateComponent"><span class="post__toc-text">updateComponent</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#render"><span class="post__toc-text">_render</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#update"><span class="post__toc-text">_update</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#patch"><span class="post__toc-text">patch</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#createElm"><span class="post__toc-text">createElm</span></a></li></ol></li><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#update-路径的具体实现"><span class="post__toc-text">update 路径的具体实现</span></a><ol class="post__toc-child"><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#patchVnode"><span class="post__toc-text">patchVnode</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#updateChildren"><span class="post__toc-text">updateChildren</span></a></li></ol></li></ol>
</aside>
  <div class="post__content" itemprop="articleBody">
    <p>在<a href="https://jylzs369.github.io/2018/08/16/vue-implement-of-vnode/" target="_blank" rel="noopener">虚拟节点的实现</a>一篇中，除了知道了 <code>VNode</code> 类的实现之外，还简要地整理了一下DOM渲染的路径。在这一篇中，主要来分析一下两条路径的具体实现代码。</p>
<p>按照创建 <code>Vue</code> 实例后的一般执行流程，首先来看看实例初始化时对渲染模块的初始处理。这也是开始 <code>mount</code> 路径的前一步。初始包括两部分，一是向 <code>Vue</code> 类原型对象上挂载渲染相关的方法，而是初始化渲染相关的属性。</p>
<h2 id="渲染的初始化"><a href="#渲染的初始化" class="headerlink" title="渲染的初始化"></a>渲染的初始化</h2><p><em>下面代码位于<a href="https://github.com/vuejs/vue/blob/v2.5.17-beta.0/src/core/instance/render.js" target="_blank" rel="noopener">vue/src/core/instance/render.js</a></em></p>
<h3 id="相关属性初始化"><a href="#相关属性初始化" class="headerlink" title="相关属性初始化"></a>相关属性初始化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义并导出initRender函数，接受vm</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initRender</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化实例的根虚拟节点</span></span><br><span class="line">  vm._vnode = <span class="literal">null</span> <span class="comment">// the root of the child tree</span></span><br><span class="line">  <span class="comment">// 定义实例的静态树节点</span></span><br><span class="line">  vm._staticTrees = <span class="literal">null</span> <span class="comment">// v-once cached trees</span></span><br><span class="line">  <span class="comment">// 获取配置对象</span></span><br><span class="line">  <span class="keyword">const</span> options = vm.$options</span><br><span class="line">  <span class="comment">// 设置父占位符节点</span></span><br><span class="line">  <span class="keyword">const</span> parentVnode = vm.$vnode = options._parentVnode <span class="comment">// the placeholder node in parent tree</span></span><br><span class="line">  <span class="comment">// renderContext存储父节点有无声明上下文</span></span><br><span class="line">  <span class="keyword">const</span> renderContext = parentVnode &amp;&amp; parentVnode.context</span><br><span class="line">  <span class="comment">// 将子虚拟节点转换成格式化的对象结构存储在实例的$slots属性</span></span><br><span class="line">  vm.$slots = resolveSlots(options._renderChildren, renderContext)</span><br><span class="line">  <span class="comment">// 初始化$scopedSlots属性为空对象</span></span><br><span class="line">  vm.$scopedSlots = emptyObject</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为实例绑定渲染虚拟节点函数_c和$createElement</span></span><br><span class="line">  <span class="comment">// 内部实际调用createElement函数，并获得恰当的渲染上下文</span></span><br><span class="line">  <span class="comment">// 参数按顺序分别是：标签、数据、子节点、标准化类型、是否标准化标识</span></span><br><span class="line">  <span class="comment">// bind the createElement fn to this instance</span></span><br><span class="line">  <span class="comment">// so that we get proper render context inside it.</span></span><br><span class="line">  <span class="comment">// args order: tag, data, children, normalizationType, alwaysNormalize</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 内部版本_c被从模板编译的渲染函数使用</span></span><br><span class="line">  <span class="comment">// internal version is used by render functions compiled from templates</span></span><br><span class="line">  vm._c = <span class="function">(<span class="params">a, b, c, d</span>) =&gt;</span> createElement(vm, a, b, c, d, <span class="literal">false</span>)</span><br><span class="line">  <span class="comment">// 用户写的渲染函数会总是应用执行标准化的公共版本</span></span><br><span class="line">  <span class="comment">// normalization is always applied for the public version, used in</span></span><br><span class="line">  <span class="comment">// user-written render functions.</span></span><br><span class="line">  vm.$createElement = <span class="function">(<span class="params">a, b, c, d</span>) =&gt;</span> createElement(vm, a, b, c, d, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为了更容易创建高阶组件，暴露了$attrs 和 $listeners</span></span><br><span class="line">  <span class="comment">// 并且需要保持属性的响应性以便能够实现更新，以下是对属性的响应处理</span></span><br><span class="line">  <span class="comment">// $attrs &amp; $listeners are exposed for easier HOC creation.</span></span><br><span class="line">  <span class="comment">// they need to be reactive so that HOCs using them are always updated</span></span><br><span class="line">  <span class="keyword">const</span> parentData = parentVnode &amp;&amp; parentVnode.data</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对属性和事件监听器进行响应处理，建立观察状态</span></span><br><span class="line">  <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    <span class="comment">// 在非生产环境时检测是否属于可读并发出警告</span></span><br><span class="line">    defineReactive(vm, <span class="string">'$attrs'</span>, parentData &amp;&amp; parentData.attrs || emptyObject, () =&gt; &#123;</span><br><span class="line">      !isUpdatingChildComponent &amp;&amp; warn(<span class="string">`$attrs is readonly.`</span>, vm)</span><br><span class="line">    &#125;, <span class="literal">true</span>)</span><br><span class="line">    defineReactive(vm, <span class="string">'$listeners'</span>, options._parentListeners || emptyObject, () =&gt; &#123;</span><br><span class="line">      !isUpdatingChildComponent &amp;&amp; warn(<span class="string">`$listeners is readonly.`</span>,  vm)</span><br><span class="line">    &#125;, <span class="literal">true</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    defineReactive(vm, <span class="string">'$attrs'</span>, parentData &amp;&amp; parentData.attrs || emptyObject, <span class="literal">null</span>, <span class="literal">true</span>)</span><br><span class="line">    defineReactive(vm, <span class="string">'$listeners'</span>, options._parentListeners || emptyObject, <span class="literal">null</span>, <span class="literal">true</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>initRender</code> 函数为实例进行了初始化处理，主要有三件事：</p>
<ul>
<li>初始化相关属性</li>
<li>设置绑定了上下文的生成虚拟节点的私有和共有版函数</li>
<li>对节点的属性和事件监听器进行状态观察</li>
</ul>
<p>生成虚拟节点函数主要会在流程中的 <code>render</code> 函数中使用。对节点属性和事件监听器的响应处理保证了在生命周期过程中节点属性和事件状态的更新。</p>
<h3 id="挂载方法初始化"><a href="#挂载方法初始化" class="headerlink" title="挂载方法初始化"></a>挂载方法初始化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出renderMixin函数，接收形参Vue，</span></span><br><span class="line"><span class="comment">// 使用Flow进行静态类型检查指定为Component类</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">renderMixin</span> (<span class="params">Vue: Class&lt;Component&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 为Vue原型对象绑定运行时相关的辅助方法</span></span><br><span class="line">  <span class="comment">// install runtime convenience helpers</span></span><br><span class="line">  installRenderHelpers(Vue.prototype)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 挂载Vue原型对象的$nextTick方法，接收函数类型的fn形参</span></span><br><span class="line">  Vue.prototype.$nextTick = <span class="function"><span class="keyword">function</span> (<span class="params">fn: Function</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 返回nextTick函数的执行结果</span></span><br><span class="line">    <span class="keyword">return</span> nextTick(fn, <span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 挂载Vue原型对象的_render方法，期望返回虚拟节点对象</span></span><br><span class="line">  <span class="comment">// _render方法即是根据配置对象在内部生成虚拟节点的方法</span></span><br><span class="line">  Vue.prototype._render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>): <span class="title">VNode</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将实例赋值给vm变量</span></span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// 导入vm的$options对象的render方法和_parentVnode对象</span></span><br><span class="line">    <span class="keyword">const</span> &#123; render, _parentVnode &#125; = vm.$options</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非生产环境下重置插槽上的_rendered标志以进行重复插槽检查</span></span><br><span class="line">    <span class="comment">// reset _rendered flag on slots for duplicate slot check</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> vm.$slots) &#123;</span><br><span class="line">        <span class="comment">// $flow-disable-line</span></span><br><span class="line">        vm.$slots[key]._rendered = <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有父级虚拟节点，定义并赋值实例的$scopedSlots属性</span></span><br><span class="line">    <span class="keyword">if</span> (_parentVnode) &#123;</span><br><span class="line">      vm.$scopedSlots = _parentVnode.data.scopedSlots || emptyObject</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置实例的父虚拟节点，允许render函数访问占位符节点的数据</span></span><br><span class="line">    <span class="comment">// set parent vnode. this allows render functions to have access</span></span><br><span class="line">    <span class="comment">// to the data on the placeholder node.</span></span><br><span class="line">    vm.$vnode = _parentVnode</span><br><span class="line">    <span class="comment">// 定义渲染节点</span></span><br><span class="line">    <span class="comment">// render self</span></span><br><span class="line">    <span class="keyword">let</span> vnode</span><br><span class="line">    <span class="comment">// 在实例的渲染代理对象上调用render方法，并传入$createElement参数</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      vnode = render.call(vm._renderProxy, vm.$createElement)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="comment">// 处理错误</span></span><br><span class="line">      handleError(e, vm, <span class="string">`render`</span>)</span><br><span class="line">      <span class="comment">// 返回错误渲染结果或者前一虚拟节点，防止渲染错误导致的空白组件</span></span><br><span class="line">      <span class="comment">// return error render result,</span></span><br><span class="line">      <span class="comment">// or previous vnode to prevent render error causing blank component</span></span><br><span class="line">      <span class="comment">// 非生产环境特殊处理渲染错误</span></span><br><span class="line">      <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vm.$options.renderError) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            handleError(e, vm, <span class="string">`renderError`</span>)</span><br><span class="line">            vnode = vm._vnode</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          vnode = vm._vnode</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vnode = vm._vnode</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在渲染函数出错时返回空虚拟节点</span></span><br><span class="line">    <span class="comment">// return empty vnode in case the render function errored out</span></span><br><span class="line">    <span class="keyword">if</span> (!(vnode <span class="keyword">instanceof</span> VNode)) &#123;</span><br><span class="line">      <span class="comment">// 非生产环境报错</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; <span class="built_in">Array</span>.isArray(vnode)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">'Multiple root nodes returned from render function. Render function '</span> +</span><br><span class="line">          <span class="string">'should return a single root node.'</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 创建空的虚拟节点</span></span><br><span class="line">      vnode = createEmptyVNode()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置父虚拟节点</span></span><br><span class="line">    <span class="comment">// set parent</span></span><br><span class="line">    vnode.parent = _parentVnode</span><br><span class="line">    <span class="comment">// 返回虚拟节点</span></span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染模块挂载了两个方法 <code>$nextTick</code> 公共方法和 <code>_render</code> 私有方法<code>$nextTick</code> 是实例的公有方法，这个很常见，就不多说；<code>_render</code> 是内部用来生成 <code>VNode</code> 的方法，内部调用了 <code>initRender</code> 函数中绑定的 <code>createElement</code> 函数，初始化实例一般会调用实例的公共版方法，如果是创建组件则会调用私有版方法。</p>
<p>另 <code>renderMixin</code> 函数在执行时还为Vue实例绑定了一些处理渲染的工具函数，具体可查看<a href="https://github.com/vuejs/vue/blob/v2.5.17-beta.0dev/src/core/instance/render-helpers/" target="_blank" rel="noopener">源代码</a>。</p>
<h2 id="mount-路径的具体实现"><a href="#mount-路径的具体实现" class="headerlink" title="mount 路径的具体实现"></a><code>mount</code> 路径的具体实现</h2><p>按照创建Vue实例的一般流程，初始化处理好之后，最后一步执行的 <code>vm.$mount(vm.$options.el)</code> 就宣告 <code>mount</code> 渲染路径的开始。记得好像还没有见过 <code>$mount</code> 的定义，因为这个函数是在运行时挂在到原型对象上的，web端的源代码在 <a href="https://github.com/vuejs/vue/blob/v2.5.17-beta.0/src/platforms/web/runtime/index.js" target="_blank" rel="noopener">platforms/web</a> 中，同样要值得注意的是原型的 <code>__patch__</code> 方法也是在运行时定义的。代码片段如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// install platform patch function</span></span><br><span class="line">Vue.prototype.__patch__ = inBrowser ? patch : noop</span><br><span class="line"></span><br><span class="line"><span class="comment">// public mount method</span></span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  el?: string | Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  el = el &amp;&amp; inBrowser ? query(el) : <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">return</span> mountComponent(<span class="keyword">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然这两个方法都是在运行时才定义，但各自都是引用了核心代码中定义的实际实现函数：<code>mountComponent</code> 和 <code>patch</code>，下面就按照执行的流程一步步来解析这些实现渲染功能的函数。</p>
<h3 id="mountComponent"><a href="#mountComponent" class="headerlink" title="mountComponent"></a><code>mountComponent</code></h3><p>源代码位于<a href="https://github.com/vuejs/vue/blob/v2.5.17-beta.0/src/core/instance/lifecycle.js" target="_blank" rel="noopener">core/instance/lifecycle.js</a>中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义并导出mountComponent函数</span></span><br><span class="line"><span class="comment">// 接受Vue实例vm，DOM元素el、布尔标识hydrating参数</span></span><br><span class="line"><span class="comment">// 后两参数可选，返回组件实例</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vm: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  el: ?Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 设置实例的$el属性</span></span><br><span class="line">  vm.$el = el</span><br><span class="line">  <span class="comment">// 检测实例属性$options对象的render方法，未定义则设置为创建空节点</span></span><br><span class="line">  <span class="keyword">if</span> (!vm.$options.render) &#123;</span><br><span class="line">    vm.$options.render = createEmptyVNode</span><br><span class="line">    <span class="comment">// 非生产环境检测构建版本并警告</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> ((vm.$options.template &amp;&amp; vm.$options.template.charAt(<span class="number">0</span>) !== <span class="string">'#'</span>) ||</span><br><span class="line">        vm.$options.el || el) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">'You are using the runtime-only build of Vue where the template '</span> +</span><br><span class="line">          <span class="string">'compiler is not available. Either pre-compile the templates into '</span> +</span><br><span class="line">          <span class="string">'render functions, or use the compiler-included build.'</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">'Failed to mount component: template or render function not defined.'</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 调用生命周期钩子函数beforeMount，准备首次加载</span></span><br><span class="line">  callHook(vm, <span class="string">'beforeMount'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义updateComponent方法</span></span><br><span class="line">  <span class="keyword">let</span> updateComponent</span><br><span class="line">  <span class="comment">// 非生产环境加入性能评估</span></span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">    updateComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> name = vm._name</span><br><span class="line">      <span class="keyword">const</span> id = vm._uid</span><br><span class="line">      <span class="keyword">const</span> startTag = <span class="string">`vue-perf-start:<span class="subst">$&#123;id&#125;</span>`</span></span><br><span class="line">      <span class="keyword">const</span> endTag = <span class="string">`vue-perf-end:<span class="subst">$&#123;id&#125;</span>`</span></span><br><span class="line"></span><br><span class="line">      mark(startTag)</span><br><span class="line">      <span class="keyword">const</span> vnode = vm._render()</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(<span class="string">`vue <span class="subst">$&#123;name&#125;</span> render`</span>, startTag, endTag)</span><br><span class="line"></span><br><span class="line">      mark(startTag)</span><br><span class="line">      vm._update(vnode, hydrating)</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(<span class="string">`vue <span class="subst">$&#123;name&#125;</span> patch`</span>, startTag, endTag)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 定义updateComponent内部调用实例的_update方法</span></span><br><span class="line">    <span class="comment">// 参数为按实例状态生成的新虚拟节点树和hydrating标识</span></span><br><span class="line">    updateComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      vm._update(vm._render(), hydrating)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在Watcher类内部将此监听器设置到实例的_watcher上。</span></span><br><span class="line">  <span class="comment">// 由于初次patch可能调用$forceUpdate方法（例如在子组件的mounted钩子），</span></span><br><span class="line">  <span class="comment">// 这依赖于已经定义好的vm._watcher</span></span><br><span class="line">  <span class="comment">// we set this to vm._watcher inside the watcher's constructor</span></span><br><span class="line">  <span class="comment">// since the watcher's initial patch may call $forceUpdate (e.g. inside child</span></span><br><span class="line">  <span class="comment">// component's mounted hook), which relies on vm._watcher being already defined</span></span><br><span class="line">  <span class="comment">// 建立对渲染的观察，最末参数声明为渲染监听器，并传入监视器的before方法，</span></span><br><span class="line">  <span class="comment">// 在初次渲染之后，实例的_isMounted为true，在每次渲染更新之前会调用update钩子</span></span><br><span class="line">  <span class="keyword">new</span> Watcher(vm, updateComponent, noop, &#123;</span><br><span class="line">    before () &#123;</span><br><span class="line">      <span class="keyword">if</span> (vm._isMounted) &#123;</span><br><span class="line">        callHook(vm, <span class="string">'beforeUpdate'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>)</span><br><span class="line">  <span class="comment">// 设置hydrating标识为false</span></span><br><span class="line">  hydrating = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 手动安装的实例，mounted调用挂载在自身</span></span><br><span class="line">  <span class="comment">// 渲染创建的子组件在其插入的钩子中调用了mounted</span></span><br><span class="line">  <span class="comment">// manually mounted instance, call mounted on self</span></span><br><span class="line">  <span class="comment">// mounted is called for render-created child components in its inserted hook</span></span><br><span class="line">  <span class="comment">// vm.$vnode为空设置_isMounted属性为true，并调用mounted钩子</span></span><br><span class="line">  <span class="comment">// vm.$vnode为空是因为实例是根组件，没有父级节点。</span></span><br><span class="line">  <span class="keyword">if</span> (vm.$vnode == <span class="literal">null</span>) &#123;</span><br><span class="line">    vm._isMounted = <span class="literal">true</span></span><br><span class="line">    callHook(vm, <span class="string">'mounted'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回实例</span></span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="updateComponent"><a href="#updateComponent" class="headerlink" title="updateComponent"></a><code>updateComponent</code></h3><p><code>updateComponent</code> 函数在上一流程中定义，在执行过程中传入为待观察属性创建的监视器中，并在首次渲染时被调用。可以在上述代码中看出，其内部是执行了实例的 <code>_update</code> 方法，并传入实例 <code>_render</code> 方法的执行结果和 <code>hydrating</code> 参数，<code>hydrating</code> 似乎是与服务器端渲染有关的标识属性，暂时不太清楚具体的作用。</p>
<h3 id="render"><a href="#render" class="headerlink" title="_render"></a><code>_render</code></h3><p>在文首的 <code>renderMixin</code> 函数中定义，返回虚拟节点作为传入下一流程 <code>_update</code> 的第一个参数。</p>
<h3 id="update"><a href="#update" class="headerlink" title="_update"></a><code>_update</code></h3><p>在前文<a href="Vue源码探究-生命周期.md">生命周期</a>中的 <code>lifecycleMixin</code> 函数中定义，正是在这个方法中，发生了执行路径的分流，在 <code>mount</code> 路径中，执行首次渲染分支，将挂载的DOM元素和 <code>_render</code> 首次生成的虚拟节点传入 <code>patch</code> 函数中。</p>
<h3 id="patch"><a href="#patch" class="headerlink" title="patch"></a><code>patch</code></h3><p><code>patch</code> 方法定义在 <a href="https://github.com/vuejs/vue/blob/v2.5.17-beta.0/src/platforms/web/runtime/patch.js" target="_blank" rel="noopener">platforms/web/runtime/patch.js</a>中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> patch: <span class="built_in">Function</span> = createPatchFunction(&#123; nodeOps, modules &#125;)</span><br></pre></td></tr></table></figure>

<p>从最后一句代码可以看出，<code>patch</code> 得到的是 <code>createPatchFunction</code> 执行后内部返回的 <code>patch</code> 函数，传入的是平台特有的参数。在 <code>createPatchFunction</code> 函数执行过程中定义了一系列闭包函数来实现最终的DOM渲染，具体代码非常多，简单解释一下其内部定义的各种函数的用途，最后详细探索一下 <code>patch</code> 函数的具体实现。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义并导出createPatchFunction函数，接受backend参数</span></span><br><span class="line"><span class="comment">// backend参数是一个含有平台相关BOM操作的对象方法集</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createPatchFunction</span> (<span class="params">backend</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建空虚拟节点函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">emptyNodeAt</span> (<span class="params">elm</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建移除DOM节点回调</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">createRmCb</span> (<span class="params">childElm, listeners</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移除DOM节点</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">removeNode</span> (<span class="params">el</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否是未知元素</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">isUnknownElement</span> (<span class="params">vnode, inVPre</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建并插入DOM元素</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">createElm</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    vnode,</span></span></span><br><span class="line"><span class="function"><span class="params">    insertedVnodeQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">    parentElm,</span></span></span><br><span class="line"><span class="function"><span class="params">    refElm,</span></span></span><br><span class="line"><span class="function"><span class="params">    nested,</span></span></span><br><span class="line"><span class="function"><span class="params">    ownerArray,</span></span></span><br><span class="line"><span class="function"><span class="params">    index</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化组件</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">initComponent</span> (<span class="params">vnode, insertedVnodeQueue</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 激活组件</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reactivateComponent</span> (<span class="params">vnode, insertedVnodeQueue, parentElm, refElm</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插入DOM节点</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">insert</span> (<span class="params">parent, elm, ref</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建子DOM节点</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">createChildren</span> (<span class="params">vnode, children, insertedVnodeQueue</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断节点是否可对比更新</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">isPatchable</span> (<span class="params">vnode</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用创建钩子</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">invokeCreateHooks</span> (<span class="params">vnode, insertedVnodeQueue</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为组件作用域CSS设置范围id属性。</span></span><br><span class="line">  <span class="comment">// 这是作为一种特殊情况实现的，以避免通过正常的属性修补过程的开销。</span></span><br><span class="line">  <span class="comment">// set scope id attribute for scoped CSS.</span></span><br><span class="line">  <span class="comment">// this is implemented as a special case to avoid the overhead</span></span><br><span class="line">  <span class="comment">// of going through the normal attribute patching process.</span></span><br><span class="line">  <span class="comment">// 设置CSS作用域ID</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setScope</span> (<span class="params">vnode</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加虚拟节点，内部调用createElm</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">addVnodes</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用销毁钩子</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">invokeDestroyHook</span> (<span class="params">vnode</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移除虚拟节点，内部调用removeNode或removeAndInvokeRemoveHook</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">removeVnodes</span> (<span class="params">parentElm, vnodes, startIdx, endIdx</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用移除事件回调函数并移除节点</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">removeAndInvokeRemoveHook</span> (<span class="params">vnode, rm</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新子节点</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">updateChildren</span> (<span class="params">parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查重复key</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">checkDuplicateKeys</span> (<span class="params">children</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 寻找旧子节点索引</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">findIdxInOld</span> (<span class="params">node, oldCh, start, end</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对比并更新虚拟节点</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">patchVnode</span> (<span class="params">oldVnode, vnode, insertedVnodeQueue, removeOnly</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用插入钩子</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">invokeInsertHook</span> (<span class="params">vnode, queue, initial</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 渲染混合</span></span><br><span class="line">  <span class="comment">// 注意：这是一个仅限浏览器的函数，因此我们可以假设elms是DOM节点。</span></span><br><span class="line">  <span class="comment">// Note: this is a browser-only function so we can assume elms are DOM nodes.</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">hydrate</span> (<span class="params">elm, vnode, insertedVnodeQueue, inVPre</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断节点匹配</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">assertNodeMatch</span> (<span class="params">node, vnode, inVPre</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 节点补丁函数</span></span><br><span class="line">  <span class="comment">// 接受旧新虚拟节点，hydrating和removeOnly标识</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">patch</span> (<span class="params">oldVnode, vnode, hydrating, removeOnly</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果新虚拟节点未定义且存在旧节点，则调用销毁节点操作并返回</span></span><br><span class="line">    <span class="comment">// 这一步的判断是因为在旧虚拟节点存时，变动后没有生成新虚拟节点</span></span><br><span class="line">    <span class="comment">// 则说明新结构是不存在的，所以要清空旧节点。</span></span><br><span class="line">    <span class="keyword">if</span> (isUndef(vnode)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDef(oldVnode)) invokeDestroyHook(oldVnode)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化isInitialPatch标识和insertedVnodeQueue队列</span></span><br><span class="line">    <span class="keyword">let</span> isInitialPatch = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> insertedVnodeQueue = []</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下分两种情况构建节点：</span></span><br><span class="line">    <span class="comment">// 如果不存在旧虚拟节点</span></span><br><span class="line">    <span class="keyword">if</span> (isUndef(oldVnode)) &#123;</span><br><span class="line">      <span class="comment">// 空挂载（比如组件），会创建新的根元素</span></span><br><span class="line">      <span class="comment">// empty mount (likely as component), create new root element</span></span><br><span class="line">      <span class="comment">// 这种情况说明时首次渲染，设置isInitialPatch为true</span></span><br><span class="line">      isInitialPatch = <span class="literal">true</span></span><br><span class="line">      <span class="comment">// 根据虚拟节点创建新DOM节点</span></span><br><span class="line">      createElm(vnode, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 存在旧虚拟节点</span></span><br><span class="line">      <span class="comment">// 判断旧虚拟节点是否是真实的DOM元素</span></span><br><span class="line">      <span class="keyword">const</span> isRealElement = isDef(oldVnode.nodeType)</span><br><span class="line">      <span class="comment">// 如果不是真实DOM节点并且新旧虚拟节点根节点相同</span></span><br><span class="line">      <span class="keyword">if</span> (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123;</span><br><span class="line">        <span class="comment">// 执行比较新旧节点更新DOM操作</span></span><br><span class="line">        <span class="comment">// patch existing root node</span></span><br><span class="line">        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 新旧节点不相同的情况</span></span><br><span class="line">        <span class="comment">// 旧节点是DOM元素时先将旧节点转换成虚拟节点</span></span><br><span class="line">        <span class="keyword">if</span> (isRealElement) &#123;</span><br><span class="line">          <span class="comment">// 挂在到真实DOM元素</span></span><br><span class="line">          <span class="comment">// 检查是否是服务器渲染，然后执行合并操作</span></span><br><span class="line">          <span class="comment">// mounting to a real element</span></span><br><span class="line">          <span class="comment">// check if this is server-rendered content and if we can perform</span></span><br><span class="line">          <span class="comment">// a successful hydration.</span></span><br><span class="line">          <span class="comment">// 下面这两个if语句里的操作都是服务器渲染相关，暂不去了解</span></span><br><span class="line">          <span class="keyword">if</span> (oldVnode.nodeType === <span class="number">1</span> &amp;&amp; oldVnode.hasAttribute(SSR_ATTR)) &#123;</span><br><span class="line">            oldVnode.removeAttribute(SSR_ATTR)</span><br><span class="line">            hydrating = <span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (isTrue(hydrating)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hydrate(oldVnode, vnode, insertedVnodeQueue)) &#123;</span><br><span class="line">              invokeInsertHook(vnode, insertedVnodeQueue, <span class="literal">true</span>)</span><br><span class="line">              <span class="keyword">return</span> oldVnode</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">              warn(</span><br><span class="line">                <span class="string">'The client-side rendered virtual DOM tree is not matching '</span> +</span><br><span class="line">                <span class="string">'server-rendered content. This is likely caused by incorrect '</span> +</span><br><span class="line">                <span class="string">'HTML markup, for example nesting block-level elements inside '</span> +</span><br><span class="line">                <span class="string">'&lt;p&gt;, or missing &lt;tbody&gt;. Bailing hydration and performing '</span> +</span><br><span class="line">                <span class="string">'full client-side render.'</span></span><br><span class="line">              )</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 如果不是服务器渲染或合并失败，生成空的虚拟节点</span></span><br><span class="line">          <span class="comment">// either not server-rendered, or hydration failed.</span></span><br><span class="line">          <span class="comment">// create an empty node and replace it</span></span><br><span class="line">          oldVnode = emptyNodeAt(oldVnode)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义旧元素oldElm和其父元素</span></span><br><span class="line">        <span class="comment">// replacing existing element</span></span><br><span class="line">        <span class="keyword">const</span> oldElm = oldVnode.elm</span><br><span class="line">        <span class="keyword">const</span> parentElm = nodeOps.parentNode(oldElm)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据新虚拟节点创建新DOM元素，并且会插入到DOM树中</span></span><br><span class="line">        <span class="comment">// create new node</span></span><br><span class="line">        createElm(</span><br><span class="line">          vnode,</span><br><span class="line">          insertedVnodeQueue,</span><br><span class="line">          <span class="comment">// 以下参数是#4590问题的解决处理</span></span><br><span class="line">          <span class="comment">// extremely rare edge case: do not insert if old element is in a</span></span><br><span class="line">          <span class="comment">// leaving transition. Only happens when combining transition +</span></span><br><span class="line">          <span class="comment">// keep-alive + HOCs. (#4590)</span></span><br><span class="line">          oldElm._leaveCb ? <span class="literal">null</span> : parentElm,</span><br><span class="line">          nodeOps.nextSibling(oldElm)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果新的虚拟节点有父级则以递归方式更新父占位符节点元素</span></span><br><span class="line">        <span class="comment">// cbs是在生成patch函数时初始化好的事件监听器</span></span><br><span class="line">        <span class="comment">// 在此条件中也会被逐一触发</span></span><br><span class="line">        <span class="comment">// update parent placeholder node element, recursively</span></span><br><span class="line">        <span class="keyword">if</span> (isDef(vnode.parent)) &#123;</span><br><span class="line">          <span class="keyword">let</span> ancestor = vnode.parent</span><br><span class="line">          <span class="keyword">const</span> patchable = isPatchable(vnode)</span><br><span class="line">          <span class="keyword">while</span> (ancestor) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cbs.destroy.length; ++i) &#123;</span><br><span class="line">              cbs.destroy[i](ancestor)</span><br><span class="line">            &#125;</span><br><span class="line">            ancestor.elm = vnode.elm</span><br><span class="line">            <span class="keyword">if</span> (patchable) &#123;</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cbs.create.length; ++i) &#123;</span><br><span class="line">                cbs.create[i](emptyNode, ancestor)</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// #6513</span></span><br><span class="line">              <span class="comment">// invoke insert hooks that may have been merged by create hooks.</span></span><br><span class="line">              <span class="comment">// e.g. for directives that uses the "inserted" hook.</span></span><br><span class="line">              <span class="keyword">const</span> insert = ancestor.data.hook.insert</span><br><span class="line">              <span class="keyword">if</span> (insert.merged) &#123;</span><br><span class="line">                <span class="comment">// start at index 1 to avoid re-invoking component mounted hook</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; insert.fns.length; i++) &#123;</span><br><span class="line">                  insert.fns[i]()</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              registerRef(ancestor)</span><br><span class="line">            &#125;</span><br><span class="line">            ancestor = ancestor.parent</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 销毁旧节点</span></span><br><span class="line">        <span class="comment">// destroy old node</span></span><br><span class="line">        <span class="comment">// 如果旧节点的父级元素存在，则从其上移除旧节点</span></span><br><span class="line">        <span class="keyword">if</span> (isDef(parentElm)) &#123;</span><br><span class="line">          removeVnodes(parentElm, [oldVnode], <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.tag)) &#123;</span><br><span class="line">          <span class="comment">// 否则视为不存在旧DOM节点，此时如果虚拟节点有标签名</span></span><br><span class="line">          <span class="comment">// 则调用旧虚拟节点销毁钩子</span></span><br><span class="line">          invokeDestroyHook(oldVnode)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后调用新节点的插入钩子</span></span><br><span class="line">    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)</span><br><span class="line">    <span class="comment">// 返回虚拟节点的真实DOM元素</span></span><br><span class="line">    <span class="keyword">return</span> vnode.elm</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>createPatchFunction</code> 函数内容非常多，但大多数函数都是辅助性的，与节点处理和回调函数钩子相关。大致上了解作用即可。</p>
<p><code>patch</code> 方法的执行首先分了两条路线：</p>
<ul>
<li>不存在旧虚拟节点直接创建新节点插入到DOM树，这是首次渲染的执行路径，这种情况简单。</li>
<li>存在旧虚拟节点时需进行对比再更新，这种情况比较复杂，其中又要分旧节点是否是真实DOM的情况，是虚拟节点并且与新生成虚拟节点相等（这里的相等是指同样的虚拟根节点，具体可参照sameVnode的代码查看条件）则直接进行对比更新；若是真实节点要先进行到虚拟节点的转换还有与服务器渲染相关的判断，然后再根据得到的结果创建新的DOM节点插入页面，最后还要分情况进行父节点的递归更新和移除旧节点。</li>
</ul>
<p><code>patch</code> 方法的实现方式是有迹可循的，在这源代码中，可以看出之前划分的 <code>mount</code> 和 <code>update</code> 的执行流程，但要注意的是，上述的条件判断划分的路线和逻辑上划分的流程是稍有区别的，<code>mount</code> 路径其实在代码里体现为 <code>!oldVnode</code> 和 <code>oldVnode</code> 路线中是真实DOM元素的情况，跨越了两个条件，主要体现在直接调用了 <code>createElm</code> 创建并插入新节点，这是因为在渲染时分为有无声明挂载的真实DOM元素两种情况。而 <code>update</code> 直接进入的是 <code>patchVnode</code> 对比操作。虽然有点绕但是需要分清楚这种区别。然而具体如何实现节点的创建和对比更新还是得继续往里层看，由于这一条路径是讲 <code>mount</code> 情况，所以往下先看看与之接续的 <code>createElm</code> 函数。</p>
<h3 id="createElm"><a href="#createElm" class="headerlink" title="createElm"></a><code>createElm</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义createElm函数，一系列参数主要记住vnode，parentElm</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElm</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vnode,</span></span></span><br><span class="line"><span class="function"><span class="params">  insertedVnodeQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">  parentElm,</span></span></span><br><span class="line"><span class="function"><span class="params">  refElm,</span></span></span><br><span class="line"><span class="function"><span class="params">  nested,</span></span></span><br><span class="line"><span class="function"><span class="params">  ownerArray,</span></span></span><br><span class="line"><span class="function"><span class="params">  index</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果新虚拟节点存在真实DOM元素和ownerArray，</span></span><br><span class="line">  <span class="comment">// 则代表它在之前的渲染中用过。</span></span><br><span class="line">  <span class="comment">// 现在要被用作新节点时有潜在的错误</span></span><br><span class="line">  <span class="comment">// 所以将它改为从本身克隆的节点</span></span><br><span class="line">  <span class="keyword">if</span> (isDef(vnode.elm) &amp;&amp; isDef(ownerArray)) &#123;</span><br><span class="line">    <span class="comment">// This vnode was used in a previous render!</span></span><br><span class="line">    <span class="comment">// now it's used as a new node, overwriting its elm would cause</span></span><br><span class="line">    <span class="comment">// potential patch errors down the road when it's used as an insertion</span></span><br><span class="line">    <span class="comment">// reference node. Instead, we clone the node on-demand before creating</span></span><br><span class="line">    <span class="comment">// associated DOM element for it.</span></span><br><span class="line">    vnode = ownerArray[index] = cloneVNode(vnode)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置isRootInsert，为检查过度动画入口</span></span><br><span class="line">  vnode.isRootInsert = !nested <span class="comment">// for transition enter check</span></span><br><span class="line">  <span class="comment">// 下面判断用于keep-alive组件，若是普通组件则会返回undefined继续往下执行</span></span><br><span class="line">  <span class="keyword">if</span> (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取虚拟节点信息、子节点和标签名称</span></span><br><span class="line">  <span class="keyword">const</span> data = vnode.data</span><br><span class="line">  <span class="keyword">const</span> children = vnode.children</span><br><span class="line">  <span class="keyword">const</span> tag = vnode.tag</span><br><span class="line">  <span class="comment">// 下面三种情况创建普通节点、注释节点和文字节点</span></span><br><span class="line">  <span class="keyword">if</span> (isDef(tag)) &#123;</span><br><span class="line">    <span class="comment">// 具有标签名称，则创建普通节点</span></span><br><span class="line">    <span class="comment">// 非生产环境简则是否是正确的元素</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (data &amp;&amp; data.pre) &#123;</span><br><span class="line">        creatingElmInVPre++</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isUnknownElement(vnode, creatingElmInVPre)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">'Unknown custom element: &lt;'</span> + tag + <span class="string">'&gt; - did you '</span> +</span><br><span class="line">          <span class="string">'register the component correctly? For recursive components, '</span> +</span><br><span class="line">          <span class="string">'make sure to provide the "name" option.'</span>,</span><br><span class="line">          vnode.context</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据ns属性选择创建节点的方式创建节点</span></span><br><span class="line">    vnode.elm = vnode.ns</span><br><span class="line">      ? nodeOps.createElementNS(vnode.ns, tag)</span><br><span class="line">      : nodeOps.createElement(tag, vnode)</span><br><span class="line">    <span class="comment">// 设置节点的作用域ID</span></span><br><span class="line">    setScope(vnode)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是weex平台，可以根据参数调整节点树插入DOM的具体实现</span></span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (__WEEX__) &#123;</span><br><span class="line">      <span class="comment">// in Weex, the default insertion order is parent-first.</span></span><br><span class="line">      <span class="comment">// List items can be optimized to use children-first insertion</span></span><br><span class="line">      <span class="comment">// with append="tree".</span></span><br><span class="line">      <span class="keyword">const</span> appendAsTree = isDef(data) &amp;&amp; isTrue(data.appendAsTree)</span><br><span class="line">      <span class="keyword">if</span> (!appendAsTree) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isDef(data)) &#123;</span><br><span class="line">          invokeCreateHooks(vnode, insertedVnodeQueue)</span><br><span class="line">        &#125;</span><br><span class="line">        insert(parentElm, vnode.elm, refElm)</span><br><span class="line">      &#125;</span><br><span class="line">      createChildren(vnode, children, insertedVnodeQueue)</span><br><span class="line">      <span class="keyword">if</span> (appendAsTree) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isDef(data)) &#123;</span><br><span class="line">          invokeCreateHooks(vnode, insertedVnodeQueue)</span><br><span class="line">        &#125;</span><br><span class="line">        insert(parentElm, vnode.elm, refElm)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// web平台则先创建子节点插入父级后再一次插入DOM中</span></span><br><span class="line">      createChildren(vnode, children, insertedVnodeQueue)</span><br><span class="line">      <span class="keyword">if</span> (isDef(data)) &#123;</span><br><span class="line">        invokeCreateHooks(vnode, insertedVnodeQueue)</span><br><span class="line">      &#125;</span><br><span class="line">      insert(parentElm, vnode.elm, refElm)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; data &amp;&amp; data.pre) &#123;</span><br><span class="line">      creatingElmInVPre--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isTrue(vnode.isComment)) &#123;</span><br><span class="line">    <span class="comment">// 如果是注释节点，则创建注释节点并插入到DOM中</span></span><br><span class="line">    vnode.elm = nodeOps.createComment(vnode.text)</span><br><span class="line">    insert(parentElm, vnode.elm, refElm)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是文字节点，则创建文字节点并插入到DOM</span></span><br><span class="line">    vnode.elm = nodeOps.createTextNode(vnode.text)</span><br><span class="line">    insert(parentElm, vnode.elm, refElm)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>createElm</code> 函数包含了节点的创建和插入两部分，创建了虚拟节点对应的DOM元素之后，就会调用 <code>insert</code> 方法将它插入到页面DOM结构中。创建功能在这里遵循DOM的三种节点类型，即元素、注释和文字节点，实际与插入和移除方法一样都是使用了对应的原生方法 ，<code>nodeops</code> 对象即是在返回 <code>patch</code> 函数时预先导入了的原生DOM操作方法的集合，具体可以在<a href="https://github.com/vuejs/vue/blob/v2.5.17-beta.0/src/platforms/web/runtime/node-ops.js" target="_blank" rel="noopener">运行时的处理</a>中确认。之前生成的 <code>vnode</code> 决定了最终应该生成何种节点，在这个函数中就能够发现，最终生成的真实DOM节点是多么依赖于 <code>vnode</code> 所携带的信息，所以说虚拟节点是实现生成真实DOM的基础。</p>
<p>这个流程中最后一步再调用 <code>removeVnodes</code> 方法移除掉DOM树中的旧节点，到此为止 <code>mount</code> 路径的执行就结束了。</p>
<h2 id="update-路径的具体实现"><a href="#update-路径的具体实现" class="headerlink" title="update 路径的具体实现"></a><code>update</code> 路径的具体实现</h2><p>根据 <code>update</code> 的执行流程，前一部分是由 <code>watcher</code> 来响应的，就不再讨论，然后进入 <code>updateComponent</code> 流程，直至返回 <code>patch</code> 函数都与 <code>mount</code> 流程的实现一致，只是要执行不同的分支，整个流程中只有最后一步生成真实DOM的过程有所区别，就是 <code>patchVnode</code> 函数的执行。上面已经说过 <code>update</code> 流程中最后是要对比新旧节点然后再实现更新，这个功能即由 <code>patchVnode</code> 来完成，它的内部调用 <code>updateChildren</code> 来完成对比，实现逻辑非常有借鉴性，值得玩味。下面来看看这两个函数，</p>
<h3 id="patchVnode"><a href="#patchVnode" class="headerlink" title="patchVnode"></a>patchVnode</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义patchVnode函数，接收四个参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchVnode</span> (<span class="params">oldVnode, vnode, insertedVnodeQueue, removeOnly</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果新旧虚拟节点相同则结束对比</span></span><br><span class="line">  <span class="keyword">if</span> (oldVnode === vnode) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取并设置新虚拟节点的真实DOM元素</span></span><br><span class="line">  <span class="keyword">const</span> elm = vnode.elm = oldVnode.elm</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异步占位符节点的特殊处理</span></span><br><span class="line">  <span class="keyword">if</span> (isTrue(oldVnode.isAsyncPlaceholder)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDef(vnode.asyncFactory.resolved)) &#123;</span><br><span class="line">      hydrate(oldVnode.elm, vnode, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vnode.isAsyncPlaceholder = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为静态树重用元素</span></span><br><span class="line">  <span class="comment">// 只在克隆虚拟节点时使用，如非克隆节点则需要重新渲染</span></span><br><span class="line">  <span class="comment">// reuse element for static trees.</span></span><br><span class="line">  <span class="comment">// note we only do this if the vnode is cloned -</span></span><br><span class="line">  <span class="comment">// if the new node is not cloned it means the render functions have been</span></span><br><span class="line">  <span class="comment">// reset by the hot-reload-api and we need to do a proper re-render.</span></span><br><span class="line">  <span class="keyword">if</span> (isTrue(vnode.isStatic) &amp;&amp;</span><br><span class="line">    isTrue(oldVnode.isStatic) &amp;&amp;</span><br><span class="line">    vnode.key === oldVnode.key &amp;&amp;</span><br><span class="line">    (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))</span><br><span class="line">  ) &#123;</span><br><span class="line">    vnode.componentInstance = oldVnode.componentInstance</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果存在内联预处理钩子则调用</span></span><br><span class="line">  <span class="keyword">let</span> i</span><br><span class="line">  <span class="keyword">const</span> data = vnode.data</span><br><span class="line">  <span class="keyword">if</span> (isDef(data) &amp;&amp; isDef(i = data.hook) &amp;&amp; isDef(i = i.prepatch)) &#123;</span><br><span class="line">    i(oldVnode, vnode)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面是对一般情况的DOM更新处理</span></span><br><span class="line">  <span class="comment">// 获取虚拟节点子节点</span></span><br><span class="line">  <span class="keyword">const</span> oldCh = oldVnode.children</span><br><span class="line">  <span class="keyword">const</span> ch = vnode.children</span><br><span class="line">  <span class="comment">// 如果存在更新钩子则调用</span></span><br><span class="line">  <span class="keyword">if</span> (isDef(data) &amp;&amp; isPatchable(vnode)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode)</span><br><span class="line">    <span class="keyword">if</span> (isDef(i = data.hook) &amp;&amp; isDef(i = i.update)) i(oldVnode, vnode)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当新虚拟节点不存在text属性值，即不是文字节点时</span></span><br><span class="line">  <span class="keyword">if</span> (isUndef(vnode.text)) &#123;</span><br><span class="line">    <span class="comment">// 情况一：新旧虚拟节点子节点都存在时</span></span><br><span class="line">    <span class="keyword">if</span> (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</span><br><span class="line">      <span class="comment">// 不相等则更新子节点树</span></span><br><span class="line">      <span class="keyword">if</span> (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(ch)) &#123;</span><br><span class="line">      <span class="comment">// 情况二，只有新虚拟节点子节点存在，</span></span><br><span class="line">      <span class="comment">// 旧虚拟节点是文字节点，先置空元素文本内容</span></span><br><span class="line">      <span class="keyword">if</span> (isDef(oldVnode.text)) nodeOps.setTextContent(elm, <span class="string">''</span>)</span><br><span class="line">      <span class="comment">// 再向DOM元素插入新虚拟节点内容</span></span><br><span class="line">      addVnodes(elm, <span class="literal">null</span>, ch, <span class="number">0</span>, ch.length - <span class="number">1</span>, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldCh)) &#123;</span><br><span class="line">      <span class="comment">// 情况三，只有旧虚拟节点子节点存在，则移除DOM元素内容</span></span><br><span class="line">      removeVnodes(elm, oldCh, <span class="number">0</span>, oldCh.length - <span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.text)) &#123;</span><br><span class="line">      <span class="comment">// 情况四，新旧虚拟节点子节点不存在且旧虚拟节点是文字节点</span></span><br><span class="line">      <span class="comment">// 置空DOM元素文本内容</span></span><br><span class="line">      nodeOps.setTextContent(elm, <span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldVnode.text !== vnode.text) &#123;</span><br><span class="line">    <span class="comment">// 新虚拟节点是文字节点时，除非旧节点也是文字节点且内容相等</span></span><br><span class="line">    <span class="comment">// 直接将新文本内容设置到DOM元素中</span></span><br><span class="line">    nodeOps.setTextContent(elm, vnode.text)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果存在后处理钩子则调用</span></span><br><span class="line">  <span class="keyword">if</span> (isDef(data)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDef(i = data.hook) &amp;&amp; isDef(i = i.postpatch)) i(oldVnode, vnode)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>patchVnode</code> 的内容主要有三点，第一是处理异步虚拟节点；第二是处理静态可重用元素；第三是处理一般情况下的新旧节点更新。</p>
<p>一般情况下的新旧节点更新首先是按照新虚拟节点是否文字节点来分情况，因为DOM的更新决定权在于新的虚拟节点内容，如果是新节点是文字节点，则可以不用在意旧节点的情况，除非旧节点也是文本内容且内容无异时不需要处理，其他情况下都直接为DOM元素内容重置为新虚拟节点的文本。如果新节点不是文字节点，处理会再细分为四种情况：第一是新旧虚拟子节点都存在且不相等时，执行patch核心的更新操作 <code>updateChildren</code>。第二是只有新子节点存在而旧子节点不存在，如果旧节点是文字节点，先要置空就节点的文本内容，再向DOM元素添加新字节点的内容。第三是只有旧子节点存在而新子节点不存在时，说明更新后没有节点了，执行移除操作。第四是新旧子节点不存在而旧节点是文字节点时，清空DOM元素的文本内容。</p>
<p>这里要十分注意理清虚拟节点和其子节点的比较。只有当新旧虚拟节点与其各自子虚拟节点都存储的是元素节点时，才需要调用 <code>updateChildren</code> 函数来进行深入比较，其他的情况都可以比较简便的处理DOM节点的更新，这也避免了不必要的处理提高了渲染的性能。</p>
<p>最后来看看整个DOM节点对比更新的核心逻辑函数：</p>
<h3 id="updateChildren"><a href="#updateChildren" class="headerlink" title="updateChildren"></a>updateChildren</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义updateChildren函数，接受5个参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateChildren</span> (<span class="params">parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化逻辑需要的变量，由于此函数仅针对子节点，所以以下省略“子”字</span></span><br><span class="line">  <span class="keyword">let</span> oldStartIdx = <span class="number">0</span> <span class="comment">// 旧节点开始索引</span></span><br><span class="line">  <span class="keyword">let</span> newStartIdx = <span class="number">0</span> <span class="comment">// 新节点开始索引</span></span><br><span class="line">  <span class="keyword">let</span> oldEndIdx = oldCh.length - <span class="number">1</span> <span class="comment">// 旧节点结束索引</span></span><br><span class="line">  <span class="keyword">let</span> oldStartVnode = oldCh[<span class="number">0</span>] <span class="comment">// 当前旧首节点</span></span><br><span class="line">  <span class="keyword">let</span> oldEndVnode = oldCh[oldEndIdx] <span class="comment">// 当前旧尾节点</span></span><br><span class="line">  <span class="keyword">let</span> newEndIdx = newCh.length - <span class="number">1</span> <span class="comment">// 新节点结束索引</span></span><br><span class="line">  <span class="keyword">let</span> newStartVnode = newCh[<span class="number">0</span>] <span class="comment">// 当前新首节点</span></span><br><span class="line">  <span class="keyword">let</span> newEndVnode = newCh[newEndIdx] <span class="comment">// 当前新尾节点</span></span><br><span class="line">  <span class="keyword">let</span> oldKeyToIdx, idxInOld, vnodeToMove, refElm</span><br><span class="line"></span><br><span class="line">  <span class="comment">// removeOnly是仅用于&lt;transition-group&gt;情况下的特殊标识，</span></span><br><span class="line">  <span class="comment">// 确保移除的元素在离开过渡期间保持在正确的相对位置。</span></span><br><span class="line">  <span class="comment">// removeOnly is a special flag used only by &lt;transition-group&gt;</span></span><br><span class="line">  <span class="comment">// to ensure removed elements stay in correct relative positions</span></span><br><span class="line">  <span class="comment">// during leaving transitions</span></span><br><span class="line">  <span class="keyword">const</span> canMove = !removeOnly</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查新节点中有无重复key</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    checkDuplicateKeys(newCh)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以增加索引值模拟移动指针，逐一对比对应索引位置的节点</span></span><br><span class="line">  <span class="comment">// 循环仅在在新旧开始索引同时小于各自结束索引时才继续进行</span></span><br><span class="line">  <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="comment">// 对比具体分为7种情况：</span></span><br><span class="line">    <span class="keyword">if</span> (isUndef(oldStartVnode)) &#123;</span><br><span class="line">      <span class="comment">// 当前旧首节点不存在时，递增旧开始索引指向后一节点</span></span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx] <span class="comment">// Vnode has been moved left</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isUndef(oldEndVnode)) &#123;</span><br><span class="line">      <span class="comment">// 当前旧尾节点不存在时，递减旧结束索引指向前一节点</span></span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">      <span class="comment">// 当前新旧首节点相同，递归调用patchVnode对比子级</span></span><br><span class="line">      patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)</span><br><span class="line">      <span class="comment">// 递增新旧开始索引，当前新旧节点指向各自后一节点</span></span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">      <span class="comment">// 当前新旧尾节点相同，递归调用patchVnode对比子级</span></span><br><span class="line">      patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)</span><br><span class="line">      <span class="comment">// 递减新旧结束索引，当前新旧尾节点指向前一节点</span></span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">      newEndVnode = newCh[--newEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; <span class="comment">// Vnode moved right</span></span><br><span class="line">      <span class="comment">// 当前旧首节点与当前新尾节点相同，递归调用patchVnode对比</span></span><br><span class="line">      patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)</span><br><span class="line">      <span class="comment">// canMove为真则将当前旧首节点移动到下一兄弟节点前</span></span><br><span class="line">      canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br><span class="line">      <span class="comment">// 递增就开始索引，当前旧首节点指向后一节点</span></span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">      <span class="comment">// 递减新结束索引，当前新尾节点指向前一节点</span></span><br><span class="line">      newEndVnode = newCh[--newEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; <span class="comment">// Vnode moved left</span></span><br><span class="line">      <span class="comment">// 当前旧尾节点与当前新首节点相同，调用patchVnode</span></span><br><span class="line">      patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)</span><br><span class="line">      <span class="comment">// canMove为真则将当前旧尾节点移动到当前旧首节点前</span></span><br><span class="line">      canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)</span><br><span class="line">      <span class="comment">// 递减旧节点结束索引，当前旧尾节点指向前一节点</span></span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">      <span class="comment">// 递增新节点开始索引，当前新首节点指向后一节点</span></span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 其他情况下</span></span><br><span class="line">      <span class="comment">// oldKeyToIdx未定义时根据旧节点创建key和索引键值对集合</span></span><br><span class="line">      <span class="keyword">if</span> (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">      <span class="comment">// 如果当前新首节点的key存在，则idxInOld等于oldKeyToIdx中对应key的索引</span></span><br><span class="line">      <span class="comment">// 否则寻找旧节点数组中与当前新首节点相同的节点索引赋予idxInOld</span></span><br><span class="line">      idxInOld = isDef(newStartVnode.key)</span><br><span class="line">        ? oldKeyToIdx[newStartVnode.key]</span><br><span class="line">        : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">      <span class="comment">//  如果idxInOld不存在，则说明当前对比的新节点是新增节点</span></span><br><span class="line">      <span class="keyword">if</span> (isUndef(idxInOld)) &#123; <span class="comment">// New element</span></span><br><span class="line">        <span class="comment">// 创建新节点插入到父级对应位置</span></span><br><span class="line">        createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 在旧节点数组中找到了相应的节点的索引时</span></span><br><span class="line">        <span class="comment">// 将vnodeToMove赋值为相应的节点</span></span><br><span class="line">        vnodeToMove = oldCh[idxInOld]</span><br><span class="line">        <span class="comment">// 对比此节点和当前新首节点</span></span><br><span class="line">        <span class="keyword">if</span> (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class="line">          <span class="comment">// 如果相同，则继续对比子级</span></span><br><span class="line">          patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue)</span><br><span class="line">          <span class="comment">// 将旧节点数组中的该节点设置为undefined</span></span><br><span class="line">          oldCh[idxInOld] = <span class="literal">undefined</span></span><br><span class="line">          <span class="comment">// 移动找到的节点到当前旧首节点之前</span></span><br><span class="line">          canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 如不同，则说明虽然key相同，但是不同元素，当作新元素处理</span></span><br><span class="line">          <span class="comment">// same key but different element. treat as new element</span></span><br><span class="line">          <span class="comment">// 创建新元素闯入父级相应位置</span></span><br><span class="line">          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 递增新节点开始索引，当前新首节点指向下一节点</span></span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 新旧节点开始索引任一方大于其结束索引时结束循环</span></span><br><span class="line">  <span class="comment">// 当旧节点开始索引大于旧节点结束索引时</span></span><br><span class="line">  <span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">    <span class="comment">// 判断新节点数组中newEndIdx索引后的节点是否存在，若不存在refElm为null</span></span><br><span class="line">    <span class="comment">// 若存在则refElm为相应节点的elm值</span></span><br><span class="line">    refElm = isUndef(newCh[newEndIdx + <span class="number">1</span>]) ? <span class="literal">null</span> : newCh[newEndIdx + <span class="number">1</span>].elm</span><br><span class="line">    <span class="comment">// 向父节点相应位置添加该节点</span></span><br><span class="line">    addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">    <span class="comment">// 当新节点开始索引大于新节点结束索引时</span></span><br><span class="line">    <span class="comment">// 在父级中移除未处理的剩余旧节点，范围是oldStartIdx~oldEndIdx</span></span><br><span class="line">    removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>updateChildren</code> 函数的主要逻辑是利用索引来替换当前节点的引用，有如模拟指针移动指向的对象，来逐一进行对比，并且是递归进行的。指针移动的基准是参照新节点，条件满足下，根据当前的新节点来寻找旧节点中对应的节点，如果相等会递归进入子级，如果不相等当作新增节点处理，在处理之后会移动到下一个节点，继续新一轮的对比。在旧节点数组中将对比过的节点设置成 <code>undefined</code> 标志节点已处理过，避免了以后的多余对比。这里的处理逻辑是相当巧妙的，这就是节点对比更新的最基础的实现。</p>
<hr>
<p>终于把我认为Vue最核心的另一个主要功能给攻略了下来，真是激动人心。比起数据绑定，这一部分的实现也着实不简单，光是处理流就让人凌乱不堪。<code>patch</code> 所实际对应的 <code>createPatchFunction</code> 函数是这一模块的重中之重，理顺了更新渲染的流程，继而理解了这一函数的具体实现后，基本上能对Vue的渲染功能有了一定深度的把握。</p>

  </div>
  
  <section id="comments" class="comments">
    <div class="valine-comment"></div>
<!--载入js，在</body>之前插入即可-->
<!--Leancloud 操作库:-->
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<!--Valine 的核心代码库-->
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script>
new Valine({
    el: '.valine-comment',
    app_id: 'DKiK5z8iNqcTBYteGEiuxyaP-gzGzoHsz',
    app_key: '0SPtM0nGzQdGBXxpwbOSLTXV',
    placeholder: '有什么话想告诉我？',
    visitor: 'true',
  })
</script>
  </section>
  
</article>
    </main>
    <footer id="footer">
  Copyright &copy; 2025 Shio  
  <a class="social-links" href="mailto:jylzs369@163.com"
    ><i class="blogfont">&#xe61a; </i></a
  >
  
  <a class="social-links" href="https://www.jianshu.com/u/70c1c469e3b6"
    ><i class="blogfont">&#xe6d7; </i></a
  >
  
  <a class="social-links" href="https://www.zhihu.com/people/jylzs369"
    ><i class="blogfont">&#xe606; </i></a
  >
  
  <a class="social-links" href="/atom.xml"
    ><i class="blogfont">&#xe640; </i></a
  >
    <a href="https://beian.miit.gov.cn/" title="粤ICP备20052180号" target="_blank" rel="noopener">粤ICP备20052180号</a>
</footer>

    <!-- scripts -->

<script src="/scripts/main.js"></script>

  </body>
</html>