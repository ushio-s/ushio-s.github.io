<!DOCTYPE html>
<html  lang=zh-CN>
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  
    
    <link rel="shortcut icon" href="/images/favicon.ico ">
    
    
    <link rel="icon" type="image/png" href="/images/favicon-android.png " sizes="192x192">
    
    
    <link rel="apple-touch-icon" href="/images/favicon-apple.png " sizes="180x180">
    
  
  <!-- title -->
  <title>Shio&#39;s Psycology Life Vue源码探究-事件系统 </title>
  <!-- styles -->
  <!-- styles -->

<link rel="stylesheet" href="/styles/global.css">

  <!-- rss -->
  
  <link rel="alternate" href="/atom.xml" title="Shio&#39;s Psycology Life" type="application/atom+xml" />
  
<meta name="generator" content="Hexo 4.2.1"></head>
  <body>
    <header id="header">
  
  <nav class="menu menu--right">
  
    <a class="menu__item" href="/">主页</a>
    <a class="menu__item" href="/archives/">归档</a>
    <a class="menu__item" href="/categories/">专题</a>
    <a class="menu__item" href="/tags/">标签</a>
    <!-- <a class="menu__item" href="/">作品</a> -->
    <!-- <a class="menu__item" href="/about/">关于</a> -->
  </nav>
</header>
    <main>
      <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post__header">
  <h1 class="post__title">Vue源码探究-事件系统</h1>
  
  
  <div class="post__meta">
    
<time class="post__date" datetime="2018-07-16T03:09:34.000Z" itemprop="datePublished">
  
  <i class="blogfont">&#xedff;</i>
  
  2018-07-16 11:09:34
</time>

    
<div class="post__category">
  <i class="blogfont">&#xe62d;</i>
  <a class="category-link" href="/categories/Dev/">Dev</a>, <a class="category-link" href="/categories/Dev/Explore-Vue/">Explore Vue</a>
</div>
  

    
<div class="post__tag">
  <i class="blogfont">&#xe7ec;</i>
  <a class="tag-link" href="/tags/Vue/" rel="tag">Vue</a>
</div>


    <div id="/2018-07-16/vue-events-system/" class="leancloud_visitors post__stat" data-flag-title="Vue源码探究-事件系统">
  <i class="blogfont">&#xe672;</i>
  <span class="leancloud-visitors-count">loading...</span>
</div>
  </div>
</header>
  <aside class="post__aside">
  <div class="post__actions">
    <a id="backTop" class="post__top" href="javascript:">
      <i class="blogfont">&#xe6b1;</i><!-- 回到顶部 -->
    </a>
    <!-- <a id="share" class="post__share" href="javascript:">
      <i class="blogfont">&#xe6c1;</i>
    </a> -->
  </div>
  <ol class="post__toc"><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#头部引用"><span class="post__toc-text">头部引用</span></a></li><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#事件初始化"><span class="post__toc-text">事件初始化</span></a><ol class="post__toc-child"><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#更新事件监听器"><span class="post__toc-text">更新事件监听器</span></a></li></ol></li><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#事件相关的原型方法"><span class="post__toc-text">事件相关的原型方法</span></a></li></ol>
</aside>
  <div class="post__content" itemprop="articleBody">
    <p><em>本章代码位于<a href="https://github.com/vuejs/vue/blob/v2.5.17-beta.0/src/core/instance/events.js" target="_blank" rel="noopener">vue/src/core/instance/events.js</a></em></p>
<p>紧跟着生命周期之后的就是继续初始化事件相关的属性和方法。整个事件系统的代码相对其他模块来说非常简短，分几个部分来详细看看它的具体实现。</p>
<h2 id="头部引用"><a href="#头部引用" class="headerlink" title="头部引用"></a>头部引用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  tip,</span><br><span class="line">  toArray,</span><br><span class="line">  hyphenate,</span><br><span class="line">  handleError,</span><br><span class="line">  formatComponentName</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></span><br><span class="line"><span class="keyword">import</span> &#123; updateListeners &#125; <span class="keyword">from</span> <span class="string">'../vdom/helpers/index'</span></span><br></pre></td></tr></table></figure>
<p>头部先是引用了的一些工具方法，没有什么难点，具体可以查看相应文件。唯一值得注意的是引用自虚拟节点模块的一个叫 <code>updateListeners</code> 方法。顾名思义，是用来更新监听器的，至于为什么要有这样的一个方法，主要是因为如果该实例的父组件已经存在一些事件监听器，为了正确捕获到事件并向上冒泡，父级事件是需要继承下来的，这个原因在下面的初始化代码中有佐证；另外，如果在实例初始化的时候绑定了同名的事件处理器，也需要为同名事件添加新的处理器，以实现同一事件的多个监听器的绑定。</p>
<h2 id="事件初始化"><a href="#事件初始化" class="headerlink" title="事件初始化"></a>事件初始化</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义并导出initEvents函数，接受Component类型的vm参数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initEvents</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建例的_events属性，初始化为空对象</span></span><br><span class="line">  vm._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  <span class="comment">// 创建实例的_hasHookEvent属性，初始化为false</span></span><br><span class="line">  vm._hasHookEvent = <span class="literal">false</span></span><br><span class="line">  <span class="comment">// 初始化父级附属事件</span></span><br><span class="line">  <span class="comment">// init parent attached events</span></span><br><span class="line">  <span class="keyword">const</span> listeners = vm.$options._parentListeners</span><br><span class="line">  <span class="comment">// 如果父级事件存在，则更新实例事件监听器</span></span><br><span class="line">  <span class="keyword">if</span> (listeners) &#123;</span><br><span class="line">    updateComponentListeners(vm, listeners)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置target值，目标是引用实例</span></span><br><span class="line"><span class="keyword">let</span> target: any</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加事件函数，接受事件名称、事件处理器、是否一次性执行三个参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">event, fn, once</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (once) &#123;</span><br><span class="line">    target.$once(event, fn)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    target.$on(event, fn)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除事件函数，接受事件名称和时间处理器两个参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span> (<span class="params">event, fn</span>) </span>&#123;</span><br><span class="line">  target.$off(event, fn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义并导出函数updateComponentListeners，接受实例对象，新旧监听器参数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">updateComponentListeners</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vm: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  listeners: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  oldListeners: ?Object</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 设置target为vm</span></span><br><span class="line">  target = vm</span><br><span class="line">  <span class="comment">// 执行更新监听器函数，传入新旧事件监听对象、添加事件与移除事件函数、实例对象</span></span><br><span class="line">  updateListeners(listeners, oldListeners || &#123;&#125;, add, remove, vm)</span><br><span class="line">  <span class="comment">// 置空引用</span></span><br><span class="line">  target = <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上述代码所示，事件监听系统的初始化首先是创建了私有的事件对象和是否有事件钩子的标志两个属性，然后根据父级是否有事件处理器来决定是否更新当前实例的事件监听器，具体如何实现监听器的更新，贴上这段位于<a href="https://github.com/vuejs/vue/blob/v2.5.17-beta.0/src/core/vdom/helpers/update-listeners.js" target="_blank" rel="noopener">虚拟节点模块的辅助函数</a>中的代码片段来仔细看看。</p>
<h3 id="更新事件监听器"><a href="#更新事件监听器" class="headerlink" title="更新事件监听器"></a>更新事件监听器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义并导出updateListeners哈数</span></span><br><span class="line"><span class="comment">// 接受新旧事件监听器对象，事件添加和移除函数以及实例对象参数。</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">updateListeners</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  on: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  oldOn: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  add: Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  remove: Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  vm: Component</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定义一些辅助变量</span></span><br><span class="line">  <span class="keyword">let</span> name, def, cur, old, event</span><br><span class="line">  <span class="comment">// 遍历新的监听器对象</span></span><br><span class="line">  <span class="keyword">for</span> (name <span class="keyword">in</span> on) &#123;</span><br><span class="line">    <span class="comment">// 为def和cur赋值为新的事件对象</span></span><br><span class="line">    def = cur = on[name]</span><br><span class="line">    <span class="comment">// 为old赋值为旧的事件对象</span></span><br><span class="line">    old = oldOn[name]</span><br><span class="line">    <span class="comment">// 标准化事件对象并赋值给event。</span></span><br><span class="line">    <span class="comment">// normalizeEvent函数主要用于将传入的带有特殊前缀的事件修饰符分解为具有特定值的事件对象</span></span><br><span class="line">    event = normalizeEvent(name)</span><br><span class="line">    <span class="comment">// 下面代码是weex框架专用，处理cur变量和格式化好的事件对象的参数属性</span></span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (__WEEX__ &amp;&amp; isPlainObject(def)) &#123;</span><br><span class="line">      cur = def.handler</span><br><span class="line">      event.params = def.params</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果新事件不存在，在非生产环境中提供报错信息，否则不执行任何操作</span></span><br><span class="line">    <span class="keyword">if</span> (isUndef(cur)) &#123;</span><br><span class="line">      process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">        <span class="string">`Invalid handler for event "<span class="subst">$&#123;event.name&#125;</span>": got `</span> + <span class="built_in">String</span>(cur),</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    <span class="comment">// 当旧事件不存在时</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isUndef(old)) &#123;</span><br><span class="line">      <span class="comment">// 如果新事件对象cur的fns属性不存在</span></span><br><span class="line">      <span class="keyword">if</span> (isUndef(cur.fns)) &#123;</span><br><span class="line">        <span class="comment">// 创建函数调用器并重新复制给cur和on[name]</span></span><br><span class="line">        cur = on[name] = createFnInvoker(cur)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 添加新的事件处理器</span></span><br><span class="line">      add(event.name, cur, event.once, event.capture, event.passive, event.params)</span><br><span class="line">    <span class="comment">// 如果新旧事件不完全相等</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur !== old) &#123;</span><br><span class="line">      <span class="comment">// 用新事件处理函数覆盖旧事件对象的fns属性</span></span><br><span class="line">      old.fns = cur</span><br><span class="line">      <span class="comment">// 将事件对象重新复制给on</span></span><br><span class="line">      on[name] = old</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遍历旧事件监听器</span></span><br><span class="line">  <span class="keyword">for</span> (name <span class="keyword">in</span> oldOn) &#123;</span><br><span class="line">    <span class="comment">// 如果新事件对象不存在</span></span><br><span class="line">    <span class="keyword">if</span> (isUndef(on[name])) &#123;</span><br><span class="line">      <span class="comment">// 标准化事件对象</span></span><br><span class="line">      event = normalizeEvent(name)</span><br><span class="line">      <span class="comment">// 移除事件处理器</span></span><br><span class="line">      remove(event.name, oldOn[name], event.capture)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码中用到了 <code>normalizeEvent</code> 和 <code>createFnInvoker</code> 两个主要的函数来完成更新监听器的实现，代码与 <code>updateListeners</code> 函数位于同一文件中。</p>
<ul>
<li><code>normalizeEvent</code>：主要是用于返回一个定制化的事件对象，这个函数接受4个必选参数和2两个可选参数，分别是事件名称name属性、是否一次性执行的once属性、是否捕获事件的capture属性、是否使用被动模式passive属性、事件处理器handler方法、事件处理器参数params数组。属性的含义都比较好理解，特别注意一下 <code>once</code>、<code>capture</code>、<code>passive</code> 属性，这三个属性是用来修饰事件的，分别对应了 <code>~</code>、<code>!</code>、<code>&amp;</code> 修饰符，贴上一个官方文档中的使用示例，引用自<a href="https://cn.vuejs.org/v2/guide/render-function.html#事件-amp-按键修饰符" target="_blank" rel="noopener">事件 &amp; 按键修饰符</a>。启动被动模式的用途是使事件处理器无法阻止默认事件，比如 <code>&lt;a&gt;</code> 标签自带的链接跳转事件，如果设置passive为true，则事件处理器即便是设置了阻止默认事件也是没办法阻止跳转的。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">on: &#123;</span><br><span class="line">  <span class="string">'!click'</span>: <span class="keyword">this</span>.doThisInCapturingMode,</span><br><span class="line">  <span class="string">'~keyup'</span>: <span class="keyword">this</span>.doThisOnce,</span><br><span class="line">  <span class="string">'~!mouseover'</span>: <span class="keyword">this</span>.doThisOnceInCapturingMode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>createFnInvoker</code>： 接受一个fns参数，可以传入一个事件处理器函数，也可以传入一个包含多个处理器的数组。在该函数内部定义了一个 <code>invoker</code> 函数并且最终返回它，函数有一个fns属性是用来存放所传入的处理器的，调用这个函数后，会按fns的类型来分别执行处理器数组的调用或单个处理器的调用。这个实现即是真正执行事件处理器调用的过程。</li>
</ul>
<h2 id="事件相关的原型方法"><a href="#事件相关的原型方法" class="headerlink" title="事件相关的原型方法"></a>事件相关的原型方法</h2><p>在事件的初始化过程里有用到几个以 <code>&amp;</code> 开头的类原型方法，它们是在mixin函数里挂载到核心类上的。初始化的时候定义的方法都是在这些方法的基础上再进行了一次封装，其绑定事件、触发事件和移除事件的具体实现都在这些方法中，当然不会放过对这些细节的探索。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出eventsMixin函数，接收形参Vue，</span></span><br><span class="line"><span class="comment">// 使用Flow进行静态类型检查指定为Component类</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">eventsMixin</span> (<span class="params">Vue: Class&lt;Component&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定义hook正则检验</span></span><br><span class="line">  <span class="keyword">const</span> hookRE = <span class="regexp">/^hook:/</span></span><br><span class="line">  <span class="comment">// 给Vue原型对象挂载$on方法</span></span><br><span class="line">  <span class="comment">// 参数event可为字符串或数组类型，fn是事件监听函数</span></span><br><span class="line">  <span class="comment">// 方法返回实例对象本身</span></span><br><span class="line">  Vue.prototype.$on = <span class="function"><span class="keyword">function</span> (<span class="params">event: string | Array&lt;string&gt;, fn: Function</span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义实例变量</span></span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// 如果传入的event参数是数组，遍历event数组，为所有事件注册fn监听函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(event)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = event.length; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$on(event[i], fn)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// event参数为字符串时，检查event事件监听函数数组是否存在</span></span><br><span class="line">      <span class="comment">// 已存在事件监听数组则直接添加新监听函数</span></span><br><span class="line">      <span class="comment">// 否则建立空的event事件监听函数数组，再添加新监听函数</span></span><br><span class="line">      (vm._events[event] || (vm._events[event] = [])).push(fn)</span><br><span class="line">      <span class="comment">// 此处做了性能优化，使用正则检验hook:是否存在的布尔值</span></span><br><span class="line">      <span class="comment">// 而不是hash值查找设置实例对象的_hasHookEvent值</span></span><br><span class="line">      <span class="comment">// 此次优化是很久之前版本的修改，暂时不太清楚以前hash值查找是什么逻辑，留待以后查证</span></span><br><span class="line">      <span class="comment">// optimize hook:event cost by using a boolean flag marked at registration</span></span><br><span class="line">      <span class="comment">// instead of a hash lookup</span></span><br><span class="line">      <span class="keyword">if</span> (hookRE.test(event)) &#123;</span><br><span class="line">        vm._hasHookEvent = <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回实例本身</span></span><br><span class="line">    <span class="keyword">return</span> vm</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 为Vue原型对象挂载$once方法</span></span><br><span class="line">  <span class="comment">// 参数event只接受字符串，fn是监听函数</span></span><br><span class="line">  Vue.prototype.$once = <span class="function"><span class="keyword">function</span> (<span class="params">event: string, fn: Function</span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义实例变量</span></span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// 创建on函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">on</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 函数执行后先清除event事件绑定的on监听函数，即函数本身</span></span><br><span class="line">      <span class="comment">// 这样以后就不会再继续监听event事件</span></span><br><span class="line">      vm.$off(event, on)</span><br><span class="line">      <span class="comment">// 在实例上运行fn监听函数</span></span><br><span class="line">      fn.apply(vm, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为on函数设置fn属性，保证在on函数内能够正确找到fn函数</span></span><br><span class="line">    on.fn = fn</span><br><span class="line">    <span class="comment">// 为event事件注册on函数</span></span><br><span class="line">    vm.$on(event, on)</span><br><span class="line">    <span class="comment">// 返回实例本身</span></span><br><span class="line">    <span class="keyword">return</span> vm</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 为Vue原型对象挂载$off方法</span></span><br><span class="line">  <span class="comment">// event参数可为字符串或数组类型</span></span><br><span class="line">  <span class="comment">// fn是监听函数，为可选参数</span></span><br><span class="line">  Vue.prototype.$off = <span class="function"><span class="keyword">function</span> (<span class="params">event?: string | Array&lt;string&gt;, fn?: Function</span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义实例变量</span></span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// 如果没有传入参数，则清除实例对象的所有事件</span></span><br><span class="line">    <span class="comment">// 将实例对象的_events私有属性设置为null，并返回实例</span></span><br><span class="line">   <span class="comment">// all</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">arguments</span>.length) &#123;</span><br><span class="line">      vm._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">      <span class="keyword">return</span> vm</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果event参数传入数组，清除所有event事件的fn监听函数返回实例</span></span><br><span class="line">    <span class="comment">// 这里是$off方法递归执行，最终会以单一事件为基础来实现监听的清除</span></span><br><span class="line">    <span class="comment">// array of events</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(event)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = event.length; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$off(event[i], fn)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> vm</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果指定单一事件，将事件的监听函数数组赋值给cbs变量</span></span><br><span class="line">    <span class="comment">// specific event</span></span><br><span class="line">    <span class="keyword">const</span> cbs = vm._events[event]</span><br><span class="line">    <span class="comment">// 如果没有注册此事件监听则返回实例</span></span><br><span class="line">    <span class="keyword">if</span> (!cbs) &#123;</span><br><span class="line">      <span class="keyword">return</span> vm</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有指定监听函数，则清除所有该事件的监听函数，返回实例</span></span><br><span class="line">    <span class="keyword">if</span> (!fn) &#123;</span><br><span class="line">      vm._events[event] = <span class="literal">null</span></span><br><span class="line">      <span class="keyword">return</span> vm</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果指定监听函数，则遍历事件监听函数数组，移除指定监听函数返回实例</span></span><br><span class="line">    <span class="keyword">if</span> (fn) &#123;</span><br><span class="line">      <span class="comment">// specific handler</span></span><br><span class="line">      <span class="keyword">let</span> cb</span><br><span class="line">      <span class="keyword">let</span> i = cbs.length</span><br><span class="line">      <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        cb = cbs[i]</span><br><span class="line">        <span class="keyword">if</span> (cb === fn || cb.fn === fn) &#123;</span><br><span class="line">          cbs.splice(i, <span class="number">1</span>)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vm</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 为Vue原型对象挂载$emit方法，只接受单一event</span></span><br><span class="line">  Vue.prototype.$emit = <span class="function"><span class="keyword">function</span> (<span class="params">event: string</span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义实例变量</span></span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// 在非生产环境下，传入的事件字符串如果是驼峰值且有相应的小写监听事件</span></span><br><span class="line">    <span class="comment">// 则提示事件已注册，且无法使用驼峰式注册事件</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> lowerCaseEvent = event.toLowerCase()</span><br><span class="line">      <span class="keyword">if</span> (lowerCaseEvent !== event &amp;&amp; vm._events[lowerCaseEvent]) &#123;</span><br><span class="line">        tip(</span><br><span class="line">          <span class="string">`Event "<span class="subst">$&#123;lowerCaseEvent&#125;</span>" is emitted in component `</span> +</span><br><span class="line">          <span class="string">`<span class="subst">$&#123;formatComponentName(vm)&#125;</span> but the handler is registered for "<span class="subst">$&#123;event&#125;</span>". `</span> +</span><br><span class="line">          <span class="string">`Note that HTML attributes are case-insensitive and you cannot use `</span> +</span><br><span class="line">          <span class="string">`v-on to listen to camelCase events when using in-DOM templates. `</span> +</span><br><span class="line">          <span class="string">`You should probably use "<span class="subst">$&#123;hyphenate(event)&#125;</span>" instead of "<span class="subst">$&#123;event&#125;</span>".`</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将事件监听函数数组赋值 给cbs</span></span><br><span class="line">    <span class="keyword">let</span> cbs = vm._events[event]</span><br><span class="line">    <span class="comment">// 如果监听函数数组存在</span></span><br><span class="line">    <span class="keyword">if</span> (cbs) &#123;</span><br><span class="line">      <span class="comment">// 重置cbs变量，为何要使用toArray方法转换一次数组不太明白？</span></span><br><span class="line">      cbs = cbs.length &gt; <span class="number">1</span> ? toArray(cbs) : cbs</span><br><span class="line">      <span class="comment">// 将event之后传入的所有参数定义为args数组</span></span><br><span class="line">      <span class="keyword">const</span> args = toArray(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">      <span class="comment">// 遍历所有监听函数，为实例执行每一个监听函数，并传入args参数数组</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = cbs.length; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          cbs[i].apply(vm, args)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          handleError(e, vm, <span class="string">`event handler for "<span class="subst">$&#123;event&#125;</span>"`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vm</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>eventsMixin的内容非常直观，分别为实例原型对象挂载了<code>$on</code>、<code>$once</code>、<code>$off</code>、<code>$emit</code>四个方法。这是实例事件监听函数的注册、一次性注册、移除和触发的内部实现。在使用的过程中会对这些实现有一个更清晰的理解。</p>
<hr>
<p>终于对Vue的事件系统的实现有了一个大致了解，没有什么特别高深的处理，但完整的事件系统的实现有很多细致的功能这里其实并没有特别详细地探讨，比如事件修饰符，可以参考官方文档里的解说会有一个更清晰的了解。事件系统的重要作用首先是为实例制定了一套处理事件的方案和标准，其次是在实例数据更新的过程中保持对事件监听器的更新，这两个部分的处理是最需要细致去琢磨的。</p>

  </div>
  
  <section id="comments" class="comments">
    <div class="valine-comment"></div>
<!--载入js，在</body>之前插入即可-->
<!--Leancloud 操作库:-->
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<!--Valine 的核心代码库-->
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script>
new Valine({
    el: '.valine-comment',
    app_id: 'DKiK5z8iNqcTBYteGEiuxyaP-gzGzoHsz',
    app_key: '0SPtM0nGzQdGBXxpwbOSLTXV',
    placeholder: '有什么话想告诉我？',
    visitor: 'true',
  })
</script>
  </section>
  
</article>
    </main>
    <footer id="footer">
  Copyright &copy; 2025 Shio  
  <a class="social-links" href="https://github.com/ushio-s"
    ><i class="blogfont">&#xe6b7; </i></a
  >
  
  <a class="social-links" href="mailto:jylzs369@163.com"
    ><i class="blogfont">&#xe61a; </i></a
  >
  
  <a class="social-links" href="https://www.jianshu.com/u/70c1c469e3b6"
    ><i class="blogfont">&#xe6d7; </i></a
  >
  
  <a class="social-links" href="https://www.zhihu.com/people/jylzs369"
    ><i class="blogfont">&#xe606; </i></a
  >
  
  <a class="social-links" href="/atom.xml"
    ><i class="blogfont">&#xe640; </i></a
  >
    <a href="https://beian.miit.gov.cn/" title="粤ICP备20052180号" target="_blank" rel="noopener">粤ICP备20052180号</a>
</footer>

    <!-- scripts -->

<script src="/scripts/main.js"></script>

  </body>
</html>