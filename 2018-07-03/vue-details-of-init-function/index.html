<!DOCTYPE html>
<html  lang=zh-CN>
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  
    
    <link rel="shortcut icon" href="/images/favicon.ico ">
    
    
    <link rel="icon" type="image/png" href="/images/favicon-android.png " sizes="192x192">
    
    
    <link rel="apple-touch-icon" href="/images/favicon-apple.png " sizes="180x180">
    
  
  <!-- title -->
  <title>Shio&#39;s Psycology Life Vue源码探究-类初始化函数详情 </title>
  <!-- styles -->
  <!-- styles -->

<link rel="stylesheet" href="/styles/global.css">

  <!-- rss -->
  
  <link rel="alternate" href="/atom.xml" title="Shio&#39;s Psycology Life" type="application/atom+xml" />
  
<meta name="generator" content="Hexo 4.2.1"></head>
  <body>
    <header id="header">
  
  <nav class="menu menu--right">
  
    <a class="menu__item" href="/">主页</a>
    <a class="menu__item" href="/archives/">归档</a>
    <a class="menu__item" href="/categories/">专题</a>
    <a class="menu__item" href="/tags/">标签</a>
    <!-- <a class="menu__item" href="/">作品</a> -->
    <!-- <a class="menu__item" href="/about/">关于</a> -->
  </nav>
</header>
    <main>
      <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post__header">
  <h1 class="post__title">Vue源码探究-类初始化函数详情</h1>
  
  
  <div class="post__meta">
    
<time class="post__date" datetime="2018-07-03T03:28:15.000Z" itemprop="datePublished">
  
  <i class="blogfont">&#xedff;</i>
  
  2018-07-03 11:28:15
</time>

    
<div class="post__category">
  <i class="blogfont">&#xe62d;</i>
  <a class="category-link" href="/categories/Dev/">Dev</a>, <a class="category-link" href="/categories/Dev/Explore-Vue/">Explore Vue</a>
</div>
  

    
<div class="post__tag">
  <i class="blogfont">&#xe7ec;</i>
  <a class="tag-link" href="/tags/Vue/" rel="tag">Vue</a>
</div>


    <div id="/2018-07-03/vue-details-of-init-function/" class="leancloud_visitors post__stat" data-flag-title="Vue源码探究-类初始化函数详情">
  <i class="blogfont">&#xe672;</i>
  <span class="leancloud-visitors-count">loading...</span>
</div>
  </div>
</header>
  <aside class="post__aside">
  <div class="post__actions">
    <a id="backTop" class="post__top" href="javascript:">
      <i class="blogfont">&#xe6b1;</i><!-- 回到顶部 -->
    </a>
    <!-- <a id="share" class="post__share" href="javascript:">
      <i class="blogfont">&#xe6c1;</i>
    </a> -->
  </div>
  <ol class="post__toc"><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#头部引用"><span class="post__toc-text">头部引用</span></a><ol class="post__toc-child"><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#辅助函数extend"><span class="post__toc-text">辅助函数extend</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#辅助函数mergeOptions"><span class="post__toc-text">辅助函数mergeOptions</span></a></li></ol></li><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#初始化内部组件时options的合并"><span class="post__toc-text">初始化内部组件时options的合并</span></a></li><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#初始化实例时options的合并"><span class="post__toc-text">初始化实例时options的合并</span></a></li></ol>
</aside>
  <div class="post__content" itemprop="articleBody">
    <p>随着初始化函数的执行，实例的生命周期也开始运转，在初始化函数里可以看到每个模块向实例集成的功能，这些功能的具体内容以后在单独的文章里继续探索。现在来详细看看类初始化函数的详细代码。</p>
<h2 id="头部引用"><a href="#头部引用" class="headerlink" title="头部引用"></a>头部引用</h2><p>*下面代码位于<a href="https://github.com/vuejs/vue/blob/v2.5.17-beta.0/src/core/instance/init.js" target="_blank" rel="noopener">vue/src/core/instance/init.js</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">'../config'</span></span><br><span class="line"><span class="keyword">import</span> &#123; initProxy &#125; <span class="keyword">from</span> <span class="string">'./proxy'</span></span><br><span class="line"><span class="keyword">import</span> &#123; initState &#125; <span class="keyword">from</span> <span class="string">'./state'</span></span><br><span class="line"><span class="keyword">import</span> &#123; initRender &#125; <span class="keyword">from</span> <span class="string">'./render'</span></span><br><span class="line"><span class="keyword">import</span> &#123; initEvents &#125; <span class="keyword">from</span> <span class="string">'./events'</span></span><br><span class="line"><span class="keyword">import</span> &#123; mark, measure &#125; <span class="keyword">from</span> <span class="string">'../util/perf'</span></span><br><span class="line"><span class="keyword">import</span> &#123; initLifecycle, callHook &#125; <span class="keyword">from</span> <span class="string">'./lifecycle'</span></span><br><span class="line"><span class="keyword">import</span> &#123; initProvide, initInjections &#125; <span class="keyword">from</span> <span class="string">'./inject'</span></span><br><span class="line"><span class="keyword">import</span> &#123; extend, mergeOptions, formatComponentName &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></span><br></pre></td></tr></table></figure>
<p>头部注入的一些方法是在生命周期运行中开始初始化的功能，之前在核心类实现的文章中有提到过，在这里不展开。<code>config</code>对象是作为基本的配置参数，在不同运行环境里会更改当中的属性值来适应不同的平台需求，在这个文件中只用到了其中的性能检测属性，与具体的类的实现没有太大关联，与引入的<code>mark</code>、<code>measure</code>、<code>formatComponentName</code>方法配合主要是做性能评估用的。</p>
<p>在初始化组件的时候主要用到的是工具方法<code>extend</code>、<code>mergeOptions</code>。</p>
<h3 id="辅助函数extend"><a href="#辅助函数extend" class="headerlink" title="辅助函数extend"></a>辅助函数extend</h3><p><code>extend</code>函数是一个很简单的为对象扩展属性的方法，代码位于这个文件中<a href="https://github.com/vuejs/vue/blob/v2.5.17-beta.0/src/shared/util.js" target="_blank" rel="noopener">vue/src/shared/util.js</a>，具体实现非常基础，看看就好。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Mix properties into target object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">extend</span> (<span class="params">to: Object, _from: ?Object</span>): <span class="title">Object</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> _from) &#123;</span><br><span class="line">    to[key] = _from[key]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> to</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="辅助函数mergeOptions"><a href="#辅助函数mergeOptions" class="headerlink" title="辅助函数mergeOptions"></a>辅助函数mergeOptions</h3><p><code>mergeOptions</code>函数代码位于<br><a href="https://github.com/vuejs/vue/blob/v2.5.17-beta.0/src/core/util/options.js" target="_blank" rel="noopener">vue/src/core/util/options.js</a>中，它是初始化合并options对象时非常重要的函数，为了看明白它在初始化函数里的用途，稍微花点时间来仔细看一下它的具体实现。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该函数用于将两个配置对象合并为一个新的配置对象，</span></span><br><span class="line"><span class="comment">// 核心实体既用于实例化也用于继承</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Merge two option objects into a new one.</span></span><br><span class="line"><span class="comment"> * Core utility used in both instantiation and inheritance.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 导出mergeOptions函数</span></span><br><span class="line"><span class="comment">// 接收Object类型的parent、child参数，Component类型的vm参数</span></span><br><span class="line"><span class="comment">// 函数返回对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mergeOptions</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  parent: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  child: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  vm?: Component</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Object</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 非生产环境时检查child对象的components属性中是否有不合适的引用组件名称</span></span><br><span class="line">  <span class="comment">// 不合适的组建名主要是指与Vue内建html标签或保留标签名相同的组件名称如slot,component</span></span><br><span class="line">  <span class="comment">// 有兴趣了解的可以参照同一文件中的L246到L269查看具体实现</span></span><br><span class="line">  <span class="comment">// 其中的辅助工具函数位于src/shared/util.js的L94到L112</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    checkComponents(child)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果child传入的是函数对象，则将函数的options属性赋值给child，确保child引用options</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> child === <span class="string">'function'</span>) &#123;</span><br><span class="line">    child = child.options</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面三个函数都是将child的各个属性格式化成预定好的对象格式</span></span><br><span class="line">  <span class="comment">// 标准化属性</span></span><br><span class="line">  normalizeProps(child, vm)</span><br><span class="line">  <span class="comment">// 标准化注入</span></span><br><span class="line">  normalizeInject(child, vm)</span><br><span class="line">  <span class="comment">// 标准化指令</span></span><br><span class="line">  normalizeDirectives(child)</span><br><span class="line">  <span class="comment">// 定义扩展</span></span><br><span class="line">  <span class="keyword">const</span> extendsFrom = child.extends</span><br><span class="line">  <span class="comment">// 如果存在则向下递归合并</span></span><br><span class="line">  <span class="keyword">if</span> (extendsFrom) &#123;</span><br><span class="line">    parent = mergeOptions(parent, extendsFrom, vm)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果存在mixins，则合并每一个mixin对象</span></span><br><span class="line">  <span class="keyword">if</span> (child.mixins) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = child.mixins.length; i &lt; l; i++) &#123;</span><br><span class="line">      parent = mergeOptions(parent, child.mixins[i], vm)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定义以空对象options</span></span><br><span class="line">  <span class="keyword">const</span> options = &#123;&#125;</span><br><span class="line">  <span class="keyword">let</span> key</span><br><span class="line">  <span class="comment">// 对每一个parent中的属性进行合并，添加到options中</span></span><br><span class="line">  <span class="keyword">for</span> (key <span class="keyword">in</span> parent) &#123;</span><br><span class="line">    mergeField(key)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果parent中不含有key属性，则对每一个child中key属性进行合并</span></span><br><span class="line">  <span class="keyword">for</span> (key <span class="keyword">in</span> child) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasOwn(parent, key)) &#123;</span><br><span class="line">      mergeField(key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定义mergeField函数，接收key参数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">mergeField</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果strats[key]有定义好的合并策略函数，则复制给strat</span></span><br><span class="line">    <span class="comment">// 否则将默认的defaultStrat方法赋给strat</span></span><br><span class="line">    <span class="keyword">const</span> strat = strats[key] || defaultStrat</span><br><span class="line">    <span class="comment">// 合并属性</span></span><br><span class="line">    options[key] = strat(parent[key], child[key], vm, key)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回最终options对象</span></span><br><span class="line">  <span class="keyword">return</span> options</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管 <code>mergeOptions</code> 函数的实现有些复杂，但它的作用其实比较明确，就是解决初始化的过程中对继承的类的options对象和新传入的options对象之间同名属性的冲突，即使用继承的属性值还是新传入的属性值的问题。在代码的一开始官方就已说明它是一个递归函数，可以一并解决添加了扩展内容和使用了mixins的场景，总而言之，这个步骤就是确保我们初始化的实例的options对象正确唯一。</p>
<p>代码中有几个标准化属性的函数，具体实现也在以上代码的同一文件中，虽然有一堆代码，但实现还是比较简单，主要目的就是把传入的options对象的各个属性格式化成基于对象的预定格式，在以后的运行中方便使用。</p>
<p><code>hasOwn</code> 函数是对 <code>Object.prototype.hasOwnProperty</code> 方法的一个包装，比较简单，需要了解的话就去<a href="https://github.com/vuejs/vue/blob/v2.5.17-beta.0/src/shared/util.js" target="_blank" rel="noopener">util工具函数文件</a>中查看。</p>
<p>值得一提的是 <code>strats</code> 的使用。在代码的一开始的部分就定义 <code>strats</code> 变量，并说明它是用来处理父子选项合并属性的功能。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Option overwriting strategies are functions that handle</span></span><br><span class="line"><span class="comment"> * how to merge a parent option value and a child option</span></span><br><span class="line"><span class="comment"> * value into the final value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> strats = config.optionMergeStrategies</span><br></pre></td></tr></table></figure>

<p>对于 <code>el</code> 和 <code>propsData</code> 属性的合并策略赋予 <code>defaultStrat</code> 函数，该函数的原则是child对象属性优先，没有child对象属性则返回parent的对应属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Options with restrictions</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">  strats.el = strats.propsData = <span class="function"><span class="keyword">function</span> (<span class="params">parent, child, vm, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!vm) &#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">`option "<span class="subst">$&#123;key&#125;</span>" can only be used during instance `</span> +</span><br><span class="line">        <span class="string">'creation with the `new` keyword.'</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> defaultStrat(parent, child)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>data</code>、<code>watch</code>、<code>props</code>、<code>methods</code>、<code>inject</code>、<code>computed</code>、<code>provide</code>、各种钩子函数和<code>ASSET_TYPES</code>里包含的<code>component</code>、<code>directive</code> 、 <code>filter</code> 三个属性都分别定义了相关的合并方法，有兴趣继续了解的同学可以在同一分文件中查看，代码太长但是实现比较基础，所以没什么好详说的，可以关注一下的是某些属性是替换覆盖，而某些属性是合并成数组如各种钩子的监听函数。</p>
<h2 id="初始化内部组件时options的合并"><a href="#初始化内部组件时options的合并" class="headerlink" title="初始化内部组件时options的合并"></a>初始化内部组件时options的合并</h2><p>对于初始化合并options的操作分为了两个方向，一是创建内部组件时的合并，二是创建非内部组件实例时的合并，先来说说内部组件初始化的详细内容，在类的实现中对应着这一句代码 <code>initInternalComponent(vm, options)</code><br> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 输出initInternalComponent函数</span></span><br><span class="line"> <span class="comment">// 接受Component类型的vm参数和InternalComponentOptions类型的options参数</span></span><br><span class="line"> <span class="comment">// 这里vm和options分别是创建实例时将要传入的实例对象和配置对象</span></span><br><span class="line"> <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initInternalComponent</span> (<span class="params">vm: Component, options: InternalComponentOptions</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定义opts，为opts和vm.$options创建以vm.constructor.options为原型的对象</span></span><br><span class="line">  <span class="keyword">const</span> opts = vm.$options = <span class="built_in">Object</span>.create(vm.constructor.options)</span><br><span class="line">  <span class="comment">// 以下为手动赋值，目的为了提升性能，因为比通过动态枚举属性来赋值的过程快</span></span><br><span class="line">  <span class="comment">// doing this because it's faster than dynamic enumeration.</span></span><br><span class="line">  <span class="comment">// 定义父虚拟节点parentVnode并赋值</span></span><br><span class="line">  <span class="keyword">const</span> parentVnode = options._parentVnode</span><br><span class="line">  <span class="comment">// 设置opts对象parent和_parentVnode属性</span></span><br><span class="line">  opts.parent = options.parent</span><br><span class="line">  opts._parentVnode = parentVnode</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义vnodeComponentOptions并赋值</span></span><br><span class="line">  <span class="keyword">const</span> vnodeComponentOptions = parentVnode.componentOptions</span><br><span class="line">  <span class="comment">// 定义opts各属性</span></span><br><span class="line">  opts.propsData = vnodeComponentOptions.propsData</span><br><span class="line">  opts._parentListeners = vnodeComponentOptions.listeners</span><br><span class="line">  opts._renderChildren = vnodeComponentOptions.children</span><br><span class="line">  opts._componentTag = vnodeComponentOptions.tag</span><br><span class="line"></span><br><span class="line">  <span class="comment">// options.render属性存在，则设置opts的render和staticRenderFns属性</span></span><br><span class="line">  <span class="keyword">if</span> (options.render) &#123;</span><br><span class="line">    opts.render = options.render</span><br><span class="line">    opts.staticRenderFns = options.staticRenderFns</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看出 <code>initInternalComponent</code> 函数的内容比较简单，主要是为创建的内部组件的options对象手动赋值，提升性能，因为按照官方注释的说法是所有的内部组件的初始化都没有列外可以同样处理。至于什么时候会创建内部组件，这种场景目前还不太了解，能确定的是通常创建Vue实例来初始化视图页面的用法是非内部组件性质的。在这里留下一个疑问。</p>
<h2 id="初始化实例时options的合并"><a href="#初始化实例时options的合并" class="headerlink" title="初始化实例时options的合并"></a>初始化实例时options的合并</h2><p>下面三个函数就是初始化实例合并options这条线时用到的方法，后两个函数作辅助用。对应如下带代码。主要是用来解决构造函数的默认配置选项和扩展选项之间的合并问题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vm.$options = mergeOptions(</span><br><span class="line">  resolveConstructorOptions(vm.constructor),</span><br><span class="line">  options || &#123;&#125;,</span><br><span class="line">  vm</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出resolveConstructorOptions函数，接受Component构造函数Ctor参数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">resolveConstructorOptions</span> (<span class="params">Ctor: Class&lt;Component&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定义传入的构造函数的options属性</span></span><br><span class="line">  <span class="keyword">let</span> options = Ctor.options</span><br><span class="line">  <span class="comment">// 如果Ctor.super存在则执行下面代码，这里是用来判断实例对象是否有继承</span></span><br><span class="line">  <span class="comment">// 如果有的话递归的把继承的父级对象的options都拿出来合并</span></span><br><span class="line">  <span class="keyword">if</span> (Ctor.super) &#123;</span><br><span class="line">    <span class="keyword">const</span> superOptions = resolveConstructorOptions(Ctor.super)</span><br><span class="line">    <span class="keyword">const</span> cachedSuperOptions = Ctor.superOptions</span><br><span class="line">    <span class="keyword">if</span> (superOptions !== cachedSuperOptions) &#123;</span><br><span class="line">      <span class="comment">// 如果父级的option变化了则要更新</span></span><br><span class="line">      <span class="comment">// super option changed,</span></span><br><span class="line">      <span class="comment">// need to resolve new options.</span></span><br><span class="line">      Ctor.superOptions = superOptions</span><br><span class="line">      <span class="comment">// 检查是否有任何后期修改/附加选项，这是为了解决之前误删注入选项的问题</span></span><br><span class="line">      <span class="comment">// check if there are any late-modified/attached options (#4976)</span></span><br><span class="line">      <span class="keyword">const</span> modifiedOptions = resolveModifiedOptions(Ctor)</span><br><span class="line">      <span class="comment">// 如果返回有修改的选项，则扩展Ctor.extendOptions</span></span><br><span class="line">      <span class="comment">// update base extend options</span></span><br><span class="line">      <span class="keyword">if</span> (modifiedOptions) &#123;</span><br><span class="line">        extend(Ctor.extendOptions, modifiedOptions)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 合并继承选项和扩展选项</span></span><br><span class="line">      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions)</span><br><span class="line">      <span class="comment">// 设置options.components[options.name]的引用</span></span><br><span class="line">      <span class="keyword">if</span> (options.name) &#123;</span><br><span class="line">        options.components[options.name] = Ctor</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回options</span></span><br><span class="line">  <span class="keyword">return</span> options</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下两个函数是为了解决#4976问题的方案</span></span><br><span class="line"><span class="comment">// 定义resolveModifiedOptions函数，接受Ctor参数，返回Object</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveModifiedOptions</span> (<span class="params">Ctor: Class&lt;Component&gt;</span>): ?<span class="title">Object</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 定义modified变量储存最终要选择保留的属性</span></span><br><span class="line">  <span class="keyword">let</span> modified</span><br><span class="line">  <span class="comment">// 分别定义最新、扩展和密封的配置选项</span></span><br><span class="line">  <span class="keyword">const</span> latest = Ctor.options</span><br><span class="line">  <span class="keyword">const</span> extended = Ctor.extendOptions</span><br><span class="line">  <span class="keyword">const</span> sealed = Ctor.sealedOptions</span><br><span class="line">  <span class="comment">// 遍历传入的配置选项对象</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> latest) &#123;</span><br><span class="line">    <span class="comment">// 如果最新的属性与密封的属性不相等，则执行去重处理</span></span><br><span class="line">    <span class="keyword">if</span> (latest[key] !== sealed[key]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!modified) modified = &#123;&#125;</span><br><span class="line">      modified[key] = dedupe(latest[key], extended[key], sealed[key])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回modified</span></span><br><span class="line">  <span class="keyword">return</span> modified</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义dedupe函数，接收latest最新对象，extended扩展对象，sealed密封对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dedupe</span> (<span class="params">latest, extended, sealed</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 合并选项的时候比较最新和密封的属性，确保生命周期钩子不重复</span></span><br><span class="line">  <span class="comment">// compare latest and sealed to ensure lifecycle hooks won't be duplicated</span></span><br><span class="line">  <span class="comment">// between merges</span></span><br><span class="line">  <span class="comment">// 如果latest是数组</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(latest)) &#123;</span><br><span class="line">    <span class="comment">// 定义res变量</span></span><br><span class="line">    <span class="keyword">const</span> res = []</span><br><span class="line">    <span class="comment">// 格式化sealed和extended为数组对象</span></span><br><span class="line">    sealed = <span class="built_in">Array</span>.isArray(sealed) ? sealed : [sealed]</span><br><span class="line">    extended = <span class="built_in">Array</span>.isArray(extended) ? extended : [extended]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; latest.length; i++) &#123;</span><br><span class="line">      <span class="comment">// 返回扩展的选项中存在的最新对象的属性而非密封选项以排除重复选项</span></span><br><span class="line">      <span class="comment">// push original options and not sealed options to exclude duplicated options</span></span><br><span class="line">      <span class="keyword">if</span> (extended.indexOf(latest[i]) &gt;= <span class="number">0</span> || sealed.indexOf(latest[i]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        res.push(latest[i])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回包含了扩展选项的数组变量</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 否则直接返回latest</span></span><br><span class="line">    <span class="keyword">return</span> latest</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>resolveConstructorOptions</code> 函数解决了继承的构造函数的选项之后，新创建的实例vm的$options对象就是继承选项和创建时传入的options选项的合并。其中虽然有很多复杂的递归调用，但是这些函数的目的都是为了确定最终的选项，理解这个目的非常重要。</p>
<hr>
<p>初始化函数的执行不仅在于开始生命周期的运行，对于options对象的各个属性值如何取舍的问题给出了非常复杂但健全的解决方法，这为生命周期正常运行铺垫了非常坚实的基础，有了清晰的options选项，之后的功能才能如期顺利执行。在这里也可以看出Vue处理各种属性的合并原则，对此有良好的理解可以确保在使用时立即定位遇到的相关问题。</p>

  </div>
  
  <section id="comments" class="comments">
    <div class="valine-comment"></div>
<!--载入js，在</body>之前插入即可-->
<!--Leancloud 操作库:-->
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<!--Valine 的核心代码库-->
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script>
new Valine({
    el: '.valine-comment',
    app_id: 'DKiK5z8iNqcTBYteGEiuxyaP-gzGzoHsz',
    app_key: '0SPtM0nGzQdGBXxpwbOSLTXV',
    placeholder: '有什么话想告诉我？',
    visitor: 'true',
  })
</script>
  </section>
  
</article>
    </main>
    <footer id="footer">
  Copyright &copy; 2025 Shio  
  <a class="social-links" href="mailto:jylzs369@163.com"
    ><i class="blogfont">&#xe61a; </i></a
  >
  
  <a class="social-links" href="https://www.jianshu.com/u/70c1c469e3b6"
    ><i class="blogfont">&#xe6d7; </i></a
  >
  
  <a class="social-links" href="https://www.zhihu.com/people/jylzs369"
    ><i class="blogfont">&#xe606; </i></a
  >
  
  <a class="social-links" href="/atom.xml"
    ><i class="blogfont">&#xe640; </i></a
  >
    <a href="https://beian.miit.gov.cn/" title="粤ICP备20052180号" target="_blank" rel="noopener">粤ICP备20052180号</a>
</footer>

    <!-- scripts -->

<script src="/scripts/main.js"></script>

  </body>
</html>