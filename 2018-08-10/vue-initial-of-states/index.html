<!DOCTYPE html>
<html  lang=zh-CN>
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  
    
    <link rel="shortcut icon" href="/images/favicon.ico ">
    
    
    <link rel="icon" type="image/png" href="/images/favicon-android.png " sizes="192x192">
    
    
    <link rel="apple-touch-icon" href="/images/favicon-apple.png " sizes="180x180">
    
  
  <!-- title -->
  <title>Shio&#39;s Psycology Life Vue源码探究-状态初始化 </title>
  <!-- styles -->
  <!-- styles -->

<link rel="stylesheet" href="/styles/global.css">

  <!-- rss -->
  
  <link rel="alternate" href="/atom.xml" title="Shio&#39;s Psycology Life" type="application/atom+xml" />
  
<meta name="generator" content="Hexo 4.2.1"></head>
  <body>
    <header id="header">
  
  <nav class="menu menu--right">
  
    <a class="menu__item" href="/">主页</a>
    <a class="menu__item" href="/archives/">归档</a>
    <a class="menu__item" href="/categories/">专题</a>
    <a class="menu__item" href="/tags/">标签</a>
    <!-- <a class="menu__item" href="/">作品</a> -->
    <!-- <a class="menu__item" href="/about/">关于</a> -->
  </nav>
</header>
    <main>
      <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post__header">
  <h1 class="post__title">Vue源码探究-状态初始化</h1>
  
  
  <div class="post__meta">
    
<time class="post__date" datetime="2018-08-10T06:23:31.000Z" itemprop="datePublished">
  
  <i class="blogfont">&#xedff;</i>
  
  2018-08-10 14:23:31
</time>

    
<div class="post__category">
  <i class="blogfont">&#xe62d;</i>
  <a class="category-link" href="/categories/Dev/">Dev</a>, <a class="category-link" href="/categories/Dev/Explore-Vue/">Explore Vue</a>
</div>
  

    
<div class="post__tag">
  <i class="blogfont">&#xe7ec;</i>
  <a class="tag-link" href="/tags/Vue/" rel="tag">Vue</a>
</div>


    <div id="/2018-08-10/vue-initial-of-states/" class="leancloud_visitors post__stat" data-flag-title="Vue源码探究-状态初始化">
  <i class="blogfont">&#xe672;</i>
  <span class="leancloud-visitors-count">loading...</span>
</div>
  </div>
</header>
  <aside class="post__aside">
  <div class="post__actions">
    <a id="backTop" class="post__top" href="javascript:">
      <i class="blogfont">&#xe6b1;</i><!-- 回到顶部 -->
    </a>
    <!-- <a id="share" class="post__share" href="javascript:">
      <i class="blogfont">&#xe6c1;</i>
    </a> -->
  </div>
  <ol class="post__toc"><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#initState"><span class="post__toc-text">initState</span></a><ol class="post__toc-child"><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#initProps"><span class="post__toc-text">initProps</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#initData"><span class="post__toc-text">initData</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#initComputed"><span class="post__toc-text">initComputed</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#initMethods"><span class="post__toc-text">initMethods</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#initWatch"><span class="post__toc-text">initWatch</span></a></li></ol></li><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#stateMixin"><span class="post__toc-text">stateMixin</span></a></li></ol>
</aside>
  <div class="post__content" itemprop="articleBody">
    <p><em>本篇代码位于<a href="https://github.com/vuejs/vue/blob/v2.5.17-beta.0/src/core/instance/state.js" target="_blank" rel="noopener">vue/src/core/instance/state.js</a></em></p>
<p>继续随着核心类的初始化展开探索其他的模块，这一篇来研究一下Vue的状态初始化。这里的状态初始化指的就是在创建实例的时候，在配置对象里定义的属性、数据变量、方法等是如何进行初始处理的。由于随后的数据更新变动都交给观察系统来负责，所以在事先弄明白了数据绑定的原理之后，就只需要将目光集中在这一部分。</p>
<p>来仔细看看在核心类中首先执行的关于 <code>state</code> 部分的源码：</p>
<h2 id="initState"><a href="#initState" class="headerlink" title="initState"></a>initState</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义并导出initState函数，接收参数vm</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initState</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化实例的私有属性_watchers</span></span><br><span class="line">  <span class="comment">// 这就是在观察系统里会使用到的存储所有显式监视器的对象</span></span><br><span class="line">  vm._watchers = []</span><br><span class="line">  <span class="comment">// 获取实例的配置对象</span></span><br><span class="line">  <span class="keyword">const</span> opts = vm.$options</span><br><span class="line">  <span class="comment">// 如果定义了props，则初始化props</span></span><br><span class="line">  <span class="keyword">if</span> (opts.props) initProps(vm, opts.props)</span><br><span class="line">  <span class="comment">// 如果定义了methods，则初始化methods</span></span><br><span class="line">  <span class="keyword">if</span> (opts.methods) initMethods(vm, opts.methods)</span><br><span class="line">  <span class="comment">// 如果定义了data，则初始化data</span></span><br><span class="line">  <span class="keyword">if</span> (opts.data) &#123;</span><br><span class="line">    initData(vm)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 否则初始化实例的私有属性_data为空对象，并开启观察</span></span><br><span class="line">    observe(vm._data = &#123;&#125;, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果定义了computed，则初始化计算属性</span></span><br><span class="line">  <span class="keyword">if</span> (opts.computed) initComputed(vm, opts.computed)</span><br><span class="line">  <span class="comment">// 如果定义了watch并且不是nativeWatch，则初始化watch</span></span><br><span class="line">  <span class="comment">// nativeWatch是火狐浏览器下定义的对象的原型方法</span></span><br><span class="line">  <span class="keyword">if</span> (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</span><br><span class="line">    initWatch(vm, opts.watch)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码非常直白，主要用来执行配置对象里定义的了状态的初始化。这里分别有 <code>props</code>、<code>data</code>、<code>methods</code>、<code>computed</code>、<code>watch</code> 五个配置对象，分别有各自的初始化方法。在仔细研究它们的具体实现之前，先来看一段将在各个初始化函数里用到的辅助函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义共享属性定义描述符对象sharedPropertyDefinition</span></span><br><span class="line"><span class="comment">// 描述符对象的枚举和可配置属性都设置为true</span></span><br><span class="line"><span class="comment">// get、set方法设置为空函数</span></span><br><span class="line"><span class="keyword">const</span> sharedPropertyDefinition = &#123;</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  <span class="keyword">get</span>: noop,</span><br><span class="line">  <span class="keyword">set</span>: noop</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义并导出proxy函数，该函数用来为在目标对象上定义并代理属性</span><br><span class="line">// 接收目标对象target，路径键名sourceKey，属性键名三个参数</span><br><span class="line">export function proxy (target: Object, sourceKey: string, key: string) &#123;</span><br><span class="line">  <span class="comment">// 设置属性描述符对象的get方法</span></span><br><span class="line">  sharedPropertyDefinition.get = <span class="function"><span class="keyword">function</span> <span class="title">proxyGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[sourceKey][key]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置属性描述性对象的set犯法</span></span><br><span class="line">  sharedPropertyDefinition.set = <span class="function"><span class="keyword">function</span> <span class="title">proxySetter</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>[sourceKey][key] = val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在目标对象上定义属性</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, key, sharedPropertyDefinition)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>proxy</code> 函数的定义非常重要，在下面要探究的各个初始化函数中它，它会将我们在配置对象中设置的属性全部定义到实例对象中，但是我们对这些属性的操作是通过各部分相应的代理属性上来执行的。<code>get</code> 和 <code>set</code> 方法的实现非常明白的表示出这一过程，然后再将属性定义到实例中。由这个函数作为基础，继续来看看其他五个状态的初始化函数的内容。</p>
<h3 id="initProps"><a href="#initProps" class="headerlink" title="initProps"></a>initProps</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义initProps函数，接收vm，propsOptions两个参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initProps</span> (<span class="params">vm: Component, propsOptions: Object</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 赋值propsData，propsData是全局扩展传入的赋值对象</span></span><br><span class="line">  <span class="comment">// 在使用extend的时候会用到，实际开发里运用较少</span></span><br><span class="line">  <span class="keyword">const</span> propsData = vm.$options.propsData || &#123;&#125;</span><br><span class="line">  <span class="comment">// 定义实例的_props私有属性，并赋值给props</span></span><br><span class="line">  <span class="keyword">const</span> props = vm._props = &#123;&#125;</span><br><span class="line">  <span class="comment">// 缓存prop键，以便将来props更新可以使用Array而不是动态对象键枚举进行迭代。</span></span><br><span class="line">  <span class="comment">// cache prop keys so that future props updates can iterate using Array</span></span><br><span class="line">  <span class="comment">// instead of dynamic object key enumeration.</span></span><br><span class="line">  <span class="keyword">const</span> keys = vm.$options._propKeys = []</span><br><span class="line">  <span class="comment">// 是否是根实例</span></span><br><span class="line">  <span class="keyword">const</span> isRoot = !vm.$parent</span><br><span class="line">  <span class="comment">// 对于非根实例，关闭观察标识</span></span><br><span class="line">  <span class="comment">// root instance props should be converted</span></span><br><span class="line">  <span class="keyword">if</span> (!isRoot) &#123;</span><br><span class="line">    toggleObserving(<span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遍历props配置对象</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> propsOptions) &#123;</span><br><span class="line">    <span class="comment">// 向缓存键值数组中添加键名</span></span><br><span class="line">    keys.push(key)</span><br><span class="line">    <span class="comment">// 验证prop的值，validateProp执行对初始化定义的props的类型检查和默认赋值</span></span><br><span class="line">    <span class="comment">// 如果有定义类型检查，布尔值没有默认值时会被赋予false，字符串默认undefined</span></span><br><span class="line">    <span class="comment">// 对propsOptions的比较也是在使用extend扩展时才有意义</span></span><br><span class="line">    <span class="comment">// 具体实现可以参考 src/core/util/props.js，没有难点这里不详细解释</span></span><br><span class="line">    <span class="keyword">const</span> value = validateProp(key, propsOptions, propsData, vm)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非生产环境下进行检查和提示</span></span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="comment">// 进行键名的转换，将驼峰式转换成连字符式的键名</span></span><br><span class="line">      <span class="keyword">const</span> hyphenatedKey = hyphenate(key)</span><br><span class="line">      <span class="comment">// 对与保留变量名冲突的键名给予提示</span></span><br><span class="line">      <span class="keyword">if</span> (isReservedAttribute(hyphenatedKey) ||</span><br><span class="line">          config.isReservedAttr(hyphenatedKey)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`"<span class="subst">$&#123;hyphenatedKey&#125;</span>" is a reserved attribute and cannot be used as component prop.`</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 对属性建立观察，并在直接使用属性时给予警告</span></span><br><span class="line">      defineReactive(props, key, value, () =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (vm.$parent &amp;&amp; !isUpdatingChildComponent) &#123;</span><br><span class="line">          warn(</span><br><span class="line">            <span class="string">`Avoid mutating a prop directly since the value will be `</span> +</span><br><span class="line">            <span class="string">`overwritten whenever the parent component re-renders. `</span> +</span><br><span class="line">            <span class="string">`Instead, use a data or computed property based on the prop's `</span> +</span><br><span class="line">            <span class="string">`value. Prop being mutated: "<span class="subst">$&#123;key&#125;</span>"`</span>,</span><br><span class="line">            vm</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 非生产环境下直接对属性进行存取器包装，建立依赖观察</span></span><br><span class="line">      defineReactive(props, key, value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用Vue.extend()方法扩展属性时，已经对静态属性进行了代理</span></span><br><span class="line">    <span class="comment">// 这里只需要针对实例化时的属性执行代理操作</span></span><br><span class="line">    <span class="comment">// static props are already proxied on the component's prototype</span></span><br><span class="line">    <span class="comment">// during Vue.extend(). We only need to proxy props defined at</span></span><br><span class="line">    <span class="comment">// instantiation here.</span></span><br><span class="line">    <span class="comment">// 当实例上没有同名属性时，对属性进行代理操作</span></span><br><span class="line">    <span class="comment">// 将对键名的引用指向vm._props对象中</span></span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">      proxy(vm, <span class="string">`_props`</span>, key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 开启观察状态标识</span></span><br><span class="line">  toggleObserving(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>initProps</code> 函数的最主要内容有两点，一是对定义的数据建立观察，二是对数据进行代理，这就是私有变量 <code>_props</code> 的作用，之后获取和设置的变量都是作为 <code>_props</code> 的属性被操作。</p>
<p>另外初始化 <code>props</code> 的过程中有针对 <code>extend</code> 方法会使用到的 <code>propsData</code> 属性的初始化。具体使用是在扩展对象时定义一些 props，然后在创建实例的过程中传入  propsData 配置对象，扩展对象里相应的props属性会接收 propsData 传入的值。与在父组件传入 props 的值类似，只是这里要显式的通过 <code>propsData</code> 配置对象来传入值。</p>
<h3 id="initData"><a href="#initData" class="headerlink" title="initData"></a>initData</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义initData函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initData</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取配置对象的data属性</span></span><br><span class="line">  <span class="keyword">let</span> data = vm.$options.data</span><br><span class="line">  <span class="comment">// 判断data是否是函数</span></span><br><span class="line">  <span class="comment">// 若是函数则将getData函数的返回赋值给data和实例私有属性_data</span></span><br><span class="line">  <span class="comment">// 否则直接将data赋值给实例_data属性，并在无data时赋值空对象</span></span><br><span class="line">  data = vm._data = <span class="keyword">typeof</span> data === <span class="string">'function'</span></span><br><span class="line">    ? getData(data, vm)</span><br><span class="line">    : data || &#123;&#125;</span><br><span class="line">  <span class="comment">// 如果data不是对象则将data赋值为空对象</span></span><br><span class="line">  <span class="comment">// 进一步保证data是对象类型</span></span><br><span class="line">  <span class="keyword">if</span> (!isPlainObject(data)) &#123;</span><br><span class="line">    data = &#123;&#125;</span><br><span class="line">    <span class="comment">// 在非生产环境下给出警告提示</span></span><br><span class="line">    process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">      <span class="string">'data functions should return an object:\n'</span> +</span><br><span class="line">      <span class="string">'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function'</span>,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 实例对象代理data</span></span><br><span class="line">  <span class="comment">// proxy data on instance</span></span><br><span class="line">  <span class="comment">// 获取所有data键值</span></span><br><span class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(data)</span><br><span class="line">  <span class="comment">// 获取配置对象的props</span></span><br><span class="line">  <span class="keyword">const</span> props = vm.$options.props</span><br><span class="line">  <span class="comment">// 获取配置对象的methods</span></span><br><span class="line">  <span class="keyword">const</span> methods = vm.$options.methods</span><br><span class="line">  <span class="comment">// 遍历keys</span></span><br><span class="line">  <span class="keyword">let</span> i = keys.length</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = keys[i]</span><br><span class="line">    <span class="comment">// 非生产环境给出与methods定义的方法名冲突的警告</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (methods &amp;&amp; hasOwn(methods, key)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`Method "<span class="subst">$&#123;key&#125;</span>" has already been defined as a data property.`</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检测是否与props冲突</span></span><br><span class="line">    <span class="keyword">if</span> (props &amp;&amp; hasOwn(props, key)) &#123;</span><br><span class="line">      <span class="comment">// 非生产环境给出冲突警告</span></span><br><span class="line">      process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">        <span class="string">`The data property "<span class="subst">$&#123;key&#125;</span>" is already declared as a prop. `</span> +</span><br><span class="line">        <span class="string">`Use prop default value instead.`</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    <span class="comment">// 没有与props冲突并且非保留字时，代理键名到实例的_data对象上</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isReserved(key)) &#123;</span><br><span class="line">      proxy(vm, <span class="string">`_data`</span>, key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 观察数据</span></span><br><span class="line">  <span class="comment">// observe data</span></span><br><span class="line">  observe(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义并导出getData函数，接受函数类型的data对象，和Vue实例对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getData</span> (<span class="params">data: Function, vm: Component</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="comment">// pushTarget和popTarget是为了解决Vue依赖性检测的缺陷可能导致冗余依赖性的问题</span></span><br><span class="line">  <span class="comment">// 具体可参阅 https://github.com/vuejs/vue/issues/7573</span></span><br><span class="line">  <span class="comment">// 此操作会设置Dep.target为undefined，在初始化option时调用dep.depend()也不会建立依赖</span></span><br><span class="line">  <span class="comment">// #7573 调用数据getter时禁用dep集合</span></span><br><span class="line">  <span class="comment">// #7573 disable dep collection when invoking data getters</span></span><br><span class="line">  pushTarget()</span><br><span class="line">  <span class="comment">// 尝试在vm上调用data函数并返回执行结果</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> data.call(vm, vm)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// 如果捕获到错误则处理错误，并返回空对象</span></span><br><span class="line">    handleError(e, vm, <span class="string">`data()`</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    popTarget()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 props 的处理类似，<code>initData</code> 函数的作用也是为了对数据建立观察的依赖关系，并且代理数据到私有变量 <code>_data</code> 上，另外包括了对 data 与其他配置对象属性的键名冲突的检测。</p>
<h3 id="initComputed"><a href="#initComputed" class="headerlink" title="initComputed"></a>initComputed</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置computedWatcherOptions对象</span></span><br><span class="line"><span class="keyword">const</span> computedWatcherOptions = &#123; <span class="attr">computed</span>: <span class="literal">true</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义initComputed函数，接受实例vm，和computed对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initComputed</span> (<span class="params">vm: Component, computed: Object</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="comment">// 定义watchers和实例_computedWatchers属性，初始赋值空对象</span></span><br><span class="line">  <span class="keyword">const</span> watchers = vm._computedWatchers = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  <span class="comment">// 是否是服务器渲染，computed属性在服务器渲染期间只能是getter</span></span><br><span class="line">  <span class="comment">// computed properties are just getters during SSR</span></span><br><span class="line">  <span class="keyword">const</span> isSSR = isServerRendering()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历computed</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> computed) &#123;</span><br><span class="line">    <span class="comment">// 获取用户定义的值</span></span><br><span class="line">    <span class="keyword">const</span> userDef = computed[key]</span><br><span class="line">    <span class="comment">// 如果用户定义的是函数则赋值给getter否则j将userDef.get方法赋值给getter</span></span><br><span class="line">    <span class="keyword">const</span> getter = <span class="keyword">typeof</span> userDef === <span class="string">'function'</span> ? userDef : userDef.get</span><br><span class="line">    <span class="comment">// 非生产环境抛出缺少计算属性错误警告</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; getter == <span class="literal">null</span>) &#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">`Getter is missing for computed property "<span class="subst">$&#123;key&#125;</span>".`</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非服务器渲染下</span></span><br><span class="line">    <span class="keyword">if</span> (!isSSR) &#123;</span><br><span class="line">      <span class="comment">// 为计算属性创建内部监视器</span></span><br><span class="line">      <span class="comment">// create internal watcher for the computed property.</span></span><br><span class="line">      watchers[key] = <span class="keyword">new</span> Watcher(</span><br><span class="line">        vm,</span><br><span class="line">        getter || noop,</span><br><span class="line">        noop,</span><br><span class="line">        computedWatcherOptions</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组件定义的内部计算属性已经在组件的原型上定义好了</span></span><br><span class="line">    <span class="comment">// 所以这里只要关注实例初始化时用户定义的计算属性</span></span><br><span class="line">    <span class="comment">// component-defined computed properties are already defined on the</span></span><br><span class="line">    <span class="comment">// component prototype. We only need to define computed properties defined</span></span><br><span class="line">    <span class="comment">// at instantiation here.</span></span><br><span class="line">    <span class="comment">// 键名非实例根属性时，定义计算属性，具体参照defineComputed函数</span></span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">      defineComputed(vm, key, userDef)</span><br><span class="line">    <span class="comment">// 非生产环境下，检测与data属性名的冲突并给出警告</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (key <span class="keyword">in</span> vm.$data) &#123;</span><br><span class="line">        warn(<span class="string">`The computed property "<span class="subst">$&#123;key&#125;</span>" is already defined in data.`</span>, vm)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vm.$options.props &amp;&amp; key <span class="keyword">in</span> vm.$options.props) &#123;</span><br><span class="line">        warn(<span class="string">`The computed property "<span class="subst">$&#123;key&#125;</span>" is already defined as a prop.`</span>, vm)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义并导出defineComputed哈数</span></span><br><span class="line"><span class="comment">// 接收实例target，计算属性键名key，计算属性值userDef参数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineComputed</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  target: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  userDef: Object | Function</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在非服务器渲染下设置缓存</span></span><br><span class="line">  <span class="keyword">const</span> shouldCache = !isServerRendering()</span><br><span class="line">  <span class="comment">// 计算属性值是函数时</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> userDef === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="comment">// 设置计算属性的getter，setter为空函数</span></span><br><span class="line">    sharedPropertyDefinition.get = shouldCache</span><br><span class="line">      ? createComputedGetter(key)</span><br><span class="line">      : userDef</span><br><span class="line">    sharedPropertyDefinition.set = noop</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 当计算属性是对象时，设置计算属性的getter和setter</span></span><br><span class="line">    sharedPropertyDefinition.get = userDef.get</span><br><span class="line">      ? shouldCache &amp;&amp; userDef.cache !== <span class="literal">false</span></span><br><span class="line">        ? createComputedGetter(key)</span><br><span class="line">        : userDef.get</span><br><span class="line">      : noop</span><br><span class="line">    sharedPropertyDefinition.set = userDef.set</span><br><span class="line">      ? userDef.set</span><br><span class="line">      : noop</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 非生产环境下，如果没哟定义计算属性的setter</span></span><br><span class="line">  <span class="comment">// 想设置计算属性时给出警告</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">      sharedPropertyDefinition.set === noop) &#123;</span><br><span class="line">    sharedPropertyDefinition.set = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">`Computed property "<span class="subst">$&#123;key&#125;</span>" was assigned to but it has no setter.`</span>,</span><br><span class="line">        <span class="keyword">this</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 以重新设置的属性描述符为基础在实例对象上定义计算属性</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, key, sharedPropertyDefinition)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义createComputedGetter，创建计算属性getter</span></span><br><span class="line"><span class="comment">// 目的是在非服务器渲染情况下建立计算属性的观察依赖，</span></span><br><span class="line"><span class="comment">// 并根据其依赖属性返回计算后的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComputedGetter</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">computedGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> watcher = <span class="keyword">this</span>._computedWatchers &amp;&amp; <span class="keyword">this</span>._computedWatchers[key]</span><br><span class="line">    <span class="keyword">if</span> (watcher) &#123;</span><br><span class="line">      watcher.depend()</span><br><span class="line">      <span class="keyword">return</span> watcher.evaluate()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>计算属性的初始化相对复杂一些，首先要对计算属性建立观察，然后再在实例上重新定义计算属性，并且执行属性代理。由于加入了服务器渲染的功能，在定义计算属性的时候对使用环境做判断，是非服务器渲染会影响到计算属性的定义，这是由于服务器渲染下使用框架时，计算属性是不提供 setter 的；另外也要根据用户定义的值是函数或者对象来对计算属性重新定义 getter 和 setter。从这段代码里可以看出一个非常重要的程序，即在获取计算属性的时候才去计算它的值，这正是懒加载的实现。</p>
<h3 id="initMethods"><a href="#initMethods" class="headerlink" title="initMethods"></a>initMethods</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义initMethods方法，接受实例vm，配置属性methods</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initMethods</span> (<span class="params">vm: Component, methods: Object</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取实例的props</span></span><br><span class="line">  <span class="keyword">const</span> props = vm.$options.props</span><br><span class="line">  <span class="comment">// 遍历methods对象</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> methods) &#123;</span><br><span class="line">    <span class="comment">// 非生产环境下给出警告</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="comment">// 未赋值方法警告</span></span><br><span class="line">      <span class="keyword">if</span> (methods[key] == <span class="literal">null</span>) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`Method "<span class="subst">$&#123;key&#125;</span>" has an undefined value in the component definition. `</span> +</span><br><span class="line">          <span class="string">`Did you reference the function correctly?`</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 与props属性名冲突警告</span></span><br><span class="line">      <span class="keyword">if</span> (props &amp;&amp; hasOwn(props, key)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`Method "<span class="subst">$&#123;key&#125;</span>" has already been defined as a prop.`</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 与保留字冲突警告</span></span><br><span class="line">      <span class="keyword">if</span> ((key <span class="keyword">in</span> vm) &amp;&amp; isReserved(key)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`Method "<span class="subst">$&#123;key&#125;</span>" conflicts with an existing Vue instance method. `</span> +</span><br><span class="line">          <span class="string">`Avoid defining component methods that start with _ or $.`</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在实例上定义方法，赋值为用户未定义函数或空函数</span></span><br><span class="line">    vm[key] = methods[key] == <span class="literal">null</span> ? noop : bind(methods[key], vm)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>initMethods</code> 函数非常简单，除了一大段在非生产环境里报告检查冲突的代码，唯一的内容就是在实例上定义相应的方法并且把上下文绑定到实例对象上，这样即便不是使用箭头函数，在方法内也默认用 this 指代了实例对象。</p>
<h3 id="initWatch"><a href="#initWatch" class="headerlink" title="initWatch"></a>initWatch</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义initWatch函数，接受实例vm和配置属性watch</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initWatch</span> (<span class="params">vm: Component, watch: Object</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 遍历watch</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> watch) &#123;</span><br><span class="line">    <span class="comment">// 暂存属性的值</span></span><br><span class="line">    <span class="keyword">const</span> handler = watch[key]</span><br><span class="line">    <span class="comment">// 如果handler是数组</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(handler)) &#123;</span><br><span class="line">      <span class="comment">// 遍历数组为每一个元素创建相应watcher</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; handler.length; i++) &#123;</span><br><span class="line">        createWatcher(vm, key, handler[i])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 窦否则handler应该是函数，直接为key创建watcher</span></span><br><span class="line">      createWatcher(vm, key, handler)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义createWatcher函数</span></span><br><span class="line"><span class="comment">// 接受实例vm、表达式或函数expOrFn，处理器handler，可选的options</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWatcher</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vm: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  expOrFn: string | Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  handler: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  options?: Object</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果handler是对象</span></span><br><span class="line">  <span class="keyword">if</span> (isPlainObject(handler)) &#123;</span><br><span class="line">    <span class="comment">// 将handler赋值给options.</span></span><br><span class="line">    options = handler</span><br><span class="line">    <span class="comment">// 重新赋值handler</span></span><br><span class="line">    handler = handler.handler</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果handler是字符串，在实例上寻找handler并赋值给handler</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> handler === <span class="string">'string'</span>) &#123;</span><br><span class="line">    handler = vm[handler]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建观察并返回</span></span><br><span class="line">  <span class="keyword">return</span> vm.$watch(expOrFn, handler, options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>initWatcher</code> 为传入的观察对象创建监视器，比较简单。值得注意的是参数的传入类型，观察对象 <code>expOrFn</code> 可以有两种方式，一种是字符串，一种是函数，在 <code>Watcher</code> 类中对此参数进行了检测，而在初始化的函数里不对它做任何处理。<code>handler</code> 对象也可以接受对象或字符串类型，在代码中对这两种传入方式做判断，最终找到handler引用的函数传入 <code>$watch</code>。</p>
<h2 id="stateMixin"><a href="#stateMixin" class="headerlink" title="stateMixin"></a>stateMixin</h2><p>探索完了 <code>initState</code> 函数之后，继续来看看 <code>state</code> 混入的方法 <code>stateMixin</code>，在这个函数里会提供上面还未曾提到的 <code>$watch</code> 方法的具体实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义并导出stateMixin函数，接收参数Vue</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">stateMixin</span> (<span class="params">Vue: Class&lt;Component&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 使用 Object.defineProperty 方法直接声明定义对象时，flow会发生问题</span></span><br><span class="line">  <span class="comment">// 所以必须在此程序化定义对象</span></span><br><span class="line">  <span class="comment">// flow somehow has problems with directly declared definition object</span></span><br><span class="line">  <span class="comment">// when using Object.defineProperty, so we have to procedurally build up</span></span><br><span class="line">  <span class="comment">// the object here.</span></span><br><span class="line">  <span class="comment">// 定义dataDef对象</span></span><br><span class="line">  <span class="keyword">const</span> dataDef = &#123;&#125;</span><br><span class="line">  <span class="comment">// 定义dataDef的get方法，返回Vue实例私有属性_data</span></span><br><span class="line">  dataDef.get = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>._data &#125;</span><br><span class="line">  <span class="comment">// 定义propsDef对象</span></span><br><span class="line">  <span class="keyword">const</span> propsDef = &#123;&#125;</span><br><span class="line">  <span class="comment">// 定义propsDef的get方法，返回Vue实例私有属性_props</span></span><br><span class="line">  propsDef.get = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>._props &#125;</span><br><span class="line">  <span class="comment">// 非生产环境下，定义dataDef和propsDef的set方法</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    <span class="comment">// dataDef的set方法接收Object类型的newData形参</span></span><br><span class="line">    dataDef.set = <span class="function"><span class="keyword">function</span> (<span class="params">newData: Object</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 提示避免传入对象覆盖属性$data</span></span><br><span class="line">      <span class="comment">// 推荐使用嵌套的数据属性代替</span></span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">'Avoid replacing instance root $data. '</span> +</span><br><span class="line">        <span class="string">'Use nested data properties instead.'</span>,</span><br><span class="line">        <span class="keyword">this</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置propsDef的set方法为只读</span></span><br><span class="line">    propsDef.set = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      warn(<span class="string">`$props is readonly.`</span>, <span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定义Vue原型对象公共属性$data，并赋值为dataDef</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">'$data'</span>, dataDef)</span><br><span class="line">  <span class="comment">// 定义Vue原型对象公共属性$props，并赋值为propsDef</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">'$props'</span>, propsDef)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义Vue原型对象的$set方法，并赋值为从观察者导入的set函数</span></span><br><span class="line">  Vue.prototype.$<span class="keyword">set</span> = <span class="keyword">set</span></span><br><span class="line">  // 定义Vue原型对象的$delete方法，并赋值为从观察者导入的del函数</span><br><span class="line">  Vue.prototype.$delete = del</span><br><span class="line"></span><br><span class="line">  // 定义Vue原型对象的$watch方法</span><br><span class="line">  // 接收字符串或函数类型的expOrFn，从命名中可看出希望为表达式或函数</span><br><span class="line">  // 接收任何类型的cb，这里希望为回调函数或者是一个对象</span><br><span class="line">  // 接收对象类型的options</span><br><span class="line">  // 要求返回函数类型</span><br><span class="line">  Vue.prototype.$watch = function (</span><br><span class="line">    expOrFn: string | Function,</span><br><span class="line">    cb: any,</span><br><span class="line">    options?: Object</span><br><span class="line">  ): Function &#123;</span><br><span class="line">    <span class="comment">// 把实例赋值给vm变量，类型需为Component</span></span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// 如果cb是纯粹的对象类型</span></span><br><span class="line">    <span class="keyword">if</span> (isPlainObject(cb)) &#123;</span><br><span class="line">      <span class="comment">// 返回createWatcher函数</span></span><br><span class="line">      <span class="keyword">return</span> createWatcher(vm, expOrFn, cb, options)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义观察目标的options，大多数情况下为undefined</span></span><br><span class="line">    options = options || &#123;&#125;</span><br><span class="line">    <span class="comment">// 定义options的user属性值为true，标识为用户定义</span></span><br><span class="line">    options.user = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 创建watcher实例</span></span><br><span class="line">    <span class="keyword">const</span> watcher = <span class="keyword">new</span> Watcher(vm, expOrFn, cb, options)</span><br><span class="line">    <span class="comment">// 如果options的immediate为真</span></span><br><span class="line">    <span class="keyword">if</span> (options.immediate) &#123;</span><br><span class="line">      <span class="comment">// 在vm上调用cb回调函数，并传入watcher.value作为参数</span></span><br><span class="line">      cb.call(vm, watcher.value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回unwatchFn函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unwatchFn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 执行watcher.teardown()方法清除观察</span></span><br><span class="line">      watcher.teardown()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>stateMixin执行的是关于状态观察的一系列方法的混入，主要是三个方面：</p>
<ul>
<li>定义实例 $data 和 $props 属性的存取器</li>
<li>定义实例的 $set、$delete 方法，具体实在定义在观察者模块中</li>
<li>定义实例的 $watch 方法</li>
</ul>
<p>到这里，关于状态初始化的部分就探索完毕了，接下来要继续研究另一个与开发过程紧密关联的部分——虚拟节点和模板渲染。</p>
<hr>
<p>状态初始化是与我们在开发的时候最息息相关的部分，在创建实例对象的配置对象中，我们设置了这些属性和方法，实例初始化的过程中对这些传入的配置进行了很多预先的处理，这就是状态初始化背后的逻辑。在探索到这一部分的时候才真正的感到，终于与平时的开发关联起来了。</p>

  </div>
  
  <section id="comments" class="comments">
    <div class="valine-comment"></div>
<!--载入js，在</body>之前插入即可-->
<!--Leancloud 操作库:-->
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<!--Valine 的核心代码库-->
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script>
new Valine({
    el: '.valine-comment',
    app_id: 'DKiK5z8iNqcTBYteGEiuxyaP-gzGzoHsz',
    app_key: '0SPtM0nGzQdGBXxpwbOSLTXV',
    placeholder: '有什么话想告诉我？',
    visitor: 'true',
  })
</script>
  </section>
  
</article>
    </main>
    <footer id="footer">
  Copyright &copy; 2025 Shio  
  <a class="social-links" href="mailto:jylzs369@163.com"
    ><i class="blogfont">&#xe61a; </i></a
  >
  
  <a class="social-links" href="https://www.jianshu.com/u/70c1c469e3b6"
    ><i class="blogfont">&#xe6d7; </i></a
  >
  
  <a class="social-links" href="https://www.zhihu.com/people/jylzs369"
    ><i class="blogfont">&#xe606; </i></a
  >
  
  <a class="social-links" href="/atom.xml"
    ><i class="blogfont">&#xe640; </i></a
  >
    <a href="https://beian.miit.gov.cn/" title="粤ICP备20052180号" target="_blank" rel="noopener">粤ICP备20052180号</a>
</footer>

    <!-- scripts -->

<script src="/scripts/main.js"></script>

  </body>
</html>